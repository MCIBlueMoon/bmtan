<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Unity 客户端面试</title>
    <link href="/2023/02/01/Unity%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    <url>/2023/02/01/Unity%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%9D%A2%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h1><h2 id="🌙Unity"><a href="#🌙Unity" class="headerlink" title="🌙Unity"></a>🌙Unity</h2><h3 id="生命周期问题"><a href="#生命周期问题" class="headerlink" title="生命周期问题"></a>生命周期问题</h3><ul><li><p><strong>Awake</strong></p><p>当一个脚本实例被载入时Awake被调用。我们大多在这个类中完成成员变量的初始化</p></li><li><p><strong>OnEnable</strong></p><p>当对象变为可用或激活状态时此函数被调用。</p></li><li><p><strong>Start</strong></p><p>仅在Update函数第一次被调用前调用。因为它是在Awake之后被调用的，我们可以把一些需要依赖Awake的变量放在Start里面初始化。 同时我们还大多在这个类中执行StartCoroutine进行一些协程的触发。要注意在用C#写脚本时，必须使用StartCoroutine开始一个协程。</p></li><li><p><strong>Update</strong></p><p>当MonoBehaviour启用时，其Update在每一帧被调用。</p></li><li><p><strong>FixedUpdate</strong></p><p>当MonoBehaviour启用时，其 FixedUpdate 在每一固定帧被调用。</p></li><li><p><strong>LateUpdate</strong> </p><p>是在所有Update函数调用后被调用。这可用于调整脚本执行顺序。例如:当物体在Update里移动时，跟随物体的相机可以在LateUpdate里实现</p></li><li><p><strong>OnGUI</strong> </p><p>渲染和处理GUI事件时调用 这里不是 没帧都调用哦</p></li><li><p><strong>OnDisable</strong></p><p>当对象变为不可用或非激活状态时此函数被调用。</p></li><li><p><strong>OnDestroy</strong></p><p>当MonoBehaviour将被销毁时，这个函数被调用。</p></li></ul><blockquote><p>物理更新一般放在哪个系统函数里？</p></blockquote><p><strong>FixedUpdate</strong>，每固定帧绘制时执行一次，和Update不同的是FixedUpdate是渲染帧执行，如果你的渲染效率低下的时候FixedUpdate调用次数就会跟着下降。<strong>FixedUpdate比较适用于物理引擎的计算，因为是跟每帧渲染有关。Update就比较适合做控制。</strong></p><blockquote><p>Unity中Awake和Start两个生命周期函数，分别在什么时候被调用？</p></blockquote><ul><li><strong>Awake：</strong>运行时<ol><li>当脚本被动态添加到对象上时立即被调用。</li><li>当对象被实例化时，依附它的脚本会立即调用Awake</li><li>它类似构造函数</li></ol></li><li><strong>Start：</strong>第一次Update之前被调用</li></ul><blockquote><p>Unity3d脚本从唤醒到销毁有着一套比较完整的生命周期，请列出系统自带的几个重要的方法。</p></blockquote><p>Awake——&gt;OnEnable–&gt;Start——&gt;Update——&gt;FixedUpdate——&gt;LateUpdate——&gt;OnGUI——&gt;OnDisable——&gt;OnDestroy</p><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/06-05/Unity%E8%84%9A%E6%9C%AC%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="img"></p><blockquote><p>Unity中鼠标、键盘、触屏、手柄等输入事件会在Update 之前、还是之后、还是同时执行？</p></blockquote><p>之前</p><h3 id="DrawCall问题"><a href="#DrawCall问题" class="headerlink" title="DrawCall问题"></a>DrawCall问题</h3><blockquote><p>什么是DrawCall?</p></blockquote><ul><li>DrawCall 是 Cpu准备好渲染的数据后告知GPU渲染的命令</li></ul><blockquote><p>DrawCall过高影响什么性能？</p></blockquote><ul><li>会造成很多额外的性能开销，且CPU会把大量时间花费再Draw Call 上，造成CPU过载。</li></ul><blockquote><p>如何降低DrawCall</p></blockquote><ol><li><p>小图合成大图，即多个小DrawCall变一次大DrawCall</p></li><li><p>拼面板时严格控制不同图集层级处理</p></li><li><p>静态批处理</p></li><li><p>动态批处理</p></li></ol><blockquote><p>静态批处理</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20201202110747790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xMTExMX18=,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>静态批处理自由度很高，限制很少，缺点可能会占用更多的内存，而且经过静态批处理后的所有物体都不可以再移动了</strong></p><p>只要勾选上Static并拥有相同材质的物体即可在运行时进行静态批处理<br><strong>但是静态批处理会为每一个物体创建一个合并后的Combined Mesh，需要额外的内存空间来存储合并后的Combined Mesh，所以使用时要慎用(例如一片浓密的草地，如果使用静态批处理则会造成严重的内存开销)</strong></p><blockquote><p>动态批处理 </p></blockquote><p><img src="https://img-blog.csdnimg.cn/20201201161048150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xMTExMX18=,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>动态批处理一切都是自动的，不需要做任何操作，而且物体是可以移动的，但是限制很多。</strong></p><p>动态批处理默认是关闭的，需要手动开启：Project Setting—Player—勾上Dynamic Batching（动态批处理）</p><p><font color = "red"><b>总结</b></font></p><p><font color = "red"><b>——静态批处理和动态批处理都能降低DrawCall，最主要的前提是物体使用同一个材质</b></font><br><font color = "red"><b>——静态批处理适用于场景中位置不会改变并且单对象不能太多的物体，像树林，草地这种用动态批处理更适合</b></font><br><font color = "red"><b>——动态批处理限制较多，顶点数要求，材质要求等等。静态批处理限制较少，是用内存换性能的方法，具体情况具体分析</b></font></p><blockquote><p><strong>DrawCall渲染问题</strong></p></blockquote><blockquote><p>图中的小球是否被渲染了？是否会产生DrawCall？</p></blockquote><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/DrawCallProblem1.png"></p><p>不会被渲染，不会产生DrawCall</p><p>Unity本身有摄像机视锥体剔除，也就是不会显示完全位于视锥体之外的游戏对象<br>那么小球就不会进行渲染，也不会提交数据给GPU，也就不会产生DrawCall</p><blockquote><p>在没有使用遮挡剔除的情况下，图中A和B都是默认标准材质，图中的小球最终是否会被渲染，是否会产生DrawCall</p></blockquote><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/DrawCallProblem2.png"></p><p>最终不会被渲染，标准材质存在深度测试，小球在立方体后方，不会通过深度测试，所以不会被渲染</p><p>会产生DrawCall，既然都深度测试了，那么肯定是存在DrawCall的<br>深度测试发生在片元着色器处理之后，GPU会对每个片元执行深度测试来决定遮挡关系，决定是否被渲染</p><h3 id="图集问题"><a href="#图集问题" class="headerlink" title="图集问题"></a>图集问题</h3><blockquote><p>什么是图集</p></blockquote><p>我们可以将其理解为将一系列小图合并为一张大图，目的是为了降低DrawCall</p><blockquote><p>Unity打包图集的方式</p></blockquote><p><strong>（1）一种是使用系统自带的打包工具SpritePacker；</strong></p><p><strong>（2）使用SpriteAtlas进行打包图集</strong></p><p><strong>（3）使用TexturePacker打包图片并使用；</strong></p><h4 id="SpritePacker使用"><a href="#SpritePacker使用" class="headerlink" title="SpritePacker使用"></a>SpritePacker使用</h4><ol><li><p>将所需要的图片导入Unity中，注意不能放在Resources文件夹下(图片将不能被打包成图集)</p></li><li><p>选择需要打包成图集的图片（可以多选）在inspector面板里选择“Texture Type“为“Sprite （2D and UI）”，并Apply应用；</p></li></ol><p><img src="https://img-blog.csdnimg.cn/20210414152912571.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3podXl1cWlhbmcxMjM4,size_16,color_FFFFFF,t_70" alt="img"></p><ol start="3"><li>在”Packing Tag”选项里面填上图集的名称，该选项相同的图片会打包为同一个图集</li></ol><p><img src="https://img-blog.csdnimg.cn/20210414152951987.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3podXl1cWlhbmcxMjM4,size_16,color_FFFFFF,t_70" alt="img"></p><ol start="4"><li><p>选择菜单栏里面的 “Edit” -&gt; “Project Settings” -&gt; “Editor”</p></li><li><p>在inspector面板里设置“Sprite Packers”下面的“Mode”选项，</p><p>其中</p><p>“Disabled”表示关闭图集功能，</p><p>“Enabled for Builds”表示打包发布时才打包图集，</p><p>“Always Enable”表示始终打包图集；</p><p>Enabled for Builds（Legacy Sprite Packer）表示打包发布时才打包图集（使用旧版技术）；</p><p>“Always Enable（Legacy Sprite Packer）”表示始终打包图集（使用旧版技术）</p></li></ol><p><img src="https://img-blog.csdnimg.cn/2021041415304878.png" alt="img"></p><ol start="6"><li>设置完上述选项后，选中需要打包图集的图片，在 “Window ” -&gt; “Sprite Packer”面板里预览图集，可尝试点击左上角的“Pack”按钮立即打包</li></ol><p><img src="https://img-blog.csdnimg.cn/20210414153138772.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3podXl1cWlhbmcxMjM4,size_16,color_FFFFFF,t_70" alt="img"></p><blockquote><p><strong>不同图片如何合并至一个图集？</strong></p></blockquote><ul><li>选中需要打包图集的图片，将其类型修改Sprite （2D and UI），修改其Packing Tag为你自定义的名字。不同的图片，只要Tag相同，就可以打包到同一个图集里面。</li></ul><blockquote><p><strong>打图集策略</strong></p></blockquote><ol><li><p><strong>DefaultPackerPolicy</strong>：</p><p>是默认的打包方式，也是矩形打包方式。他会把所有的小图按照矩形的方式来排列，如果宽高不一样的图片，它们会自动补齐,使用方式就是tag设置时加上”[RECT]图集名”来设置。</p></li><li><p><strong>TightPackerPolicy</strong>：</p><p>是紧密打包方式，也就是尽可能的把图片都打包在图集上，这种方式要比DefaultPackerPolicy打包的图片更多一些，也就是更省空间,使用方式就是tag设置时加上”[TIGHT]图集名”来设置。</p></li><li><p><strong>TightRotateEnabledPackerPolicy</strong>：</p><p>是紧密可旋转打包方式,也就是使用紧密打包，并且允许精灵进行旋转。</p></li></ol><h4 id="SpriteAtlas使用"><a href="#SpriteAtlas使用" class="headerlink" title="SpriteAtlas使用"></a>SpriteAtlas使用</h4><p>Sprite Atlas 针对现有的图集打包系统Sprite Packer在性能和易用性上的不足，进行了全面改善。除此之外，相比Sprite Packer，Sprite Atlas将对精灵更多的控制权交还给用户。由用户来掌控图集的打包过程以及加载时机，更加利于对系统性能的控制。设置Edit–&gt;Project Settings –&gt;Editor —&gt;Mode为Always Enable。</p><p><strong>Sprite Atlas的主要有以下三个功能：</strong></p><ol><li><p>创建、编辑图集以及设定图集参数</p></li><li><p>添加图集Variant（变种）</p></li><li><p>运行时访问图集</p></li><li><p><strong>创建、编辑图集及参数设定</strong></p></li></ol><p>在Unity 2017.1版本之后，SpriteAtlas是一种资源，右击 Asset —&gt; Create —&gt;SpriteAtlas 可以像其它资源一样在Unity中创建，例如预制件、场景等。</p><p><img src="https://img-blog.csdnimg.cn/20210414153317781.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3podXl1cWlhbmcxMjM4,size_16,color_FFFFFF,t_70" alt="img"></p><p>这里可以支持多种类型，包括单个Sprite、Sliced Sprite、文件夹，以及这些类型的任意组合。</p><p>操作更加方便，对用户更友好。可以将文件夹，纹理或精灵分配给Sprite Atlas。可以将整个文件夹分配给Sprite Atlas资产，该文件夹中的所有纹理（包括子文件夹）都将被打包，使用起来非常方便。</p><p>此外，在检视窗口上还可以看到图集的一些参数设定，例如：打包时是否支持精灵旋转(Allow Rotation)、贴图的采样模式(Filter Mode)、压缩方式(Compression)等等。  在最下方的预览窗口中，可以查看图集的生成效果。这样就可以很清楚的知道图集的打包方式是否合理，是否存在大量被浪费的空间。</p><p>设计UI，添加几个Image，使用SpriteAtlas图集内部的图片作为Image原图片，发现DrawCall只需要一次就可以完成。</p><ol start="2"><li><strong>添加图集Variant（变种）</strong></li></ol><p>所谓Variant，就是指原有图集的一个变种。它会复制原有图集的贴图，并根据一个比例系数来调整复制贴图的大小。</p><p>这样的Variant通常用于为高分辨率和低分辨率的屏幕准备不同的图集。</p><p>因为如果只准备一套高分辨率的图集，在低分辨率的设备上占用内存过多。反之，如果只准备一套低分辨率图集，在高分辨率的设备上就会模糊。</p><p>通过Atlas Variant就可以很方便地解决该问题。如下图所示，SpriteAtlas .spriteatlas是新建的一个低清图集，在检视窗口中将Type设为Variant，Master Atlas设为SpriteAtlas。这里为了与原图进行更明显的对比，将Scale设为0.1， 点击Pack Preview。<br><img src="https://img-blog.csdnimg.cn/20210414153422968.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3podXl1cWlhbmcxMjM4,size_16,color_FFFFFF,t_70" alt="img"></p><ol start="3"><li><strong>运行时访问图集</strong></li></ol><p>我们经常会在代码中切换ui的图片，所以就需要单独加载图集中的每个精灵。</p><p>这样做的好处是，让用户可以更加直接地随时编辑图集，而且不用去单独加载图集中的每个精灵。</p><p>下面是一段动态换装的代码，该脚本通过LoadAsset加载SpriteAtlas类型的资源，再通过SpriteAtlas的GetSprite接口获取图集中的精灵，最后将精灵传递给SpriteRenderer。相较于基于Sprite Packer的实现，整个过程要简单直接的多。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">using</span> UnityEditor;<br><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> UnityEngine.U2D;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SpriteAtlasExample</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>       <br> <br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>      <span class="hljs-comment">//加载图集</span><br>        SpriteAtlas atlas = AssetDatabase.LoadAssetAtPath&lt;SpriteAtlas&gt;<br>            (<span class="hljs-string">&quot;Assets/Hero.spriteatlas&quot;</span>);<br> <br>        <span class="hljs-comment">//获取图集下的所有Sprite</span><br>        Sprite[] sp = <span class="hljs-keyword">new</span> Sprite[atlas.spriteCount];<br>        atlas.GetSprites(sp);<br>        print(sp.Length);<br> <br>        <span class="hljs-comment">//根据小图名称获取对应的Sprite</span><br>        Sprite sprite = atlas.GetSprite(<span class="hljs-string">&quot;nxxg&quot;</span>);<br>        <span class="hljs-keyword">if</span> (sprite != <span class="hljs-literal">null</span>)<br>        &#123;<br>            GetComponent&lt;SpriteRenderer&gt;().sprite = sprite;<br>        &#125;<br>       <br>    &#125;<br> <br> <br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> UnityEngine.U2D;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SpriteAtlasMgr</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SpriteAtlasMgr instance;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span><br>    &#123;<br>        instance = <span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> Dictionary&lt;<span class="hljs-built_in">string</span>, SpriteAtlas&gt; atlas = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">string</span>, SpriteAtlas&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddSpriteAtlas</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span> &#123; <br>        <span class="hljs-comment">//</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RemoveAtlas</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span> &#123;<br>        <span class="hljs-comment">//</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Sprite <span class="hljs-title">GetSpriteFromAtlas</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> sname</span>)</span> &#123;<br>        <span class="hljs-comment">//....</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Sprite <span class="hljs-title">GetSpriteFromAtlas</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> atlasname, <span class="hljs-built_in">string</span> sname</span>)</span><br>    &#123;<br>        <span class="hljs-comment">//....</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// public static SpriteAtlasMgr</span><br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <br>    &#125;<br><br>    <span class="hljs-comment">// Update is called once per frame</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span><br>    &#123;<br>        <br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="Prebab-预设体问题"><a href="#Prebab-预设体问题" class="headerlink" title="Prebab 预设体问题"></a>Prebab 预设体问题</h3><blockquote><p>简述prefab的用处</p></blockquote><p>在游戏运行时实例化，prefab相当于一个模板，对你已经有的素材、脚本、参数做一个默认的配置，以便于以后的修改，同时prefab打包的内容简化了导出的操作，便于团队的交流。</p><blockquote><p> 请简述一下Prefab（预制体）的本质是什么？</p></blockquote><p>Prefab的本质就是一个配置文件<br>其中记录了一个GameObject对象上挂载的脚本信息<br>并且记录了脚本信息中的可配置的属性信息</p><h3 id="Unity-协同程序和线程-进程问题"><a href="#Unity-协同程序和线程-进程问题" class="headerlink" title="Unity 协同程序和线程,进程问题"></a>Unity 协同程序和线程,进程问题</h3><blockquote><p>Unity 协程和线程,进程的区别</p></blockquote><p>在 Unity 中，协程、线程和进程都是实现多任务处理的方式</p><ul><li><p><strong>进程（Process）</strong></p><p>是Windows系统中的一个基本概念，是系统进行资源分配和调度的基本单位，是操作系统结构的基础他包含着运行一个程序所需要的基本资源。<strong>一个正在运行的应用程序在操作系统中被视为一个进程，进程可以包括一个或多个线程。</strong>　　　</p></li><li><p><strong>线程（Thread）</strong></p><p>是一种操作系统级别的多任务处理方式，是操纵系统能进行运算调度的最小单位，它被包含再进程之中，是进程中的实际运作单位。它允许在游戏运行时<strong>启动一个独立的执行流程，该执行流程不会阻塞主线程，可以并行执行</strong>，从而提高游戏的响应速度。线程可以用来处理一些耗时的操作，例如网络请求和文件读写等。在 Unity 中，<strong>使用线程需要注意线程安全问题，因为线程与主线程共享资源，需要采取一些措施来保证数据的一致性。</strong></p></li><li><p><strong>协程（Coroutine）</strong>。</p><p><font color = "red"><b>协程不是线程。协程的实现原理是迭代器，而迭代器的实现原理是状态机。</b></font></p><p> <strong>协程是伴随着主线程一起运行的一段程序。</strong></p><p><strong>是一种轻量级的线程</strong>，它可以在代码执行过程中暂停和恢复执行，避免了线程的上下文切换和锁竞争问题，同时协程也具有良好的可控性和可维护性。在 Unity 中，协程是通过 StartCoroutine 方法来启动的，<strong>协程的执行是在主线程中，而不是在一个独立的执行流程中。</strong></p><p><strong>一般应用一个应用程序只使用线程这一“资源”</strong>。</p><p>Unity只使用了一个线程，<strong>协程是一种”伪线程</strong>“。 </p><ol><li>协同程序（coroutine）,即协作式程序，一系列互相依赖的协程间依次使用CPU，每次只有一个协程工作，而其他协成处于休眠状态。协程实际上是在一个线程中，只不过每个协程对CPU进行分时，协程可以访问和使用unity的所有方法和component。　　　　</li><li>同一时间只能执行某个协程，协程适合对某个任务进行分时处理。</li><li>控制代码在特定的时间执行。　　　　</li><li><strong>协程不是线程，也不是异步执行，跟Update一样，在主线程中执行</strong>。不用考虑同步和锁的问题。　　　　</li><li>协程是一个分部组件，遇到条件（yield return）会挂起,直到条件满足才会被唤起执行后面的语句。</li></ol></li></ul><blockquote><p>线程与协程的区别</p></blockquote><p><strong>协程(协同程序)</strong>: 同一时间只能执行某个协程。开辟多个协程开销不大。<strong>协程适合对某任务进行分时处理。</strong></p><p><strong>线程:</strong> 同一时间可以同时执行多个线程。开辟多条线程开销很大。<strong>线程适合多任务同时处理。</strong></p><p> <font color = "red"><b>线程和协同程序的主要不同在于</b></font>：<strong>在多处理器情况下，从概念上来讲多线程程序同时运行多个线程；而协同程序是通过协作来完成，在任一指定时刻只有一个协同程序在运行，并且这个正在运行的协同程序只在必要时才会被挂起。</strong></p><blockquote><p>协程的主要作用</p></blockquote><p><strong>延迟执行</strong>：协程可以延迟执行某个任务，从而在指定时间后执行相应的操作。</p><p><strong>异步执行</strong>：协程可以在后台执行任务，从而避免卡顿和阻塞主线程。</p><p><strong>任务管理</strong>：协程可以管理多个任务，从而实现更灵活和可控的代码执行顺序。</p><p>协程是辅助主线程的操作，避免卡顿。</p><blockquote><p>什么是协同程序？</p></blockquote><p>在主线程运行的同时开启另一段逻辑处理，来协助当前程序的执行，协程很像多线程，但是不是多线程，Unity的协程实在每帧结束之后去检测yield的条件是否满足。</p><blockquote><p>请简述Unity中协程的原理</p></blockquote><p>Unity中的协同程序分为<strong>两部分</strong></p><ol><li>协程函数本体（<strong>迭代器函数</strong>）</li><li>协程调度器（<strong>协程管理器</strong>）</li></ol><p>协程利用迭代器函数的分步执行的特点<br>加上<br>协程调度器对迭代器函数们进行统一管理<br>根据迭代器函数的返回值来决定下一次执行函数逻辑的时间点<br>从而实现逻辑分时分步执行的目的</p><blockquote><p>Unity中的协同程序中yield return不同的内容，代表的含义不同</p><p>请说明下面这些yield return的含义</p></blockquote><ol><li>yield return 数字;</li><li>yield return null;</li><li>yield return new WaitForSeconds(数字);</li><li>yield return new WaitForFixedUpdate();</li><li>yield return new WaitForEndOfFrame();</li><li>yield break;</li></ol><p><strong>答案：</strong></p><ol><li>yield return 数字; 下一帧执行</li><li>yield return null;  下一帧执行</li><li>yield return new WaitForSeconds(数字); 等待指定秒后执行</li><li>yield return new WaitForFixedUpdate(); 等待下一个固定物理帧更新时执行</li><li>yield return new WaitForEndOfFrame(); 等待摄像机和GUI渲染完成后执行</li><li>yield break; 跳出协程</li></ol><blockquote><p>yield return 挂起的程序什么时候执行</p></blockquote><p>协同程序主要是Update()方法之后，LateUpdate()方法之前调用的</p><blockquote><p> 使用Unity协同程序进行异步加载时，底层是否会使用多线程？</p></blockquote><p>可能会<br>协同程序的原理是分时分步完成指定逻辑<br>在其中的某一步骤中，是可以使用多线程来完成某些加载操作的，多线程加载完成后，再进入协同程序的下一步继续执行</p><blockquote><p>Unity是否支持写成多线程程序？如果支持的话需要注意什么？</p></blockquote><p>1.只能从主线程访问Unity相关组件、对象以及<br>UnityEngine命名空间中的绝大部分内容<br>2.如果多线程中要和Unity主线程同时修改一些数据<br>可以通过lock关键词加锁</p><h3 id="Unity-Invoke问题"><a href="#Unity-Invoke问题" class="headerlink" title="Unity Invoke问题"></a>Unity Invoke问题</h3><ol><li><strong>Invoke</strong></li></ol><p>​       <strong>Invoke() 方法是 Unity3D 的一种委托机制</strong></p><p>​    如： Invoke(“Test”, 5);  它的意思是：5 秒之后调用 Test() 方法；</p><p>注意：</p><pre><code class="hljs">    1 ：它应该在 脚本的生命周期里的（Start、Update、OnGUI、FixedUpdate、LateUpdate）中被调用；    2：Invoke(); 不能接受含有参数的方法；    3：在 Time.ScaleTime = 0; 时， Invoke() 无效，因为它不会被调。</code></pre><ol start="2"><li><p><strong>InvokeRepeating</strong><br> <strong>InvokeRepeating(“Test”, 2 , 3);</strong> </p><p> 这个方法的意思是指：2 秒后调用 Test() 方法，并且之后每隔 3 秒调用一次 Test() 方法。</p><p> 被激活时设置了，但是此时将引擎对象设置为false,还会被执行。</p><pre><code class="hljs">还有三个重要的方法：IsInvoking：用来判断某方法是否被延时，即将执行。CancelInvoke()  : 停止当前脚本中所有的Invoke和InvokeRepeating方法。CancelInvoke(&quot;MethodName&quot;) ： 停止当前脚本某个Invoke和InvokeRepeating方法。</code></pre></li></ol><blockquote><p>Invoke与协程的区别</p></blockquote><p><strong>Invoke方法</strong>：执行没有被挂起，相当于设置完被调用函数的执行时间后即时向下执行。应用到每隔一段时间执行某个函数很方便。</p><p><strong>Coroutine方法</strong>：新开一条执行序列（跟新建线程差不多）并挂起，等待中断指令结束。开销不大。当需要挂起当前执行时使用。</p><p>协程的效率比Invoke高。</p><blockquote><p>正在运行的脚本，隐藏物体与禁止脚本导致OnDisable，Invoke与coroutine是否正常运行？</p></blockquote><p><strong>如果把物体直接隐藏：Invoke正常运行，coroutine不会正常运行。</strong></p><p><strong>原因：</strong></p><p>​    因为游戏物体隐藏了，一切与游戏物体相关的脚本生命周期都会停止，协程自然也会停止 ；    </p><p>​    如果游戏对象没有隐藏，只是将脚本隐藏，游戏对象照样可以通过反射获取协程迭代器对象继续协程的执行。</p><h3 id="Unity坐标系问题"><a href="#Unity坐标系问题" class="headerlink" title="Unity坐标系问题"></a>Unity坐标系问题</h3><blockquote><p>本地坐标系 世界坐标系</p></blockquote><ul><li><strong>世界坐标系</strong>：世界坐标是指物体在场景中的坐标，当某个物体没有父物体时，它的position即为世界坐标的position，rotation同理；本地坐标是物体相对于它的父物体的坐标而言，这个相对坐标是以父物体本身为坐标轴进行计算的，与世界坐标没有必然联系。而对于没有父物体的物体，可以认为不存在本地坐标这种说法。</li><li><strong>本地坐标系</strong>：当某个物体有父物体时，它的inspector栏transform中的position实际是localposition，即本地坐标。</li></ul><blockquote><p>Unity中如何将本地坐标转为世界坐标？</p></blockquote><ol><li>使用TransformPoint方法将本地坐标系转为世界坐标系</li><li>用本地坐标加上父对象相对世界的坐标（如果有多层父子关系，不停地往上加即可）</li></ol><blockquote><p>transform.forward和Vector3.forword的区别</p></blockquote><p>Vector3.forword始终时(0,0,1)<br>可以认为是世界坐标系的Z轴朝向</p><p>transform.forword是当前物体的局部坐标系的Z轴在世界坐标系下的朝向<br>可以认为是物体自己的Z轴朝向</p><h3 id="Unity碰撞器问题"><a href="#Unity碰撞器问题" class="headerlink" title="Unity碰撞器问题"></a>Unity碰撞器问题</h3><blockquote><p>Unity3d中的碰撞器和触发器的区别？</p></blockquote><p><strong>碰撞器</strong>是<em>触发器的载体</em>，而<strong>触发器</strong>只是<em>碰撞器身上的一个属性</em>。</p><p>当<strong>Is Trigger&#x3D;false</strong>时，碰撞器根据物理引擎引发碰撞，产生碰撞的效果，可以调用OnCollisionEnter&#x2F;Stay&#x2F;Exit函数；</p><p>当<strong>Is Trigger&#x3D;true</strong>时，碰撞器被物理引擎所忽略，没有碰撞效果，可以调用OnTriggerEnter&#x2F;Stay&#x2F;Exit函数。</p><p>如果既要检测到物体的接触又不想让碰撞检测影响物体移动或要检测一个物件是否经过空间中的某个区域这时就可以用到触发器</p><blockquote><p>物体发生碰撞的必要条件</p></blockquote><p><strong>两个物体都必须带有碰撞器</strong>（Collider），<strong>其中一个物体还必须带有Rigidbody刚体</strong>，而且必须是运动的物体带有Rigidbody脚本才能检测到碰撞。</p><blockquote><p>在物体发生碰撞的整个过程中，有几个阶段，分别列出对应的函数</p></blockquote><p><strong>三个阶段:</strong></p><ol><li>OnCollisionEnter </li><li>OnCollisionStay </li><li>OnCollisionExit</li></ol><blockquote><p>Unity中当一个细小高速物体撞击另一个较大物体时会出现什么情况？如何避免？</p></blockquote><p><strong>穿透</strong></p><ol><li>我们可以尽量用射线检测来替代细小物体的物理系统碰撞<br>因为传统的FPS游戏都是通过射线检测加模拟计算来判断伤害的</li><li>修改Rigidbody刚体中的<strong>Interpolate（插值）</strong>和<strong>CollisionDetection（碰撞检测）</strong>两个参数，来提高碰撞检测的准确性</li></ol><table><thead><tr><th><strong>Interpolate</strong></th><th>仅当在刚体运动中看到急动时才尝试使用提供的选项之一。</th></tr></thead><tbody><tr><td>- <strong>None</strong></td><td>不应用插值。</td></tr><tr><td>- <strong>Interpolate</strong></td><td>根据前一帧的变换来平滑变换。</td></tr><tr><td>- <strong>Extrapolate</strong></td><td>根据下一帧的估计变换来平滑变换。</td></tr><tr><td><strong>Collision Detection</strong></td><td>用于防止快速移动的对象穿过其他对象而不检测碰撞。</td></tr><tr><td>- <strong>Discrete</strong></td><td>对场景中的所有其他碰撞体使用离散碰撞检测。其他碰撞体在测试碰撞时会使用离散碰撞检测。用于正常碰撞（这是默认值）。</td></tr><tr><td>- <strong>Continuous</strong></td><td>对动态碰撞体（具有刚体）使用离散碰撞检测，并对静态碰撞体（没有刚体）使用基于扫掠的连续碰撞检测。设置为__连续动态 (Continuous Dynamic)__ 的刚体将在测试与该刚体的碰撞时使用连续碰撞检测。其他刚体将使用离散碰撞检测。用于__连续动态 (Continuous Dynamic)__ 检测需要碰撞的对象。（此属性对物理性能有很大影响，如果没有快速对象的碰撞问题，请将其保留为 <strong>Discrete</strong> 设置）</td></tr><tr><td>- <strong>Continuous Dynamic</strong></td><td>对设置为__连续 (Continuous)__ 和__连续动态 (Continuous Dynamic)__ 碰撞的游戏对象使用基于扫掠的连续碰撞检测。还将对静态碰撞体（没有刚体）使用连续碰撞检测。对于所有其他碰撞体，使用离散碰撞检测。用于快速移动的对象。</td></tr><tr><td>- <strong>Continuous Speculative</strong></td><td>对刚体和碰撞体使用推测性连续碰撞检测。这也是可以设置运动物体的唯一 CCD 模式。该方法通常比基于扫掠的连续碰撞检测的成本更低。</td></tr></tbody></table><h3 id="Unity-Camera问题"><a href="#Unity-Camera问题" class="headerlink" title="Unity Camera问题"></a>Unity Camera问题</h3><blockquote><p>在场景中放置多个Camera并同时处于活动状态会发生什么？</p></blockquote><p>游戏界面可以看到很多摄像机的混合。</p><blockquote><p>Unity中，照相机的Clipping Planes(剪裁屏幕)的作用是什么？调整Near、Fare两个值时，应该注意什么？</p></blockquote><p>剪裁平面 。从相机到开始渲染和停止渲染之间的距离。</p><blockquote><p>移动相机动作在哪个函数里，为什么在这个函数里？</p></blockquote><p>LateUpdate，是在所有的update结束后才调用，比较适合用于命令脚本的执行。官网上例子是摄像机的跟随，都是所有的update操作完才进行摄像机的跟进，不然就有可能出现摄像机已经推进了，但是视角里还未有角色的空帧出现。</p><blockquote><p>将Camera组件的ClearFlags选项选成Depth only是什么意思？有何用处？</p></blockquote><p>如果把摄像机的ClearFlags勾选为Deapth Only,那么摄像机就会只渲染看得见的对象，把背景会完全透明，这种情况一般用在两个摄像机以上的场景中</p><h3 id="Unity-动画问题"><a href="#Unity-动画问题" class="headerlink" title="Unity 动画问题"></a>Unity 动画问题</h3><blockquote><p>请描述游戏动画有哪几种，以及其原理？</p></blockquote><p>主要有关节动画、骨骼动画、单一网格模型动画(关键帧动画)。</p><ul><li><p><strong>关节动画</strong></p><p>把角色分成若干独立部分，一个部分对应一个网格模型，部分的动画连接成一个整体的动画，角色比较灵活，Quake2中使用这种动画；</p></li><li><p><strong>骨骼动画</strong></p><p>广泛应用的动画方式，集成了以上两个方式的优点，骨骼按角色特点组成一定的层次结构，有关节相连，可做相对运动，皮肤作为单一网格蒙在骨骼之外，决定角色的外观；</p></li><li><p><strong>单一网格模型动画</strong></p><p>由一个完整的网格模型构成，在动画序列的关键帧里记录各个顶点的原位置及其改变量，然后插值运算实现动画效果，角色动画较真实。</p></li></ul><blockquote><p><strong>Animation和Animator的区别</strong></p></blockquote><p>Animation和Animator 虽然都是控制动画的播放，但是它们的<strong>用法和相关语法都是大有不同</strong>的。</p><p><strong>Animation控制一个动画的播放</strong>，而<strong>Animator是多个动画之间相互切换</strong>，并且Animator有一个动画控制器，俗称动画状态机。</p><p>Animator利用它做动画的切换是很方便的，但是它有一个缺点就是占用内存比Animation大。</p><h3 id="Unity-光源问题"><a href="#Unity-光源问题" class="headerlink" title="Unity 光源问题"></a>Unity 光源问题</h3><blockquote><p>Unity提供了几种光源，分别是什么</p></blockquote><p>四种</p><ol><li><strong>平行光</strong>：Directional Light</li><li><strong>点光源</strong>：Point Light</li><li><strong>聚光灯</strong>：Spot Light</li><li><strong>区域光源</strong>：Area Light</li></ol><blockquote><p>实时点光源的优缺点是什么？</p></blockquote><p>可以有cookies – 带有 alpha通道的立方图(Cubemap )纹理。点光源是最耗费资源的.</p><blockquote><p>Unity中的光照贴图的作用是什么？</p></blockquote><p>在移动平台上（或配置较低的设备上）使用实时光源是非常消耗性能的<br>我们可以使用光照贴图，预先将环境光烘焙到贴图上，可以减少性能消耗</p><blockquote><p>两种阴影判断的方法、工作原理</p></blockquote><p><strong>本影和半影</strong></p><ul><li><p><strong>本影：</strong></p><p>景物表面上那些没有被光源直接照射的区域（全黑的轮廓分明的区域）。</p></li><li><p><strong>半影：</strong></p><p>景物表面上那些被某些特定光源直接照射但并非被所有特定光源直接照射的区域（半明半暗区域）</p></li></ul><h3 id="Unity-渲染问题"><a href="#Unity-渲染问题" class="headerlink" title="Unity 渲染问题"></a>Unity 渲染问题</h3><blockquote><p>在Unity中如何控制渲染优先级？</p></blockquote><ol><li>不同摄像机渲染时，摄像机深度（Camera depth）控制优先级</li><li>相同摄像机时，排序层级（Sorting Layer）控制优先级</li><li>相同排序层级时，层中的顺序（Order in Layer）控制优先级</li><li>相同摄像机，无排序层级属性时，Shader中的RenderQueue（渲染队列）控制优先级</li></ol><blockquote><p>Unity中场景中一个处于激活状态的物体(场景上只有这一个物体)，不能被摄像机渲染出来，可能有几种情况？（至少说出3种可能的情况）</p></blockquote><ol><li>在摄像机可视范围外（视口范围外）</li><li>在摄像机可视范围外（远近裁剪面之外范围）</li><li>物体的层级不能被摄像机渲染</li><li>该物体使用了透明材质，处于透明状态</li><li>该物体使用了单面渲染材质，摄像机看到的是该物体的背面</li><li>如果存在多摄像机，摄像机深度可能会影响<br>等等</li></ol><blockquote><p>解释一下Unity中的渲染管线（Rendering Pipeline）是什么，如何使用它，并举例说明它在游戏开发中的应用场景。</p></blockquote><p><strong>几何图形的准备</strong>：将场景中的几何图形转换为渲染引擎可以理解的形式，例如将3D模型转换为网格数据（Mesh）和材质信息。</p><p><strong>光照计算</strong>：计算场景中每个几何图形的光照效果，包括直接光照和间接光照。</p><p><strong>视点变换</strong>：根据摄像机的位置和方向将场景中的几何图形转换为摄像机的视图空间（View Space）坐标系下的形式。</p><p><strong>投影变换</strong>：将摄像机的视图空间坐标系下的几何图形转换为投影坐标系下的形式。</p><p><strong>图像空间计算</strong>：将投影坐标系下的几何图形转换为屏幕上的像素坐标。</p><p><strong>着色</strong>：根据材质信息和光照信息对几何图形进行着色，计算每个像素的颜色值。</p><p><strong>合成</strong>：将所有的像素颜色值按照一定的顺序合成为最终的图像，输出到屏幕上。</p><h3 id="Unity-贴图问题"><a href="#Unity-贴图问题" class="headerlink" title="Unity 贴图问题"></a>Unity 贴图问题</h3><blockquote><p>LOD是什么，优缺点是什么？</p></blockquote><p><strong>LOD(Level of detail)多层次细节</strong>，是最常用的游戏优化技术。它按照模型的位置和重要程度决定物体渲染的资源分配</p><ul><li><p><strong>优点</strong></p><p>降低非重要物体的面数和细节度，从而获得高效率的渲染运算</p></li><li><p><strong>缺点</strong></p><p>增加了内存</p></li></ul><blockquote><p>LOD（多细节层次）和 MipMap（纹理图）的作用是什么？</p></blockquote><ul><li><strong>优化游戏性能</strong><br>从不同距离渲染对象时，使用的是质量不同的模型(LOD)和贴图(Mipmap)。（一般情况是越远面数越低，图片越小）</li></ul><h3 id="Unity-UI问题"><a href="#Unity-UI问题" class="headerlink" title="Unity UI问题"></a>Unity UI问题</h3><h4 id="Canvas问题"><a href="#Canvas问题" class="headerlink" title="Canvas问题"></a>Canvas问题</h4><blockquote><p>UGUI中的Canvas以及三种画布渲染模式区别</p></blockquote><ol><li><strong>Screen Space-Overlay</strong>模式</li></ol><p><strong>Screen Space-Overlay（屏幕控件-覆盖模式）的画布会填满整个屏幕空间，并将画布下面的所有的UI元素置于屏幕的最上层，</strong>或者说画布的画面永远“覆盖”其他普通的3D画面，如果屏幕尺寸被改变，画布将自动改变尺寸来匹配屏幕　　　　　　　　　　　　　　　　　　　　　　　　　　　　　</p><p>Screen Space-Overlay模式的画布有<strong>Pixel Perfect</strong>和<strong>Sort Layer</strong>两个参数：</p><ol><li><p><strong>Pixel Perfect</strong>：只有RenderMode为Screen类型时才有的选项。使UI元素像素对应，效果就是边缘清晰不模糊。</p></li><li><p><strong>Sort Layer</strong>: Sort Layer是UGUI专用的设置，用来指示画布的深度。</p></li></ol><hr><ol start="2"><li><strong>Screen Space-Camera模式</strong></li></ol><p><strong>Screen Space-Camera（屏幕空间-摄影机模式）和Screen Space-Overlay模式类似，画布也是填满整个屏幕空间，如果屏幕尺寸改变，画布也会自动改变尺寸来匹配屏幕</strong>。所不同的是，在该模式下，画布会被放置到摄影机前方。在这种渲染模式下，画布看起来 绘制在一个与摄影机固定距离的平面上。所有的UI元素都由该摄影机渲染，因此摄影机的设置会影响到UI画面。在此模式下，UI元素是由perspective也就是视角设定的，视角广度由Filed of View设置。</p><p>　　<strong>这种模式可以用来实现在UI上显示3D模型的需求</strong>，比如很多MMO游戏中的查看人物装备的界面，可能屏幕的左侧有一个运动的3D人物，左侧是一些UI元素。通过设置Screen Space-Camera模式就可以实现上述的需求.</p><p>　　它比Screen Space-Overlay模式的画布多了下面几个参数：</p><ol><li><p><strong>Render Camera</strong>:渲染摄像机</p></li><li><p><strong>Plane Distance</strong>:画布距离摄像机的距离</p></li><li><p><strong>Sorting Layer</strong>: Sorting Layer是UGUI专用的设置，用来指示画布的深度。</p><p>可以通过点击该栏的选项，在下拉菜单中点击“Add Sorting Layer”按钮进入标签和层的设置界面，或者点击导航菜单-&gt;edit-&gt;Project Settings-&gt;Tags and Layers进入该页面。可以点击“+”添加Layer，或者点击“-”删除Layer。画布所使用的Sorting Layer越排在下面，显示的优先级也就越高。</p></li><li><p><strong>Order in Layer</strong>:在相同的Sort Layer下的画布显示先后顺序。数字越高，显示的优先级也就越高。</p></li></ol><hr><ol start="3"><li><strong>World Space</strong></li></ol><p>　　<strong>World Space即世界控件模式</strong>。在此模式下，画布被视为与场景中其他普通游戏对象性质相同的类似于一张面片（Plane）的游戏物体。画布的尺寸可以通过RectTransform设置，所有的UI元素可能位于普通3D物体的前面或者后面显示。当UI为场景的一部分时，可以使用这个模式。</p><p>　　它有一个单独的参数Event Camera，用来指定接受事件的摄像机，可以通过画布上的GraphicRaycaster组件发射射线产生事件。</p><p>　　这种模式可以用来实现跟随人物移动的血条或者名称</p><hr><p><strong>区别：</strong></p><table><thead><tr><th>渲染模式</th><th>画布对应屏幕</th><th>摄像机</th><th>像素对应</th><th>适合类型</th></tr></thead><tbody><tr><td>Screen Space-Overlay</td><td>是</td><td>不需要</td><td>可选</td><td>2D UI</td></tr><tr><td>Screen Space-Camera</td><td>是</td><td>需要</td><td>可选</td><td>2D UI</td></tr><tr><td>World Space</td><td>否</td><td>需要</td><td>不可选</td><td>3D UI</td></tr></tbody></table><h4 id="Image和Rawlmage的区别"><a href="#Image和Rawlmage的区别" class="headerlink" title="Image和Rawlmage的区别"></a>Image和Rawlmage的区别</h4><p>1.lmgae比Rawlmage更消耗性能。</p><p>2.lmage只能使用Sprite属性的图片，但是Rawlmage什么样的都可以使用。</p><p>3.Image适合放一些有操作的图片，裁剪平铺旋转什么的，针对Image Type属性。RawImage就放单独展示的图片就可以，性能会比Image好很多。</p><h4 id="unity中的UI层为什么要分为动态和静态"><a href="#unity中的UI层为什么要分为动态和静态" class="headerlink" title="unity中的UI层为什么要分为动态和静态"></a>unity中的UI层为什么要分为动态和静态</h4><p>动态分离出来也是为了减少绘制次数，动态的话 Canves会重新绘制，不分开就会重新绘制一遍静态和动态，增加DC。</p><h3 id="Unity-数学问题"><a href="#Unity-数学问题" class="headerlink" title="Unity 数学问题"></a>Unity 数学问题</h3><h4 id="数学问题"><a href="#数学问题" class="headerlink" title="数学问题"></a>数学问题</h4><p><font color = " red"><b>插值运算</b></font></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C#">Mathf.Lerp(start,end,t);<br><span class="hljs-comment">//线性插值</span><br>Vector3.Lerp(start,end,t);<br>两个向量之间的线性差值，适用于从某点移动到某点（或跟随某物体），缓动效果。<br><span class="hljs-comment">//球形插值</span><br>Vector3.Slerp(strart,end,t);<br>两个向量之间的球形（弧线）差值，适用于从某点移动到某点（或跟随某物体），缓动效果，当前位置与目标位置距离越远，效果越明显。非匀速。<br></code></pre></td></tr></table></figure><p><strong>Res:</strong><br>$$<br>start + (end - start) * t<br>$$<br>t ：插值系数 取值范围 0~1</p><p><strong>作用：</strong></p><ol><li><p>每帧改变start的值——变化<strong>速度先快后慢，位置无限接近</strong>，但是不会得到end位置</p><p><strong>例如：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">start = Mathf.Lerp(start,<span class="hljs-number">10</span>,Time.deltaTime)<br></code></pre></td></tr></table></figure></li><li><p>每帧改变t的值——变化速度<strong>匀速</strong>，位置每帧接近，当t&gt;&#x3D;1时得到结果</p><p><strong>例如:</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#">time += Time.deltaTime;<br>res = Mathf.Lerp(start,<span class="hljs-number">10.</span>time);<br></code></pre></td></tr></table></figure></li></ol><p><strong>三角函数</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//弧度转角度</span><br><span class="hljs-comment">//弧度 * 57.3f = 对应角度</span><br><span class="hljs-built_in">float</span> rad = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">float</span> anger = rad * Mathf.Rad2Deg;<br><br><span class="hljs-comment">//角度转弧度</span><br><span class="hljs-comment">//角度 * 0.01745 = 对应弧度</span><br>anger = <span class="hljs-number">1</span>;<br>rad = anger * Mathf.Deg2Rad;<br><br><span class="hljs-comment">//三角函数</span><br><span class="hljs-comment">//Mathf的三角函数相关函数，传入的参数需要弧度值</span><br>Mathf.Sin(<span class="hljs-number">30</span> * Mathf.Deg2Rad);<br>Mathf.Cos(<span class="hljs-number">60</span> * Mathf.Deg2Rad);<br><br><span class="hljs-comment">//反三角函数</span><br>rad = Mathf.Asin(<span class="hljs-number">0.5f</span>);<br>print(rad * Mathf.Rad2Deg);<br><br></code></pre></td></tr></table></figure><blockquote><p>Unity中使用的是左手还是右手坐标系？我们需要注意什么？</p></blockquote><p><strong>左手坐标系</strong><br>在进行向量相关计算时，要注意左手和右手坐标系的区别</p><hr><h4 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//世界转本地</span><br><span class="hljs-keyword">this</span>.transform.InverseTransformDirection;<br><span class="hljs-keyword">this</span>.transform.InverseTransformPoint;<br><span class="hljs-keyword">this</span>.transform.InverseTransformVector;<br><br><span class="hljs-comment">//本地转世界</span><br><span class="hljs-keyword">this</span>.transform.TransformDirection;<br><span class="hljs-keyword">this</span>.transform.TransformPoint;<br><span class="hljs-keyword">this</span>.transform.TransformVector;<br><br><span class="hljs-comment">//世界转屏幕</span><br>Camera.main.WorldToScreenPoint;<br><span class="hljs-comment">//屏幕转世界</span><br>Camera.main.ScreenToWorldPoint;<br><br><span class="hljs-comment">//世界转视口</span><br>Camera.main.WorldToViewportPoint;<br><span class="hljs-comment">//视口转世界</span><br>Camera.main.ViewportToWorldPoint;<br><br><span class="hljs-comment">//视口转屏幕</span><br>Camera.main.ViewportToScreenPoint;<br><span class="hljs-comment">//屏幕转视口</span><br>Camera.main.ScreenToViewportPoint;<br></code></pre></td></tr></table></figure><hr><h4 id="向量问题"><a href="#向量问题" class="headerlink" title="向量问题"></a>向量问题</h4><p>$$<br>AB &#x3D; B - A<br>$$</p><p><strong>向量模长</strong></p><p>向量的模长就是<strong>向量的长度</strong></p><p>向量是由两个点算出，所以向量的模长就是<strong>两个点的距离</strong></p><p><strong>公式：</strong><br>$$<br>√x²+y²+z²<br>$$</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C#">Vector3 A = Vector3.forward;<br>Vector3 B = Vector3.up;<br>Vector3 AB = B - A;<br><span class="hljs-comment">//获取模长，下面两种都可以获得两点的距离长度</span><br>AB.magnitude;<br>Vector3.Distance(A,B);<br></code></pre></td></tr></table></figure><p><strong>单位向量</strong></p><p><strong>模长为1的向量为单位向量</strong>，任意一个向量经过归一化就是单位向量</p><p><strong>只需要方向，不想让模长影响计算结果时使用单位向量</strong></p><p><strong>公式：</strong><br>$$<br>(x&#x2F;模长,y&#x2F;模长,z&#x2F;模长)<br>$$</p><blockquote><p>Unity中点乘和叉乘对于我们来说的作用是什么？</p></blockquote><p><font color = "red"><b>点乘作用</b></font></p><ol><li><strong>判断对象的方位</strong></li><li><strong>计算两向量之间的夹角</strong></li></ol><blockquote><p>用点乘实现散弹角度实现机制</p></blockquote><p> 以枪口方向为轴，上下或者左右为展开方向。获取夹角。利用点乘的方法。</p><ol><li>通过Vector3.Dot（向量A，向量B）获取两个向量的点乘C。</li><li>然后通过Acos C 然后由弧度转换为角度即可。</li><li>弧度乘以Mathf.Rad2Deg得到角度;</li></ol><p><font color = "red"><b>叉乘作用</b></font></p><ol><li><p><strong>获取一个平面的法向量</strong></p></li><li><p><strong>得到两向量之间的左右位置关系</strong></p></li></ol><p><strong>点乘</strong>：向量 A * 向量 B &#x3D; （A1A2,B1B2,C1C2）</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">Vector3.Dot（）;<br></code></pre></td></tr></table></figure><p>点乘结果 &gt; 0 两个向量夹角为锐角</p><p>点乘结果 &#x3D; 0 两个向量夹角为直角</p><p>点乘结果 &lt; 0 两个向量夹角为钝角</p><p>点乘 &gt;  0 为前方</p><p>点乘 &lt; 0 为后方</p><p><strong>叉乘：</strong>向量 A * 向量 B &#x3D; （B1C2 - C1B2 , A1C2 - C1A1 , A1B2 - B1A2）</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">Vector3.Cross（）;<br></code></pre></td></tr></table></figure><p>叉乘结果 y &gt; 0 右侧</p><p>叉乘结果 y &lt; 0 左侧</p><blockquote><p>Unity中如何计算出两个向量之间的夹角，请说出两种方式</p></blockquote><ol><li>利用Vector3中的API：<strong>Vector3.Angle</strong></li><li>先使用 <strong>Vector3.Dot 算出方向向量点乘结果</strong>，再<strong>通过Mathf.Acos反三角函数算出弧度</strong>，再将<strong>弧度转为角度</strong></li></ol><blockquote><p>矩阵相乘的意义及注意点</p></blockquote><p><strong>意义：</strong>用于表示<strong>线性变换：旋转、缩放、投影、平移、仿射</strong></p><p><strong>注意：</strong>矩阵的蠕变：误差的积累</p><hr><h4 id="四元数"><a href="#四元数" class="headerlink" title="四元数"></a>四元数</h4><p>简单来说，四元数本质上是一种高阶复数，是一个四维空间，相对于复数的二维空间。四元数由实数加上三个虚数单位组成，主要用于在三维空间中表试旋转。</p><p>一个四元数包含<strong>一个标量和一个3D向量</strong></p><p>[w,v],w为标量，v为3D向量，[w,(x,y,z)]<br>$$<br>四元数Q &#x3D;[cos(β&#x2F;2),sin(β&#x2F;2)x,sin(β&#x2F;2)y,sin(β&#x2F;2)z]<br>$$<br>对于给定的任意一个四元数：<strong>表试3D空间的一个旋转量</strong></p><blockquote><p>四元数的作用？</p></blockquote><p>四元数用于<strong>表示旋转</strong>。</p><p>其相对于欧拉角的优点：</p><ol><li>避免万向锁。</li><li>只需要一个4维的四元数就可以执行绕任意过原点的向量的旋转，方便快捷，在某些实现下比旋转矩阵效率更高。</li><li>可以提供平滑插值。</li></ol><blockquote><p>两个四元数相乘有什么作用？</p></blockquote><p>四元数相乘：角度叠加,代表旋转四元数</p><blockquote><p>四元数乘以向量有什么作用？</p></blockquote><p>四元数乘以向量：向量旋转</p><blockquote><p>Unity场景中有两个点连成了一条线，想要旋转这条线，应该怎么做？</p></blockquote><p>两点相减得到一条向量，向量乘以四元数即可</p><hr><h4 id="欧拉角"><a href="#欧拉角" class="headerlink" title="欧拉角"></a>欧拉角</h4><p>欧拉角用于表示刚体当前的姿态。</p><p>用一句话说，欧拉角就是<strong>物体绕坐标系三个坐标轴(x,y,z轴）的旋转角度</strong>。</p><ol><li><p>静态：即绕世界坐标系三个轴的旋转，由于物体旋转过程中坐标轴保持静止，所以称为静态。</p></li><li><p>动态：即绕物体坐标系三个轴的旋转，由于物体旋转过程中坐标轴随着物体做相同的转动，所以称为动态。<br>物体的任何一种旋转都可分解为分别绕三个轴的旋转，但分解方式不唯一。</p></li></ol><p>unity 3D欧拉角的<strong>旋转顺序（父子关系）是y-x-z</strong>。</p><p>unity中最简单的万向锁就是先让X轴旋转90度，z轴旋转和y轴旋转效果是一样。</p><p><strong>思想</strong>：将刚体绕某一轴的一次旋转，分解为依次分别绕X、Y、Z轴的三次旋转。这三个轴分别旋转的转动角度，就是一组三个欧拉角。</p><p>图片中即为上述的三次旋转（而其实可以绕某一轴，一次旋转即可达到最终位置）</p><p><img src="https://pic2.zhimg.com/v2-35da80e428ca5750491ffd2770e187e1_b.webp" alt="动图"></p><p>具体旋转过程举例，如图：</p><p><img src="https://pic1.zhimg.com/80/v2-6a4e77fe8ead57f7384a1491d1c73ab0_720w.webp" alt="img"></p><p>图中有两组坐标系，我们定义为：</p><ul><li>xyz ：世界坐标系（固定不动）</li><li>XYZ ：刚体坐标系（与刚体同步运动）</li></ul><p>具体旋转步骤为：</p><ul><li>1、绕<strong>世界系</strong>的 z 轴，旋转 α 角。</li><li>2、绕<strong>刚体系</strong>的 X 轴，旋转 β 角。</li><li>3、绕<strong>刚体系</strong>的 Z 轴，旋转 是 γ 角。</li></ul><p>下面有一个直观的动图展示。</p><p><img src="https://pic1.zhimg.com/v2-5480232b0c74e8d236044529bd170834_b.webp" alt="动图"></p><p>动图旋转步骤为 z→Y→X ，按照顺序标记为 zYX，加上角度即为一个完整欧拉角：</p><p>zYX — （ψ，θ，Φ）</p><hr><h4 id="万向节死锁"><a href="#万向节死锁" class="headerlink" title="万向节死锁"></a>万向节死锁</h4><p>万向锁（英语：Gimbal lock）<strong>是在使用动态欧拉角表示三维物体的旋转时出现的问题。</strong><br>万向节死锁的<strong>根本问题是欧拉角（EulerAngles）保存的信息不足以描述空间中的唯一转向。</strong></p><p>这种围绕选旋转前固定轴的<strong>先Z、再X、再Y的旋转操作</strong>，与其最终所预期的三个轴向可以旋转的结果并非一定是一对一的映射。某些情况下是多对一的映射，造成一些旋转自由度的缺失，也就是“死锁”。</p><p>在Unity 上 当某个特定轴达到某个特殊值时，<strong>绕一个轴旋转可能会覆盖住另一个轴的旋转，从而失去一维自由度。</strong></p><p><strong>Unity的X轴达到90度时，会产生万向节死锁</strong></p><p><strong>陀螺仪中的万向节死锁</strong></p><p>现在看起来，这个陀螺仪一切正常，在船体发生任意方向摇晃都可以通过自身调节来应对。然而，真的是这样吗？</p><p>假如，船体发生了剧烈的变化，此时船首仰起了90度，此时的陀螺仪调节状态如下图：</p><p><img src="https://img-blog.csdn.net/20170311165114162?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQW5kcmV3RmFu/font/5a6L5L2T/fontsize/200/fill/I0JBQkFCMA==/dissolve/70/gravity/NorthEast" alt="死锁开始"></p><p>此时，船体再次发生转动，沿着当前世界坐标的+Z轴（蓝色轴，应该正指向船底）进行转动</p><p><img src="https://img-blog.csdn.net/20170311165659086?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQW5kcmV3RmFu/font/5a6L5L2T/fontsize/200/fill/I0JBQkFCMA==/dissolve/70/gravity/NorthEast" alt="死锁的陀螺仪"></p><p>现在，转子不平衡了，陀螺仪的三板斧不起作用了。它失去了自身的调节能力。<br>之前陀螺仪之所以能通过自身调节，保持平衡，是因为存在可以相对旋转的连接头。在这种情况下，已经不存在可以相对旋转的连接头了。<br>那么连接头呢？去了哪里？显然，它还是在那里，只不过是，连接头可以旋转的相对方向不是现在需要的按着+Z轴方向。从上图中，我们清楚地看到：</p><ul><li><p>红色连接头：可以给予一个相对俯仰的自由度。</p></li><li><p>绿色连接头：可以给予一个相对偏航的自由度。</p></li><li><p>蓝色连接头：可以给予一个相对偏航的自由度。</p></li></ul><p>没错，三个连接头，提供的自由度只对应了俯仰和偏航两个自由度，桶滚自由度丢失了。这就是<strong>陀螺仪上的“万向节死锁”问题</strong>。</p><hr><h4 id="各种旋转优缺点"><a href="#各种旋转优缺点" class="headerlink" title="各种旋转优缺点"></a>各种旋转优缺点</h4><ul><li><p><strong>矩阵旋转</strong></p><ul><li><p><strong>优点：</strong></p><p>旋转轴可以是任意向量；</p></li><li><p><strong>缺点</strong>：</p><ul><li>旋转其实只需要知道一个向量+一个角度，一共4个值的信息，但矩阵法却使用了16个元素；</li><li>而且在做乘法操作时也会增加计算量，造成了空间和时间上的一些浪费；</li></ul></li></ul></li><li><p><strong>欧拉旋转</strong></p><ul><li><p><strong>优点：</strong></p><ul><li>很容易理解，形象直观；</li><li>存储空间小</li><li>可以进行从一个方向到另一个方向旋转大于180度的角度</li><li>表示更方便，只需要3个值（分别对应x、y、z轴的旋转角度）；但按我的理解，它还是转换到了3个3*3的矩阵做变换，效率不如四元数；</li></ul></li><li><p><strong>缺点：</strong></p><ul><li><strong>同一旋转的表试不唯一</strong>；</li><li><strong>会造成万向节锁（Gimbal Lock）的现象</strong>。这种现象的发生就是由于上述固定坐标轴旋转顺序造成的。理论上，欧拉旋转可以靠这种顺序让一个物体指到任何一个想要的方向，但如果在旋转中不幸让某些坐标轴重合了就会发生万向节锁，这时就会丢失一个方向上的旋转能力，也就是说在这种状态下我们无论怎么旋转（当然还是要原先的顺序）都不可能得到某些想要的旋转效果，除非我们打破原先的旋转顺序或者同时旋转3个坐标轴。这里有个视频可以直观的理解下；</li><li>由于万向节锁的存在，欧拉旋转无法实现球面平滑插值；</li></ul></li></ul></li><li><p><strong>四元数旋转</strong></p><ul><li><strong>优点：</strong><ul><li>可以避免万向节锁现象；</li><li>只需要一个4维的四元数就可以执行绕任意过原点的向量的旋转，方便快捷，在某些实现下比旋转矩阵效率更高；</li><li>可以提供平滑插值；</li></ul></li><li>缺点：<ul><li>比欧拉旋转稍微复杂了一点点，因为多了一个维度；</li><li>理解更困难，不直观；</li></ul></li></ul></li></ul><hr><h3 id="Unity-性能优化"><a href="#Unity-性能优化" class="headerlink" title="Unity 性能优化"></a>Unity 性能优化</h3><p><strong>内存：</strong></p><ol><li><p>尽量要占用少</p><ul><li><strong>使用对象池：</strong>对象池是一种常见的技术，用于缓存和重复使用游戏对象，而不是频繁地创建和销毁它们。使用对象池可以减少内存分配和垃圾回收的开销，从而提高游戏性能。</li><li><strong>减少资源占用：</strong>在开发过程中，应该尽量避免使用过多的高分辨率纹理和复杂的模型。可以使用纹理压缩、减少纹理尺寸、使用轻量级的模型等方式来减小资源占用。</li><li><strong>及时销毁不再使用的对象：</strong>当游戏中不再需要使用某些对象时，应该及时销毁它们，以释放它们占用的内存。尤其是一些长时间存在的对象，如粒子系统、音频和视频资源等，都应该及时销毁。</li><li><strong>使用异步加载：</strong>如果游戏中需要加载大量的资源，可以使用异步加载技术。异步加载可以减少游戏卡顿和内存占用，从而提高游戏性能。可以使用Unity提供的异步加载API或者自定义异步加载方式来实现异步加载。</li><li><strong>使用资源打包：</strong>在打包游戏时，可以使用资源打包技术来减少游戏的内存占用。资源打包可以将多个资源打包成一个单独的文件，从而减小游戏的内存占用。可以使用Unity提供的Asset Bundle功能或者自定义打包方式来实现资源打包。</li></ul></li><li><p>减少GC</p></li></ol><p><strong>CPU&#x2F;GPU性能</strong></p><ol><li><p><strong>减少Draw Call</strong>：在Unity中，每次渲染一个物体都会使用一个Draw Call。过多的Draw Call会导致渲染性能下降，因此应该尽量减少它们的数量。可以通过合并网格、使用物体批处理和减少物体数量等方式来减少Draw Call。</p></li><li><p><strong>使用级别LOD</strong>：如果场景中有大量的物体，可以使用级别LOD技术来优化性能。通过在远离玩家的位置使用低分辨率的网格，可以降低渲染开销，提高性能。</p></li><li><p><strong>合理使用资源</strong>：在开发过程中，应该尽量避免使用过多的高分辨率纹理和复杂的模型。可以使用纹理压缩、减少纹理尺寸、使用轻量级的模型等方式来减小资源占用。</p></li><li><p><strong>使用光照贴图</strong>：在游戏中，光照是非常重要的，但是使用动态光照会带来很大的渲染开销。因此，可以使用光照贴图来减少动态光照的数量。光照贴图可以在编辑器中生成，并且可以有效地提高游戏的性能。</p></li><li><p><strong>使用对象池</strong>：对象池是一种常见的技术，用于缓存和重复使用游戏对象，而不是频繁地创建和销毁它们。使用对象池可以减少内存分配和垃圾回收的开销，从而提高游戏性能。</p></li></ol><h3 id="Unity-对象移动"><a href="#Unity-对象移动" class="headerlink" title="Unity 对象移动"></a>Unity 对象移动</h3><p><strong>1.Transform</strong></p><p>​    通过 Update 函数每帧更新其位置来达到移动目的。</p><p>​     <strong>1.1 Transform.position</strong></p><p>​    向量相加</p><p>​    最基础的移动方式，每帧+&#x3D;计算好的新位置，更加直观。 </p><p>​     <strong>1.2 Transform.Translate</strong></p><p>​    在平移的方向和距离上移动变换。</p><p>​    <strong>每秒</strong>向某方向移动多少距离，此种方法和上一种没有太大区别，但当需要坐标转换时，使用此方法可省略转换步骤。</p><p><strong>2. Vector3</strong></p><p>​Vector3 类型可以存储物体的位置、方向。 V3 自带的类方法通过对位置的一些运算得到相对平滑的参数，其移动本质还是修改物体的 position。</p><ol start="2"><li>1 <strong>Vector3.Lerp</strong></li></ol><p>​两个向量之间的线性插值，适用于从某点移动到某点（或跟随某物体），缓动效果。</p><ol start="2"><li>2 <strong>Vector3.Slerp</strong></li></ol><p>​两个向量之间的球形（弧线）插值，适用于从某点移动到某点（或跟随某物体），缓动效果，当前位置与目标位置距离越远，效果越明显。<strong>非匀速。</strong></p><ol start="2"><li>3 <strong>Vector3.MoveTowards</strong></li></ol><p>​和 Lerp 函数基本相同，但此函数多了一个最大速度限制，且是<strong>匀速</strong>朝目标运动，而 Lerp 和 Slerp 则是将抵达位置时放缓（减速）</p><ol start="2"><li><p>4 <strong>Vector3.SmoothDamp</strong></p><p>​官方翻译为：“平滑阻尼”，无比丝滑的从 A 移动到 B 点，速度可控，比较适用于摄像机跟随，Lerp 也比较适用于摄像机跟随</p></li></ol><p><strong>3. Rigidbody</strong></p><p>​Rigidbody 组件通过物理模拟来控制一个物体的位置，当使用此组件控制物体移动时，应在 FixedUpdate 函数中更新数据，该方法会在每一次执行物理模拟前被调用，这样要比 Update 函数更加精确。</p><p>​<strong>3.1</strong> <strong>AddForce</strong></p><p>​    添加一个方向的力到刚体，刚体将开始移动，这种方式适合模拟外力作用下的刚体运动，如子弹。但注意，此力是累加的，不适合重复施加力来模拟物体！</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">AddForce(有方向的力(V3)</span>，力的模式(ForceMode,默认：ForceMode.Force))<br><br><span class="hljs-constructor">ForceMode(力的模式)</span>:<br><br><span class="hljs-number">1.</span><span class="hljs-constructor">Force(可持续的力，受质量影响)</span><br><br><span class="hljs-number">2.</span><span class="hljs-constructor">Acceleration(可持续的加速度，不受质量影响)</span><br><br><span class="hljs-number">3.</span><span class="hljs-constructor">Impulse(一个瞬间冲击力，受质量影响)</span><br><br><span class="hljs-number">4.</span><span class="hljs-constructor">VelocityChange(一个瞬间速度变化，不受质量影响)</span><br><br>  public <span class="hljs-built_in">float</span> forceNumber = <span class="hljs-number">20</span>f;<br> <br>     public Rigidbody rig; <span class="hljs-comment">//获取当前物体的刚体组件</span><br> <br>     void <span class="hljs-constructor">FixedUpdate()</span><br> <br>     &#123;<br> <br>         Vector3 force = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Vector3(0, 0, <span class="hljs-params">forceNumber</span>)</span>;<br> <br>         rig.<span class="hljs-constructor">AddForce(<span class="hljs-params">force</span>, ForceMode.Force)</span>;<br>     &#125; <br><br><br></code></pre></td></tr></table></figure><ol start="3"><li>2 <strong>MovePosition</strong></li></ol><p>​移动刚体到一个新的位置，移动的同时受到物理模拟的影响。</p><ol start="3"><li>3 <strong>Velocity</strong></li></ol><p>​瞬间给一个物体恒定的速度，将该物体提升到这个速度，保持。相比较 AddForce 更加适合跳跃功能。每次跳跃都是恒定高度。做跳跃的话： </p><ol start="4"><li><strong>Character Controller</strong></li></ol><p>​角色控制器顾名思义，是 Unity 推出的特别用于角色移动的组件，使用角色控制器的物体有刚体的效果，但不会翻滚（意思是运动仅受限于碰撞体，不受其他因素影响），很适合角色移动。还可以设置斜坡参数，一定坡度自动抬升，本身也是个碰撞体。</p><p>​4 .1 <strong>SimpleMove</strong></p><p>​    以一定速度移动角色，<strong>以秒为单位</strong>，无需乘以时间，<strong>具备重力。</strong></p><p>​4 .2 <strong>Move</strong></p><p>​    以一定速度移动角色,不具备重力，需要自行计算下落</p><h3 id="Unity-寻路"><a href="#Unity-寻路" class="headerlink" title="Unity 寻路"></a>Unity 寻路</h3><p>NavMesh是一种基于多边形网络的寻路导航系统，整个寻路分为导航网格的构建和寻路算法两个部分。</p><p>（1）烘焙导航网格</p><p>（2）需要导航的物体添加 NavMeshAgent 组件</p><p>（3）运行时候使用 NavMeshAgent.SetDestination 函数进行导航</p><h3 id="Unity-Mask实现原理"><a href="#Unity-Mask实现原理" class="headerlink" title="Unity Mask实现原理"></a>Unity Mask实现原理</h3><p><strong>Mask的实现原理：</strong></p><ol><li>Mask会赋予Image一个特殊的材质，这个材质会给Image的每个像素点进行标记，将标记结果存放在一个缓存内（这个缓存叫做 Stencil Buffer）</li><li>当子级UI进行渲染的时候会去检查这个 Stencil Buffer内的标记，如果当前覆盖的区域存在标记（即该区域在Image的覆盖范围内），进行渲染，否则不渲染。</li></ol><h3 id="Unity-帧同步"><a href="#Unity-帧同步" class="headerlink" title="Unity 帧同步"></a>Unity 帧同步</h3><blockquote><p> 什么是帧同步？</p></blockquote><p><strong>帧同步是一种前后端数据同步的方式，一般应用于对实时性要求很高的网络游戏。</strong></p><p><strong>基本实现流程及思路可以概括为</strong></p><ol><li>所有客户端每帧上传操作指令集到服务器;</li><li>服务端将这些操作指令集保存到对应帧序列字典，并记录帧号，并在下一帧将其广播给所有客户端;</li><li>客户端收到指令集后，分别按帧序，帧号进行执行指令集中的操作命令。</li><li>也就是：<strong>相同的时机(帧序列) + 相同的操作命令(指令集-确定性) &#x3D; 相同的结果(帧同步)</strong></li></ol><h3 id="Unity的GC"><a href="#Unity的GC" class="headerlink" title="Unity的GC"></a>Unity的GC</h3><ol><li><p><strong>贝姆垃圾收集器</strong></p><p>Untiy使用的GC机制是通过贝姆垃圾收集器（Boehm GC）来实现的，是应用在C&#x2F;C++语言上的一个保守的垃圾回收器，同时也适用于其它执行环境的各类编程语言，比如我们使用的基于mono实现的C#。</p></li><li><p><strong>回收机制</strong></p></li></ol><p>​Unity的GC的是采用 <strong>贝姆垃圾收集器</strong> ，本质上采用的是<strong>非分代非压缩的标记清除算法</strong>。</p><p>​它会在需要进行GC时占用主线程，进行<strong>遍历-标记-垃圾回收</strong>的过程，然后在归还主线程控制权。这会导致帧数的突然下降，产生卡顿（不过因为该实现是非压缩式的，所以卡顿现象相对较轻，但是对内存利用率进一步下降了，会有内存碎片的问题）。</p><p>​所以我们需要慎重地处理对象的创建（内存请求），还有释放（使用GC管理内存是没有主动释放内存的接口的，但是我们可以通过消除对某个对象的引用来做到这一点）。此外，Unity的代码分为两部分：<strong>托管与非托管</strong>，GC影响的只有托管部分的代码使用的堆内存。而且这个托管堆占用的地址空间不会返还给操作系统。</p><p>​标记清楚算法可以解决两个变量相互引用，产生标记的现象。</p><ol start="3"><li><p><strong>托管堆的垃圾回收机制</strong></p><p> Unity使用的垃圾机制是<strong>Boehm GC算法</strong>，他是<strong>非分代，非压缩</strong>的。<strong>非分代意味着每次回收都需要扫描整个堆</strong>，而<strong>非压缩则意味着内存分配后整个托管堆会存在间隙或者说内存碎片</strong>。这两个特点意味着Unity中托管堆的垃圾回收机制会耗时较长而且内存利用率存在着问题。</p></li><li><p><strong>整个垃圾回收的流程</strong></p><ol><li><p>停止所有进行托管堆内存分配的线程。        </p></li><li><p>找到所有不再被需要的内存，将其标记为垃圾。</p></li><li><p>将所有被标记的内存释放到空闲内存。</p></li><li><p>恢复之前停止的托管堆内存分配的线程。</p></li></ol></li><li><p><strong>GC优化</strong><br> GC对性能影响的原因（占用主线程进行大量工作），而优化GC即是减小占用GC占用主线程时花费的CPU时间，所以优化GC优化的是CPU时间，而非内存。</p></li></ol><h3 id="Unity和Android与iOS如何交互？"><a href="#Unity和Android与iOS如何交互？" class="headerlink" title="Unity和Android与iOS如何交互？"></a>Unity和Android与iOS如何交互？</h3><p>UnitySendMessage(“Cube111”,”methodName111”,”传给unity。。。”);</p><h3 id="Unity-Text-和-TMPtext的区别-优缺点"><a href="#Unity-Text-和-TMPtext的区别-优缺点" class="headerlink" title="Unity Text 和 TMPtext的区别 优缺点"></a>Unity Text 和 TMPtext的区别 优缺点</h3><p>​Text是像素渲染放大之后就会模糊，<strong>使用Text父物体的放大缩小会影响子物体Text的清晰度</strong>， <strong>TMPtext不会，它是网格渲染TMPtext会把字体生成一个类似于贴图的东西然后读取贴图的坐标来获取对应的文字</strong>，更换文字的<strong>消耗会比Text大</strong>，<strong>TMPtext适用于那种不会变动的文字</strong>，特别是在量大的情况下，性能比Text高一些，需要<strong>经常变动的问题用Text好点</strong>，TMPtext在字体库很大的情况下查找更换会比较慢。</p><h3 id="Unity-行为树和有限状态机"><a href="#Unity-行为树和有限状态机" class="headerlink" title="Unity 行为树和有限状态机"></a>Unity 行为树和有限状态机</h3><p><strong>有限状态机系统</strong>：是指在不同阶段会呈现出不同的运行状态的系统，这些状态是有限的、不重叠的。这样的系统在某一时刻一定会处于其所有状态中的一个状态，此时它接收一部分允许的输入，产生一部分可能的响应，并且迁移到一部分可能的状态。</p><ol><li>基本节点是状态：他包含了一系列运行在该状态的行为以及离开这个状态的条件。</li></ol><ol start="2"><li><p>状态可以任意跳转,实现简单,但是对于大的状态机很难维护，状态逻辑的重用性低。</p></li><li><p>每一个状态的逻辑会随着一些新状态的增加而越来越复杂。维持状态的数量和状态逻辑复杂性是一个很大的难点。需要合理的分割以及重用状态。</p></li><li><p>状态机状态的复用性很差，一旦一些因素变化导致这个环境发生变化。你只能新增一个状态，并且给这个新状态添加连接他以及其他状态的跳转逻辑。</p></li><li><p>状态机的跳转条件一旦不满足，就会一直卡在某一个状态。</p></li></ol><p><strong>行为树：</strong>一个流行的AI技术，涵盖了层次状态机，事件调度，事件计划，行为等一系列技术。实现AI的过程更加得有技巧，框架设计者较为全面考虑了我们可能会遇到的种种情况，把每种情况都抽象成了一个类型的节点，而我们要做的就是按照规范去写节点，然后把节点连接成一颗行为树。更加得具有面向对象的味道，行为模块间的藕合度相对较低。</p><ol><li>高度模块化状态，去掉状态中的跳转逻辑，使得状态变成一个“行为”。</li></ol><ol start="2"><li><p>“行为”和”行为”之间的跳转是通过父节点的类型来决定的。比如并行处理两个行为，在状态机里面无法同时处理两个状态。</p></li><li><p>通过增加控制节点的类型，可以达到复用行为的目的。</p></li><li><p>可视化编辑。</p></li></ol><p><strong>行为树的概念</strong>：</p><p>对于<strong>有限状态机</strong>而言，<strong>必须明确状态的转换方式</strong>；</p><p>对于<strong>行为树</strong>，必须明确状态前提：<strong>前提条件</strong>。</p><p>每一个行为必须有“前提条件” ，这决定了该行为是否被选择。<br>行为树的运算也是通过帧循环的update来驱动，不一定是每帧都update，但是要周期性update。<br>每一次run从根节点(root)开始，每一运行都会选择一个可行的子节点运行，这种选择可以是随机方式，也可以是预设好优先条件。<br>行为树由叶子节点和中间节点组成，叶子节点是最基本的行为(如跑动，攻击)，中间节点代表逻辑单元(巡逻，逃跑)。<br>当一个叶子节点被选择后，就会激活其对应的基本的行为。<br>最基本的行为可能执行成功也可能失败。<br>高等级的行为（中间节点）是否执行成功依赖于他们的孩子节点是否执行成功。<br>一个子节点失败可能导致父母节点选择另外一个孩子。<br>除了选择(selector)一个单独的子节点行为，一个节点还可能顺序(sequence)or并行(concurrent)得运行他的所有子节点。<br>一个行为除了有前提条件，可能还有上下文条件(父节点or孩子节点可能存储一定的状态变量)。<br>高优先级的行为可能抢占低优先级的行为。<br>优点：</p><ol><li><p>行为逻辑和状态数据分离，任何节点写好以后可以反复利用。</p></li><li><p>重用性高，可用通过重组不同的节点来实现不同的行为树。</p></li><li><p>呈线性的方式扩展，易于扩展。</p></li><li><p>可配置，把工作交给designer。</p></li><li><p>能够胜任”AI” “掉宝”等等场景。</p></li></ol><p>缺点：</p><ol><li><p>每一帧都从root开始，有可能会访问到所有的节点，相对State Machine消耗更多的cpu。</p></li><li><p>任何一个简单的操作都必须要使用节点。</p></li></ol><h3 id="Unity中判断两个2D矩形是否相交，有几种方式？（请至少说出两种方式）"><a href="#Unity中判断两个2D矩形是否相交，有几种方式？（请至少说出两种方式）" class="headerlink" title="Unity中判断两个2D矩形是否相交，有几种方式？（请至少说出两种方式）"></a>Unity中判断两个2D矩形是否相交，有几种方式？（请至少说出两种方式）</h3><ol><li>使用Unity物理系统进行碰撞检测</li><li>使用Unity中范围检测相关API</li><li>自己写算法进行检测</li></ol><h3 id="Unity制作物理游戏相关功能时，我们采用哪种方式处理位移？为什么？"><a href="#Unity制作物理游戏相关功能时，我们采用哪种方式处理位移？为什么？" class="headerlink" title="Unity制作物理游戏相关功能时，我们采用哪种方式处理位移？为什么？"></a>Unity制作物理游戏相关功能时，我们采用哪种方式处理位移？为什么？</h3><p>通过刚体相关API来处理位移，比如加力、改变刚体速度变量<br>原因：在碰撞检测时能更准确无误</p><h3 id="Unity中想要制作角色的连招功能，在制作状态机时我们一般如何处理？"><a href="#Unity中想要制作角色的连招功能，在制作状态机时我们一般如何处理？" class="headerlink" title="Unity中想要制作角色的连招功能，在制作状态机时我们一般如何处理？"></a>Unity中想要制作角色的连招功能，在制作状态机时我们一般如何处理？</h3><ol><li>状态机条件可以添加一个Trigger类型和Int类型<br>   Trigger条件主要用于触发动作，Int条件主要用于连招计数判断</li><li>逻辑上，当攻击按键输入时，我们需要触发动作，并且进行攻击计数<br>   每次按键时都应该重新进      行攻击计数延迟清零</li></ol><h3 id="Unity中想要制作自动寻路逻辑，我们应该怎么做？（请至少说出两种做法）"><a href="#Unity中想要制作自动寻路逻辑，我们应该怎么做？（请至少说出两种做法）" class="headerlink" title="Unity中想要制作自动寻路逻辑，我们应该怎么做？（请至少说出两种做法）"></a>Unity中想要制作自动寻路逻辑，我们应该怎么做？（请至少说出两种做法）</h3><ol><li>Unity自带的网格寻路系统</li><li>自定义寻路算法（比如 A星寻路算法）</li></ol><h3 id="Unity中如果想要在动作的某一时刻进行伤害检测，我们应该怎么做？（请说出两种做法）"><a href="#Unity中如果想要在动作的某一时刻进行伤害检测，我们应该怎么做？（请说出两种做法）" class="headerlink" title="Unity中如果想要在动作的某一时刻进行伤害检测，我们应该怎么做？（请说出两种做法）"></a>Unity中如果想要在动作的某一时刻进行伤害检测，我们应该怎么做？（请说出两种做法）</h3><p>1.　添加动画事件<br>2.　在切换动画一开始，进行延迟触发，延迟时间为想要触发伤害的时间（延迟可以用延迟函数，也可以用协同程序）</p><h3 id="游戏编辑器（比如-角色编辑器、关卡编辑器、地图编辑器等工具）的本质是什么？"><a href="#游戏编辑器（比如-角色编辑器、关卡编辑器、地图编辑器等工具）的本质是什么？" class="headerlink" title="游戏编辑器（比如 角色编辑器、关卡编辑器、地图编辑器等工具）的本质是什么？"></a>游戏编辑器（比如 角色编辑器、关卡编辑器、地图编辑器等工具）的本质是什么？</h3><p>数据的图形化编辑工具</p><h3 id="动态加载资源的方式？他们之间的区别"><a href="#动态加载资源的方式？他们之间的区别" class="headerlink" title="动态加载资源的方式？他们之间的区别"></a>动态加载资源的方式？他们之间的区别</h3><ol><li><strong>Resources</strong></li></ol><p>Resource类中的相关方法加载Resources文件夹下的资源</p><p>Resources是动态内部调用，Resources在编辑环境下是project窗口的一个文件夹，调用里面的资源，可以用Resources类，比如Resources.Load，打包后这个文件夹是不存在的，会统一生成assets资源</p><ol start="2"><li><strong>AssetBundle、Addressables</strong></li></ol><p>AssetBundle类中或Addressables类中的相关方法加载AB包中的资源</p><p>AssetBundle 是外部调用，要用AssetBundle 首先要先把资源打包为.assetbundle文件，再动态的去加载这个文件，本地或者网络服务器都可以。</p><ol start="3"><li><strong>WWW类中或UnityWebRequest类</strong></li></ol><p>WWW类中或UnityWebRequest类中的相关方法加载本地或远端资源</p><ol start="4"><li><strong>C#原生的一些文件加载相关 File FileStream</strong></li></ol><p><strong>总结：</strong></p><p><strong>简单说，Resources资源的加载是动态加载内部的，AssetBundle和Addressables是动态加载外部的、WWW和UnityWebReuest加载本地或远端资源、 File FileStream是加载一些文件相关</strong></p><h3 id="Application-streamingAssetsPath-和-Application-persistentDataPath两个路径有何区别？对于我们的意义是什么？"><a href="#Application-streamingAssetsPath-和-Application-persistentDataPath两个路径有何区别？对于我们的意义是什么？" class="headerlink" title="Application.streamingAssetsPath 和 Application.persistentDataPath两个路径有何区别？对于我们的意义是什么？"></a>Application.streamingAssetsPath 和 Application.persistentDataPath两个路径有何区别？对于我们的意义是什么？</h3><p>Application.streamingAssetsPath   只读<br>Application.persistentDataPath      可读可写</p><p>Application.streamingAssetsPath   适合放置一些默认2进制配置文件<br>Application.persistentDataPath      用于处理数据持久化，或作为热更新下载内容的存放目录，因为它可读可写</p><h3 id="Unity内存优化问题"><a href="#Unity内存优化问题" class="headerlink" title="Unity内存优化问题"></a>Unity内存优化问题</h3><blockquote><p>如何优化内存？</p></blockquote><ol><li><p>压缩自带类库；</p></li><li><p>将暂时不用的以后还需要使用的物体隐藏起来而不是直接Destroy掉；</p></li><li><p>释放AssetBundle占用的资源；</p></li><li><p>降低模型的片面数，降低模型的骨骼数量，降低贴图的大小；</p></li><li><p>使用光照贴图，使用多层次细节(LOD)，使用着色器(Shader)，使用预设(Prefab)。</p></li><li><p>代码中少产生临时变量</p></li></ol><blockquote><p>如何优化UI（基于UGUI）</p></blockquote><p><strong>性能上</strong></p><ol><li>打图集，将同一画面的图片放入一个图集中，目的是减少DrawCall</li><li>面板中的图片和文字尽量不要交叉，因为这样会产生多余的DrawCall</li><li>取消勾选在UI组件上的不必要的射线检测</li><li>减少透明图片的重叠使用<br>等等</li></ol><p><strong>内存上</strong></p><ol><li>大图尽量使用9宫格缩放，让美术设计UI面板底图时不要过于复杂<br>尽量是有规律的纹理和颜色变化</li><li>图片的RGBA通道分离<br>等等</li></ol><blockquote><p>UNITY3d在移动设备上的一些优化资源的方法</p></blockquote><ol><li><p>使用assetbundle，实现资源分离和共享，将内存控制到200m之内，同时也可以实现资源的在线更新</p></li><li><p>顶点数对渲染无论是cpu还是gpu都是压力最大的贡献者，降低顶点数到8万以下，fps稳定到了30帧左右</p></li><li><p>只使用一盏动态光，不是用阴影，不使用光照探头。粒子系统是cpu上的大头</p></li><li><p>剪裁粒子系统</p></li><li><p>合并同时出现的粒子系统</p></li><li><p>自己实现轻量级的粒子系统</p></li></ol><p>​   animator也是一个效率奇差的地方</p><ol start="7"><li><p>把不需要跟骨骼动画和动作过渡的地方全部使用animation，控制骨骼数量在30根以下</p></li><li><p>animator出视野不更新</p></li><li><p>删除无意义的animator</p></li><li><p>animator的初始化很耗时（粒子上能不能尽量不用animator）</p></li><li><p>除主角外都不要跟骨骼运动apply root motion</p></li><li><p>绝对禁止掉那些不带刚体带包围盒的物体（static collider ）运动</p></li><li><p>每帧递归的计算finalalpha改为只有初始化和变动时计算</p></li><li><p>去掉法线计算</p></li><li><p>不要每帧计算viewsize 和windowsize</p></li><li><p>filldrawcall时构建顶点缓存使用array.copy</p></li><li><p>代码剪裁：使用strip level ，使用.net2.0 subset</p></li><li><p>尽量减少smooth group</p></li><li><p>给美术定一个严格的经过科学验证的美术标准，并在U3D里面配以相应的检查工具</p></li></ol><h3 id="Unity中如何解决过多创建和删除对象带来的卡顿问题？"><a href="#Unity中如何解决过多创建和删除对象带来的卡顿问题？" class="headerlink" title="Unity中如何解决过多创建和删除对象带来的卡顿问题？"></a>Unity中如何解决过多创建和删除对象带来的卡顿问题？</h3><p>可以通过协同程序，分时分步创建或删除<br>原理是避免一帧中处理太多对象</p><h3 id="第一次执行GameObject-Instantiate时可能出现明显的卡顿，如何解决该问题？"><a href="#第一次执行GameObject-Instantiate时可能出现明显的卡顿，如何解决该问题？" class="headerlink" title="第一次执行GameObject.Instantiate时可能出现明显的卡顿，如何解决该问题？"></a>第一次执行GameObject.Instantiate时可能出现明显的卡顿，如何解决该问题？</h3><p>我们可以通过<strong>Unity自带的性能分析工具Profiler分析</strong>实例化时造成卡顿的原因<br><strong>程序上</strong>，一般我们可以从以下3个方面去优化它</p><ol><li><p><strong>相关资源加载：</strong>如果是由于资源加载带来的卡顿，我们可以在进入场景时进行资源预加载，总体思路就是<strong>将较大资源提前或者分帧加载</strong></p></li><li><p><strong>脚本初始化：</strong>实例化对象时，会同步执行它身上挂载所有脚本的初始化工作，我们可以策略性的<strong>改变一些初始化逻辑，尽量不要再Awake和Start中做较复杂的逻辑，或者将复杂逻辑提前或者分帧处理</strong></p></li><li><p>对于会频繁使用的对象，我们可以<strong>使用缓存池</strong></p></li></ol><p><strong>美术上</strong><br>不能只追求好的美术效果，而不考虑资源的消耗，要根据项目的实际情况，来设定模型的骨骼数、面数以及贴图的数量和大小上限。<br>在制作粒子特效时，粒子数、粒子面积、贴图等都要尽量少和小。<br>美术上要遵循：用最少的资源做出做好的效果，不能一味的用性能去换效果，最终会得不偿失</p><h3 id="Unity的IL2CPP-、Mono和跨平台等问题"><a href="#Unity的IL2CPP-、Mono和跨平台等问题" class="headerlink" title="Unity的IL2CPP 、Mono和跨平台等问题"></a>Unity的IL2CPP 、Mono和跨平台等问题</h3><blockquote><p>Unity底层如何处理C#代码？</p></blockquote><p>两种方案<br><font color = "red"><b>Mono和IL2CPP</b></font></p><blockquote><p>Mono</p></blockquote><p>C#代码——&gt;Mono C#编译器——&gt;IL中间代码——&gt; <font color = "red"><b>Mono VM——&gt;操作系统的原生代码</b></font></p><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230201222507758.png"></p><blockquote><p>Net与Mono的关系</p></blockquote><p>​Net是一个语言平台，Mono为.Net提供集成开发环境，集成并实现了.NET的编译器、CLR和基础类库，使得.Net暖既可以运行在windows也可以运行于linux，Unix，Mac OS等。</p><blockquote><p>Mono 和 Unity 的区别</p></blockquote><p>Unity 因为方便和跨平台选择了 C#作为主要的开发语言。而且 C#的跨平台是基于.Net Framework 框架下的（CIL，通用描述语言）和 CLR（通用运行环境的）。 在经过各种考量后，Unity 选择了开源，并且平台支持性很好的 Mono 这一开源 的.Net Framework 跨平台实现方案。</p><blockquote><p>IL2CPP</p></blockquote><p>C#代码——&gt;Mono C#编译器——&gt;IL中间代码——&gt;<font color = "red"><b>IL2CPP——&gt;C++——&gt;C++编译器——&gt;原生汇编代码——&gt;IL2CPP VM</b></font></p><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230201222538994.png"></p><blockquote><p>两者区别</p></blockquote><p><font color = "red"><b>IL2CPP效率高于Mono，跨平台也更好维护</b></font></p><p><font color = "red"><b>Mono是JIT即时编译，IL2CPP是AOT提前编译</b></font></p><p>建议使用效率更高的<strong>IL2CPP</strong></p><blockquote><p>Unity使用IL2CPP打包时，我们应该注意什么？如何避免（可以举例说明）</p></blockquote><p>使用IL2CPP打包时，<b>最可能出现的问题就是<font color = "red">代码裁剪</font></b>，IL2CPP会自动将它认为不会使用的代码裁剪掉，比如我们在使用Lua开发时，其实会用到很多UnityEngine或者我们自己写的C#代码，但是这些代码并不会在引擎中直接使用，都是在Lua中使用的，此时最容易出现的问题就是代码裁剪，导致打包后出现异常和报错。</p><p>要<strong>避免IL2CPP的裁剪有3种方式</strong>，我们可以组合使用</p><ol><li><strong>设置打包时的裁剪等级</strong></li><li><strong>通过xml文件配置明确规定哪些内容不裁剪</strong></li><li><strong>在静态方法中显示调用不想被裁剪的内容</strong></li></ol><blockquote><p>Unity实现跨平台的原理？</p></blockquote><p>Unity的跨平台技术是<strong>通过一个Mono虚拟机实现</strong>的。就是<strong>通过Mono将C#脚本代码编译成CIL，然后Mono运行时利用JIT或者AOT将CLI编译成目标平台的原生代码实现的</strong>。</p><p><strong>还有只会推出的IL2CPP</strong>，把本来应该再mono的虚拟机上跑的中间代码转换成cpp代码，这样再把生成的cpp代码，利用c的跨平台特性，在各个平台上通过对各平台都有良好优化的native c编译器编译，以获得更高的效率和更好的兼容性。</p><blockquote><p>讲讲Jit</p></blockquote><p><strong>即时编译（Just In-Time compile）</strong>，这是.NET运行可执行程序的基本方式，编译一个.NET程序时，编译器将源代码翻译成中间语言，<strong>它是一组可以有效地转换为本机代码且独立于CPU的指令</strong>。</p><p>当执行这些指令时，实时（JIT）编译器将它们转化为CPU特定的代码。部分加密软件通过挂钩JIT来进行IL加密，同时又保证程序正常运行。JIT也会将编译过的代码进行缓存，而不是每一次都进行编译。所以说它是静态编译和解释器的结合体。</p><h3 id="Unity引擎中哪些功能使用了C-的反射功能？至少说出一点"><a href="#Unity引擎中哪些功能使用了C-的反射功能？至少说出一点" class="headerlink" title="Unity引擎中哪些功能使用了C#的反射功能？至少说出一点"></a>Unity引擎中哪些功能使用了C#的反射功能？至少说出一点</h3><ol><li><p>Inspector窗口中显示的内容</p></li><li><p>预设体文件</p></li><li><p>场景文件</p></li><li><p>Unity中的各种特性</p><p>等等</p></li></ol><h3 id="Unity中如何调试排查Android上运行的项目问题"><a href="#Unity中如何调试排查Android上运行的项目问题" class="headerlink" title="Unity中如何调试排查Android上运行的项目问题"></a>Unity中如何调试排查Android上运行的项目问题</h3><ol><li><p><strong>如果需要进行断点调试</strong><br>通过数据线链接运行项目的Android设备<br>发布时开启了<br>Development Build 开发模式构建<br>Autoconnect Profiler 自动连接分析器<br>Script Debuggins 脚本调试<br>Wait For Managed Debugger 等待托管调试器<br>等选项<br>然后只需要Build and Run既可以<br>利用Unity的Profiler 性能剖析器窗口排查性能问题<br>并且还可以进行断点调试</p></li><li><p><strong>如果只是获取一些打印调试信息</strong><br>可以利用Unity2019.4及其以上版本提供的Android Logcat工具获取信息<br>Unity2019.4以下的版本，可以使用Android的ADB（安卓调试桥）工具</p></li><li><p><strong>如果需要获取设备输入信息</strong><br>可以利用Unity Remote来测试移动设备的输入相关逻辑</p></li></ol><h3 id="Unity场景上有多个对象，都分别挂载了n个脚本。我们如何控制不同脚本间生命周期函数Awake的执行先后顺序？"><a href="#Unity场景上有多个对象，都分别挂载了n个脚本。我们如何控制不同脚本间生命周期函数Awake的执行先后顺序？" class="headerlink" title="Unity场景上有多个对象，都分别挂载了n个脚本。我们如何控制不同脚本间生命周期函数Awake的执行先后顺序？"></a>Unity场景上有多个对象，都分别挂载了n个脚本。我们如何控制不同脚本间生命周期函数Awake的执行先后顺序？</h3><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/AwakeOrder.png"></p><ol><li>可以通过选中脚本文件，点击Inspector窗口右上角的Execution Order（执行顺序）按钮 </li><li>可以打开Project Setting窗口，选择Script Execution Order选项</li></ol><p>通过这两种方式我们可以打开脚本执行顺序窗口<br>在其中我们可以自己设置自定义脚本的执行顺序</p><h3 id="想要在Unity中使用指针我们需要进行哪些操作？"><a href="#想要在Unity中使用指针我们需要进行哪些操作？" class="headerlink" title="想要在Unity中使用指针我们需要进行哪些操作？"></a>想要在Unity中使用指针我们需要进行哪些操作？</h3><ol><li>需要在PlayerSetting中的OtherSettings中勾选  Allow ‘unsafe’ code 选项</li><li>使用指针时必须在unsafe修饰的代码块中</li></ol><h3 id="请简述一下对象池，在游戏开发中我们什么时候会用到它？"><a href="#请简述一下对象池，在游戏开发中我们什么时候会用到它？" class="headerlink" title="请简述一下对象池，在游戏开发中我们什么时候会用到它？"></a>请简述一下对象池，在游戏开发中我们什么时候会用到它？</h3><ol><li><p>对象池的主要作用是 <strong>避免大量创建对象再释放对象时造成的内存消耗，可以有效降低GC发生的频率</strong>。我们把不用的对象放入对象池中而不是让它直接变为垃圾，下次需要用到对象时再从对象池中获取，我们通过占用内存来避免更多的内存消耗和GC的发生</p></li><li><p>在游戏中频繁创建对象、实例化对象的地方，都可以用到对象池。<br>比如前端开发中，游戏中的子弹、伤害字体、特效等等<br>比如后端开发中线程池等等</p></li></ol><h3 id="buff-系统中，如何用一个-byte，记录多种buff状态标识"><a href="#buff-系统中，如何用一个-byte，记录多种buff状态标识" class="headerlink" title="buff 系统中，如何用一个 byte，记录多种buff状态标识"></a>buff 系统中，如何用一个 byte，记录多种buff状态标识</h3><p>答案：<br>一个byte，有8位，我们可以让每一位代表一种状态，0代表无，1代表有</p><p>byte buffType &#x3D; 0;</p><p>0000 0000<br>0000 0001  中毒 buff<br>0000 0010  灼烧 buff<br>0000 0100  回春 buff</p><p>当状态添加时，进行 或 ( | ) 运算<br>buffType | 灼烧 buff &#x3D; 0000 0010<br>buffType | 中毒 buff &#x3D; 0000 0011</p><p>当状态移除时，进行 异或 ( ^ ) 运算<br>buffType 0000 0011<br>buffType ^ 中毒 buff &#x3D; 0000 0011 ^ 0000 0001 &#x3D; 0000 0010</p><h3 id="Unity客户端与服务器交互方式"><a href="#Unity客户端与服务器交互方式" class="headerlink" title="Unity客户端与服务器交互方式"></a>Unity客户端与服务器交互方式</h3><p><strong>消息数据：</strong>Socket或HTTP<br><strong>文件数据：</strong>FTP或HTTP</p><p><strong>socket</strong>通常也称作”套接字”,实现服务器和客户端之间的物理连接，并进行数据传输，主要有UDP和TCP两个协议。<strong>Socket处于网络协议的传输层</strong>。</p><p>http协议传输的主要有http协议 和基于http协议的Soap协议（web service）,常见的方式是 http 的post 和get 请求，web 服务。</p><h3 id="Unity-ESC"><a href="#Unity-ESC" class="headerlink" title="Unity ESC"></a>Unity ESC</h3><p><strong>什么是Unity ECS</strong></p><p>什么是Unity ECS<br>Unity ECS是Unity引擎中的一种高性能游戏开发架构，它采用了基于数据的设计思路，与传统的面向对象编程不同。它的目标是提高游戏的性能和可伸缩性。</p><p>Unity ECS通过实体（Entity）、组件（Component）和系统（System）这三个概念来描述游戏对象。实体是游戏对象的标识符，组件是游戏对象的属性，系统是对实体和组件的操作。</p><p>Unity ECS与传统的面向对象编程不同，主要体现在以下方面：</p><p><strong>面向数据</strong>：ECS是一种基于数据的编程模型，它着重于描述游戏对象的属性和行为，而不是游戏对象本身。这使得ECS能够更加高效地处理大量的游戏对象。</p><p><strong>任务并行</strong>：ECS使用任务并行技术，使得游戏的逻辑可以在多个CPU核心上并行执行，从而提高了游戏的性能。</p><p><strong>内存布局</strong>：ECS使用紧凑的内存布局，使得游戏对象的数据可以更快地被访问，从而提高了游戏的性能。</p><h2 id="🌙C"><a href="#🌙C" class="headerlink" title="🌙C#"></a>🌙C#</h2><h3 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h3><p><em><strong>封装</strong></em> ：隐藏对象的属性，并实现细节（方法），对外提供接口，<br>public全局，protected子类，internal同集，隐藏private<br>同类，public属性器，private字段，对赋值进行限定。<br>sealed修饰符的子类是不能被继承的。</p><ul><li><p><strong>设计上：</strong>分而治之，封装变化、高内聚低耦合 </p></li><li><p><strong>数据上</strong>：把一些基本数据复合成一个自定义类型的数据 </p></li><li><p><strong>方法上：</strong>隐藏实现细节，向外提供接口</p></li></ul><p><em><strong>继承</strong></em>：重用现有代码</p><p><em><strong>多态</strong></em>：静态多态重载，动态多态重写。<br>父类行为由子类具体实现，包含virtual虚方法，abstract抽象方法，interface接口<br><code>可以涉及题目虚方法、抽象方法、接口的区别</code></p><p><em><strong>重载和重写区别</strong></em><br>静态重载：返回值无关，与参数个数，类型相关。编译阶段。便于扩展和维护<br>动态重写override（运行时，改写了方法表的新地址）。<br>抽象方法的父类必须是抽象类，子类是抽象类可以不重写，抽象类不可以被实例化。</p><h3 id="请简述private，public，protected，internal的区别"><a href="#请简述private，public，protected，internal的区别" class="headerlink" title="请简述private，public，protected，internal的区别"></a>请简述private，public，protected，internal的区别</h3><p><strong>public</strong>：对任何类和成员都公开，无限制访问</p><p><strong>private</strong>：仅对该类公开</p><p><strong>protected</strong>：对该类和其派生类公开</p><p><strong>internal</strong>：只能在包含该类的程序集中访问该类</p><h3 id="字符串三种为空的不同写法的区别"><a href="#字符串三种为空的不同写法的区别" class="headerlink" title="字符串三种为空的不同写法的区别"></a>字符串三种为空的不同写法的区别</h3><p><strong>请说明字符串中三者的区别</strong></p><ul><li>string str &#x3D; null</li><li>string str &#x3D; “”</li><li>string str &#x3D; string.Empty</li></ul><p><strong>str &#x3D; null</strong> 在堆中没有分配内存地址<br><strong>str &#x3D; “”</strong> 和 <strong>string.Empty</strong> 一样都是在堆内存中分配了空间，里面存储的是空字符串<br>而<strong>string.Empty</strong>是一个静态只读变量</p><h3 id="string和stringBuilder区别"><a href="#string和stringBuilder区别" class="headerlink" title="string和stringBuilder区别"></a>string和stringBuilder区别</h3><ul><li><p><strong>string</strong></p><p>String不变性，字符序列不可变，对原管理中实例对象赋值，会重新开一个新的实例对象赋值，新开的实例对象会等待被GC。<br>string拼接要重新开辟空间，因为string原值不会改变，导致GC频繁，性能消耗大</p></li><li><p><strong>StringBuilder</strong></p><p>StringBuilder是字符串可变对象，基本和StringBuilder相同。唯一的区别是StringBuffer是线程安全，相关方法前带synchronized关键字，一般用于多线程。StringBuilder是非线程安全，所以性能略好，一般用于单线程</p></li></ul><p><strong>三者性能比较</strong> StringBuilder&gt;String</p><blockquote><p>在开发时，对string和StringBuilder我们应该如何选择</p></blockquote><p><strong>string</strong>在每次拼接时都会产生垃圾<br><strong>StringBuilder</strong>在拼接时，是在原空间中进行修改，不会产生垃圾，会自动帮助我们扩容<br>所以<strong>当字符串需要频繁修改拼接时，我们使用StringBuilder</strong></p><h3 id="请说说你认为C-中-x3D-x3D-和-Equals-的区别是什么？"><a href="#请说说你认为C-中-x3D-x3D-和-Equals-的区别是什么？" class="headerlink" title="请说说你认为C#中 &#x3D;&#x3D; 和 Equals 的区别是什么？"></a>请说说你认为C#中 &#x3D;&#x3D; 和 Equals 的区别是什么？</h3><ol><li>&#x3D;&#x3D; 是运算符，Equals是万物之父Object中的虚方法，子类可重写</li><li>Equals 一般在子类中重写后用于比较两个对象中内容是否相同<br> &#x3D;&#x3D;在没有运算符重载的前提下时<br> 引用类型用于比较地址；值类型用于比较值是否相同</li><li>运算效率不同，一般Equals没有&#x3D;&#x3D;效率高，因为一般Equals比较的内容比&#x3D;&#x3D;多</li></ol><h3 id="C-重载运算符，重载-x3D-x3D-和-x3D-以及Object基类中的虚方法-virtual-bool-Equals-Object-obj-对于我们的意义是什么？"><a href="#C-重载运算符，重载-x3D-x3D-和-x3D-以及Object基类中的虚方法-virtual-bool-Equals-Object-obj-对于我们的意义是什么？" class="headerlink" title="C#重载运算符，重载 &#x3D;&#x3D; 和 !&#x3D; 以及Object基类中的虚方法 virtual bool Equals(Object obj)对于我们的意义是什么？"></a>C#重载运算符，重载 &#x3D;&#x3D; 和 !&#x3D; 以及Object基类中的虚方法 virtual bool Equals(Object obj)对于我们的意义是什么？</h3><p>为了判断两个对象的非引用地址相等<br>我们可以选择 使用 重载运算符 &#x3D;&#x3D; 和 !&#x3D; 或者<br>重写Equals方法，来自定义判断两个对象是否相等<br>如果想保留原有的引用地址相等判断，那么一般我们选择重写Equals方法</p><h3 id="浅拷贝和深拷贝的区别？可以举例说明"><a href="#浅拷贝和深拷贝的区别？可以举例说明" class="headerlink" title="浅拷贝和深拷贝的区别？可以举例说明"></a>浅拷贝和深拷贝的区别？可以举例说明</h3><p><strong>浅拷贝：</strong><br>只复制对象的引用地址<br>两个对象指向同一内存地址，修改其中一个另一个也会随之变化</p><p><strong>深拷贝：</strong><br>将对象和值赋值过来，两个对象修改其中任意值都不会影响对方</p><p>举例：<br>比如引用对象A和引用对象B<br>让A &#x3D; B，就是浅拷贝，此时A、B的引用地址相同，改A中内容，B也变</p><p>如果想要深拷贝，简单处理就是new（包括对象中的成员）</p><h3 id="装箱和拆箱是指什么？"><a href="#装箱和拆箱是指什么？" class="headerlink" title="装箱和拆箱是指什么？"></a>装箱和拆箱是指什么？</h3><p>装箱——把栈中内容迁移到堆中去（值转引用）<br>拆箱——把堆中内容迁移到栈中去（引用转值）</p><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230201221201268.png"></p><h3 id="值和引用类型在变量赋值时的区别是什么？"><a href="#值和引用类型在变量赋值时的区别是什么？" class="headerlink" title="值和引用类型在变量赋值时的区别是什么？"></a>值和引用类型在变量赋值时的区别是什么？</h3><p>在C#中<strong>值类型的变量直接存储数据</strong>，而<strong>引用类型的变量持有的是数据的引用，数据存储在数据堆中</strong>。</p><p><strong>值类型</strong>（value type）：<strong>byte，short，int，long，float，double，decimal，char，bool，enum 和 struct</strong> 统称为值类型。值类型变量声明后，不管是否已经赋值，编译器为其分配内存。<br><img src="https://img-blog.csdnimg.cn/b99d714ae81d4ed08afb9a933e5df2ea.png" alt="在这里插入图片描述"><br><strong>引用类型</strong>（reference type）：<strong>string ，class，interface，delegate</strong>统称为引用类型。当声明一个类时，只在栈中分配一小片内存用于容纳一个地址，而此时并没有为其分配堆上的内存空间。当使用 new 创建一个类的实例时，分配堆上的空间，并把堆上空间的地址保存到栈上分配的小片空间中。<br><img src="https://img-blog.csdnimg.cn/cdda4b5f61374524bf3082080d30c4fb.png" alt="在这里插入图片描述"><br>值类型的实例通常是在线程栈上分配的（静态分配），但是在某些情形下可以存储在堆中。引用类型的对象总是在进程堆中分配（动态分配)。</p><p><strong>内存区域上的区别</strong><br><strong>值类型</strong>：数据存储在<strong>栈</strong>上，超出作用域就自动清理<br><strong>引用类型：</strong>数据存储在托管<strong>堆</strong>上，<strong>引用地址在线程栈上，地址指向数据存放的堆上</strong><br>托管堆会由GC来自动释放 ，线程栈数据在作用域结束后会被清理。</p><p><strong>拷贝策略：值类型是拷贝数据，引用类型是拷贝引用地址</strong><br>如果值类型为传值参数，传值参数会在栈上新开辟一个副本，原先的值类型数据不会改变<br>如果引用类型是传值参数，传值参数会创建一个新的引用地址，两个引用地址会指向同一个对象实例的数据，实例数据会随着改变进行改变。（这种行为被称为副作用，一般实际项目不会这么操作，要么return返回参数，要么使用ref或者out修饰符）</p><blockquote><p>数据结构的栈和堆</p></blockquote><p>堆和栈都是一种数据项按序排列的数据结构。</p><ul><li><p><strong>栈</strong></p><p>栈就像装数据的桶，具有后进先出性质；</p></li><li><p><strong>堆</strong></p><p>堆像一棵倒过来的树，<strong>堆是一种经过排序的树形数据结构，每个结点都有一个值。</strong>堆的存取是随意，这就如同我们在图书馆的书架上取书，虽然书的摆放是有顺序的</p></li></ul><h3 id="C-结构体和类的区别"><a href="#C-结构体和类的区别" class="headerlink" title="C# 结构体和类的区别"></a>C# 结构体和类的区别</h3><p><strong>结构体：</strong></p><ul><li>值类型</li><li>存储在栈</li><li>不能够使用protected保护修饰符</li><li>成员变量申明不能指定初始值</li><li>不能申明无参构造函数</li><li>申明有参构造函数之后，无参会被顶掉</li><li>不能申明析构函数</li><li>不能被继承</li><li>结构体需要在构造函数中初始化所有成员变量</li><li>不能被静态static修饰</li><li>不能再自己内部申明和自己一样的结构体变量</li></ul><p><strong>类：</strong></p><ul><li>引用类型</li><li>存储在堆</li></ul><h3 id="C-foreach-和-for-问题"><a href="#C-foreach-和-for-问题" class="headerlink" title="C# foreach 和 for 问题"></a>C# foreach 和 for 问题</h3><blockquote><p>C#中如何让自定义容器类能够使用for循环遍历？（通过 类对象[索引] 的形式遍历）</p></blockquote><p>通过在类中实现索引器实现</p><blockquote><p>C#中如何让自定义容器类能够使用foreach循环遍历？</p></blockquote><p>通过为该类实现迭代器可以让其使用foreach遍历<br>传统方式：<br>继承IEnumerator、IEnumerable两个接口<br>实现其中的<br>1.GetEnumerator方法<br>2.Current属性<br>3.MoveNext方法<br>语法糖方式：<br>利用yield return语法糖，实现GetEnumerator方法即可完成迭代器的实现&#x3D;</p><blockquote><p>foreach迭代器遍历和for循环遍历的区别</p></blockquote><ul><li><p><strong>foreach</strong></p><p>如果集合需要foreach遍历，是否可行，存在一定问题<br>foreach中的迭代变量item是的只读，不能对其进行修改，比如list.Remove（item）操作<br>foreach只读的时候记录下来，在对记录做操作，或者直接用for循环遍历<br>foreach对int[]数组循环已经不产生GC，避免对ArrayList进行遍历</p></li><li><p><strong>for</strong></p><p>for语句中初始化变量i的作用域，循环体内部可见。<br>通过索引进行遍历，可以根据索引对所遍历集合进行修改<br>unity中for循环使用lambda表达式注意闭包问题</p></li></ul><p><strong>Foreach遍历原理</strong><br>任何集合类（Array）对象都有一个GetEnumerator()方法，该方法可以返回一个实现了 IEnumerator接口的对象。<br>这个返回的IEnumerator对象既不是集合类对象，也不是集合的元素类对象，它是一个独立的类对象。<br>通过这个实现了 IEnumerator接口对象A，可以遍历访问集合类对象中的每一个元素对象<br>对象A访问MoveNext方法，方法为真，就可以访问Current方法，读取到集合的元素。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C#">  List&lt;<span class="hljs-built_in">string</span>&gt; list = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">string</span>&gt;() &#123; <span class="hljs-string">&quot;25&quot;</span>, <span class="hljs-string">&quot;哈3&quot;</span>, <span class="hljs-string">&quot;26&quot;</span>, <span class="hljs-string">&quot;花朵&quot;</span> &#125;;<br>IEnumerator listEnumerator = list.GetEnumerator();<br>     <span class="hljs-keyword">while</span> (listEnumerator.MoveNext())<br>     &#123;<br>         Console.WriteLine(listEnumerator.Current);<br>     &#125;<br><br></code></pre></td></tr></table></figure><h3 id="内存中，堆和栈的区别是什么？"><a href="#内存中，堆和栈的区别是什么？" class="headerlink" title="内存中，堆和栈的区别是什么？"></a>内存中，堆和栈的区别是什么？</h3><p>堆和栈是操作系统堆进程占用的内存空间的两种管理方式</p><ul><li><p><strong>栈：</strong>由操作系统自动分配释放，存放函数的参数值，局部变量值，栈中数据的生命周期随着函数的执行完成而结束</p></li><li><p><strong>堆：</strong>一般由程序员分配释放，如果开发人员不释放，程序结束时由操作系统回收<br>（在C#中 托管堆内存 会由 C#帮助我们管理，存在GC垃圾回收机制）</p></li></ul><h3 id="C-容器类、各自特点、性能区别"><a href="#C-容器类、各自特点、性能区别" class="headerlink" title="C#容器类、各自特点、性能区别"></a>C#容器类、各自特点、性能区别</h3><h4 id="Stack栈"><a href="#Stack栈" class="headerlink" title="Stack栈"></a><strong>Stack栈</strong></h4><p><strong>先进后出</strong>，入栈和出栈，底层泛型数组实现，入栈动态扩容2倍</p><hr><h4 id="Queue队列"><a href="#Queue队列" class="headerlink" title="Queue队列"></a><strong>Queue队列</strong></h4><p><strong>先进先出</strong>，入队和出队，底层泛型数组实现，表头表尾指针，判空还是满通过size比较</p><p><strong>Queue和Stack主要是用来存储临时信息的</strong></p><hr><h4 id="Array数组"><a href="#Array数组" class="headerlink" title="Array数组"></a><strong>Array数组</strong></h4><p><strong>Array</strong> 类是 C# 中所有数组的基类，它是在 System 命名空间中定义。Array 类提供了各种⽤于数组的属性和⽅法。且需要声明长度，不安全</p><p>使⽤⽅法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">int</span>[] nums = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span> &#125;;<br>Array.Sort(nums);<br></code></pre></td></tr></table></figure><hr><h4 id="ArrayList数组列表"><a href="#ArrayList数组列表" class="headerlink" title="ArrayList数组列表"></a><strong>ArrayList数组列表</strong></h4><p><strong>ArrayList</strong>动态数组，是.Net Framework提供的⽤于数据存储和检索的专⽤类，它是命名空间System.Collections下的⼀部分。它的大小是按照其中存储的数据来动态扩充与收缩的。所以，我们在声明ArrayList对象时并不需要指定它的长度。ArrayList继承了IList接⼝，所以它可以很⽅便的进行数据的添加，插⼊和移除.</p><p>比如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C#">ArrayList al = <span class="hljs-keyword">new</span> ArrayList();<br><span class="hljs-comment">//新增数据</span><br>al.Add(<span class="hljs-string">&quot;abc&quot;</span>); al.Add(<span class="hljs-number">123</span>);<br><span class="hljs-comment">//修改数据</span><br>al[<span class="hljs-number">2</span>] = <span class="hljs-number">345</span>;<br><span class="hljs-comment">//移除数据</span><br>al.RemoveAt(<span class="hljs-number">0</span>);<br><span class="hljs-comment">//插⼊数据</span><br>al.Insert(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;hello world&quot;</span>);<br></code></pre></td></tr></table></figure><hr><h4 id="List列表"><a href="#List列表" class="headerlink" title="List列表"></a><strong>List列表</strong></h4><p><strong>List</strong>类是ArrayList类的泛型等效类。它的⼤部分⽤法都与ArrayList相似，因为List类也继承了IList接⼝。最关键的区别在于，在声明List集合时，我们同时需要为其声明List集合内数据的对象类型。</p><h5 id="List底层原理"><a href="#List底层原理" class="headerlink" title="List底层原理"></a>List底层原理</h5><p>底层实现是泛型数组，特性，动态扩容，泛型安全</p><p>List是一种动态数组，其<strong>底层是一个数组</strong>，当元素个数超出数组的长度时，系统会自动为数组扩容，<strong>新的长度通常是原长度的2倍</strong>。List提供了一系列的方法，可以方便地添加、删除、查找、排序等操作。</p><p>为了支持动态扩容，<strong>List在内部维护了</strong><font color = "red"><b>一个数组和一个元素个数</b></font>。当<strong><em>元素个数</em>超出数组长度</strong>时，List会<strong>创建一个新数组</strong>，并<strong>将原来的元素拷贝到新的数组</strong>中，然后使用新数组替换旧数组，从而实现动态扩容。为了避免频繁的扩容，<strong>List采用了一种预分配策略，即当扩容时，会一次性预分配一定的容量，以减少扩容次数。</strong></p><p>比如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C#">List&lt;<span class="hljs-built_in">int</span>&gt; list = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;();<br><span class="hljs-comment">//新增数据</span><br> list.Add(<span class="hljs-number">123</span>);<br><span class="hljs-comment">//修改数据</span><br>list[<span class="hljs-number">0</span>] = <span class="hljs-number">345</span>;<br><span class="hljs-comment">//移除数据</span><br>list.RemoveAt(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p> 上例中，如果我们往List泛型集合中插⼊string字符”hello world”，IDE就会报错，且不能通过编译。这样就避免了前⾯讲的类型安全问题与装箱拆箱的性能问题了。</p><p><strong>List泛型的好处：</strong><br>　　通过允许指定泛型类或⽅法操作的特定类型，泛型功能将类型安全的任务从您转移给了编译器。不需要编写代码来检测数据类型是否正确，因为会在编译时强制使⽤正确的数据类型。减少了类型强制转换的需要和运⾏时错误的可能性。泛型提供了类型安全但没有增加多个实现的开销。</p><blockquote><p>请说明C#中的List是如何扩容的</p></blockquote><p>List的本质是数组</p><blockquote><p>List初始化效率问题</p></blockquote><p><strong>以下代码，谁的效率更高？为什么？</strong></p><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ListProblem.png"></p><p><strong>代码2的效率更高</strong></p><p>因为List的本质是数组，在初始化时，如果不默认为其指明分配多少容量，它会不断扩容<br><strong>扩容会带来效率的降低和垃圾的产生</strong></p><ul><li><strong>效率的降低：</strong>从旧数组到新数组的搬家</li><li><strong>垃圾的产生：</strong>每次扩容时，就数组就变成了垃圾</li></ul><blockquote><p>C#Array、ArrayList和List的区别</p></blockquote><ol><li>三者都⽤来处理⼀组数据，继承了IEnumerable接⼝，可⽤于for循环处理。<strong>都可以通过索引下标进⾏获取和设置元素</strong>。</li><li>Array在内存中是连续的，长度固定，⽆法删除和增加新的元素。⽽ArrayList或List的容量可根据需要⾃动插⼊和删除元素。</li><li>Array可以具有多个维度，⽽ ArrayList或 List&lt; T&gt; 始终只具有⼀个维度。但是，您可以轻松创建数组列表或列表的列表。</li><li>特定类型（Object 除外）的数组 的性能优于 ArrayList的性能。 这是因为 ArrayList的元素属于 Object 类型；所以在存储或检索值类型时通常发⽣装箱和拆箱操作。不过，在不需要重新分配时（即最初的容量⼗分接近列表的最⼤容量），List&lt; T&gt; 的性能与同类型的数组⼗分相近。</li><li>在决定使⽤ List 还是使⽤ArrayList 类（两者具有类似的功能）时，记住List 类在⼤多数情况下执⾏得更好并且是类型安全的。如果对<br>List&lt; T&gt; 类的类型T 使⽤引⽤类型，则两个类的⾏为是完全相同的。但是，如果对类型T使⽤值类型，则需要考虑实现和装箱问题。</li></ol><hr><h4 id="LinkList链表"><a href="#LinkList链表" class="headerlink" title="LinkList链表"></a><strong>LinkList链表</strong></h4><ol><li><p>数组和List、ArrayList集合都有一个重大的缺陷，就是从数组的中间位置删除或插入一个元素需要付出很大的代价，其原因是数组中处于被删除元素之后的所有元素都要向数组的前端移动。</p></li><li><p>LinkedList（底层是由链表实现的）<strong>基于链表的数据结构</strong>，很好的解决了数组删除插入效率低的问题，且不用动态的扩充数组的长度。</p><p><strong>优点</strong>：插入、删除元素效率比较高；</p><p><strong>缺点</strong>：访问效率比较低。</p></li></ol><hr><blockquote><p>C#则List和LinkedList的区别</p></blockquote><ul><li><p>List是数组列表</p><p>List读取速度快，时间复杂度是O（1），增删比较麻烦，时间复杂度是O(n).</p></li><li><p>LinkedList是双向链表</p><p>LinkedList读取时间复杂度是O(n),增删时间复杂度是O（1）</p></li></ul><blockquote><p>数组和链表的区别是什么？</p></blockquote><ol><li><strong>存储结构不同</strong></li></ol><ul><li>数组是顺序存储结构，在内存中是连续存储的</li><li>链表是链式存储结构，在内存中是非连续存储的</li></ul><ol start="2"><li><strong>访问效率不同</strong></li></ol><ul><li>数组由于是顺序存储，通过下标访问，访问效率高</li><li>链表由于是非连续存储，我们想要获取其中某一元素，需要从头或尾遍历，效率低</li></ul><ol start="3"><li><strong>插入、删除效率不同</strong></li></ol><ul><li>数组由于是顺序存储，在插入和删除时，需要整体移动数组中的大部分元 素，效率低</li><li>链表由于是链式存储，在插入和删除时，效率高</li></ul><ol start="4"><li><strong>越界问题</strong></li></ol><ul><li>数组由于是顺序存储，声明时容量是固定的，如果不处理扩容逻辑，存在越界风险</li><li>链表由于是链式存储，无越界风险</li></ul><hr><h4 id="HashTable哈希表（散列表）"><a href="#HashTable哈希表（散列表）" class="headerlink" title="HashTable哈希表（散列表）"></a><strong>HashTable哈希表（散列表）</strong></h4><p><strong>概念：</strong>不定长的二进制数据通过哈希函数映射到一个较短的二进制数据集，即Key通过HashFunction函数获得HashCode<br>装填因子：α&#x3D;n&#x2F;m&#x3D;0.72 ,存储的数据N和空间大小M<br>然后通过哈希桶算法，HashCode分段，每一段都是一个桶结构，一般是HashCode直接取余。<br>桶结构会加剧冲突，解决冲突使用拉链法，将产生冲突的元素建立一个单链表，并将头指针地址存储至Hash表对应桶的位置。这样定位到Hash表桶的位置后可通过遍历单链表的形式来查找元素。</p><ol><li>Key—Value形式存取，无序，类型Object，需要类型转换。</li><li>Hashtable查询速度快，而添加速度相对慢</li><li><ul><li><strong>Hashtable</strong>中的数据实际存储在内部的一个数据桶里（bucket结构体数组），容量固定，根据数组索引获取值。</li><li><strong>Directionary&lt;TKey,TVaule&gt;字典</strong>，有序，泛型存储不需要进行类型装换（不需要装箱拆箱），碰撞阈值扩容</li><li><strong>HashSet</strong>：一组不包含重复的元素集合</li></ul></li></ol><hr><h4 id="字典Dictionary"><a href="#字典Dictionary" class="headerlink" title="字典Dictionary"></a><strong>字典Dictionary</strong></h4><p>泛型集合命名空间using System.Collections.Generic;<br><strong>任何键都必须是唯一</strong></p><p>是一种键值对的形式存放数据，即 key值 、value 值 一 一映射的。key的类型没有限制，可以是整数、字符串甚至是实例对象。</p><p>该类最大的<strong>优点</strong>就是它**查找元素的时间复杂度接近O(1)**，实际项目中常被用来做一些数据的本地缓存，提升整体效率。</p><p><font color = "red" > <b>重点！！！！👇👇👇👇👇</b></font></p><h5 id="Dictionary底层原理"><a href="#Dictionary底层原理" class="headerlink" title="Dictionary底层原理"></a><strong>Dictionary底层原理</strong></h5><p><a href="https://zhuanlan.zhihu.com/p/96633352">【C#】浅析C# Dictionary实现原理 - 知乎 (zhihu.com)</a></p><p>有两个关键的算法，<strong>Hash算法 和 解决Hash 碰撞冲突 的算法</strong>。key value的映射关系用的就是Hash函数来建立的。</p><ol><li><p>哈希算法：<strong>将不定长度的二进制数据集给映射到一个较短的二进制长度数据集</strong>一个Key通过HashFunc（哈希函数）得到HashCode</p></li><li><p>Hash桶算法：是解决哈希表而引入的一个概念 ，为每一个hashCode 建立一个桶，桶里面放着一个数组。</p><p>对HashCode进行分段显示，常用方法是对HashCode直接取余</p></li><li><p>解决碰撞冲突算法（拉链法）：分段会导致key对应的桶会相同，<strong>拉链法的思想就像对冲突的元素，建立一个单链表，头指针存储到对应的哈希桶位置</strong>。反之就是通过确定hash桶位置后，遍历单链表，获取对应的value</p></li></ol><p><strong>变量定义</strong></p><p><img src="https://img2022.cnblogs.com/blog/708460/202205/708460-20220514185149561-1170153985.png" alt="img"></p><p> 从定义可知，<strong>字典的实现底层数据结构</strong>依靠的是<strong>数组</strong>。</p><p>Key值 HashFunc Buckets桶 Entries入口（最小数据结构）</p><p><img src="https://img-blog.csdnimg.cn/20210117205128952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNDA3NTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>Dictionary字典中最小的数据结构体Entry，调用Add(Key,Value)方法添加的元素都会被封装在这样的一个结构体中。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">private</span> <span class="hljs-keyword">struct</span> Entry &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> hashCode;    <span class="hljs-comment">// 除符号位以外的31位hashCode值, 如果该Entry没有被使用，那么为-1</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> next;        <span class="hljs-comment">// 下一个元素的下标索引，如果没有下一个就为-1</span><br>    <span class="hljs-keyword">public</span> TKey key;        <span class="hljs-comment">// 存放元素的键</span><br>    <span class="hljs-keyword">public</span> TValue <span class="hljs-keyword">value</span>;    <span class="hljs-comment">// 存放元素的值</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>Collection版本控制，字典重要变量version，这个变量，在每一次新增、修改和删除操作时，都会使version++<br>之后每一次迭代过程都会检查版本号是否一致，如果不一致将抛出异常。<br>这样就避免了在迭代过程中修改了集合，造成很多诡异的问题。</p><p><font color = "red"><b>总结：</b></font></p><p>Dictionary由数组构成，Hash函数作为地址构建，拉链法解决Hash冲突。Dictionary也是线程不安全的，因此在多线程访问的时候，需要自行加lock处理。</p><ul><li>C# Dictionary使用一个<strong>Entry结构体</strong>来存储键值对，每个Entry包含一个哈希码、一个下一个元素的索引、一个键和一个值。</li><li>C# Dictionary使用一个<strong>int数组</strong>来表示哈希桶，每个桶存储了对应的Entry在Entry数组中的索引，如果桶为空，则为-1。</li><li>C# Dictionary使用一个<strong>Entry数组</strong>来存放所有的元素，每个元素通过next字段指向同一桶中的下一个元素，形成链表结构。</li><li>C# Dictionary使用<strong>除留余数法</strong>来计算哈希码和桶索引，即<code>bucketIndex = hashCode % buckets.Length</code>。</li><li>C# Dictionary使用<strong>拉链法</strong>来解决哈希冲突，即将冲突的元素放在同一桶中的链表上。</li><li>C# Dictionary在添加、删除或查找元素时，都需要先计算哈希码和桶索引，然后遍历对应桶中的链表。</li><li>C# Dictionary在添加元素时，如果发现空闲位置（被删除的Entry），则优先复用该位置；如果发现数组已满或者碰撞次数过多，则进行扩容操作。</li><li>C# Dictionary在扩容操作时，会重新分配哈希桶和Entry数组，并重新计算所有元素的哈希码和桶索引。</li></ul><p>大概：</p><p>Dictionary 是一种通过 key value 存储数据的结构，它通过哈希算法，将不定长的二进制数据集映射到一个较短的二进制长度数据集，其中的key通过哈希函数得到hashcode。再通过哈希桶算法，为每一个hashcode建立一个桶，桶里面放着数组。还对每一个hashcode进行分段显示，常用的是对hashcode取余。如果产生碰撞冲突，使用拉链法解决冲突，即对产生冲突的元素建立一个单链表，头指针存储到对应的哈希桶位置。Dictionary下还有一个结构体Entry，调用添加（ADD）方法都会封装在这一个结构体中。</p><blockquote><p>C#中Dictionary不支持相同键存储，如果想要一个键对多个值该如何处理</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//按需求选择值的存储类型，可以用List，数组等来存储值</span><br>Dictionary&lt;<span class="hljs-built_in">string</span> , List&lt;player&gt;&gt; dic;<br> Dictionary&lt;<span class="hljs-built_in">string</span> , player[]&gt; dic;   <br></code></pre></td></tr></table></figure><hr><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p><strong>性能排序：</strong><br>插入性能： LinkedList &gt; Dictionary &gt; HashTable &gt; List<br>遍历性能：List &gt; LinkedList &gt; Dictionary &gt; HashTable<br>删除性能： Dictionary &gt; LinkedList &gt; HashTable &gt; List</p><p><font color = "red"><b>小结：</b></font></p><p><font color = "red"><b>在修改较频繁，且查找和删除也较多时，首选LinkedList,<br>在主要以删除为主，插入为辅，且查找较少时，首选Dictionary，<br>在查找频繁，而又无需修改的情况下，则首选List。</b></font></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//哈希表结构体</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">struct</span> bucket &#123;<br>   <span class="hljs-keyword">public</span> Object key;<span class="hljs-comment">//键</span><br>    <span class="hljs-keyword">public</span> Object val;<span class="hljs-comment">//值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> hash_col;<span class="hljs-comment">//哈希码</span><br>&#125;<br><span class="hljs-comment">//字典结构体</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">struct</span> Entry &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> hashCode;    <span class="hljs-comment">// 除符号位以外的31位hashCode值, 如果该Entry没有被使用，那么为-1</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> next;        <span class="hljs-comment">// 下一个元素的下标索引，如果没有下一个就为-1</span><br>    <span class="hljs-keyword">public</span> TKey key;        <span class="hljs-comment">// 存放元素的键</span><br>    <span class="hljs-keyword">public</span> TValue <span class="hljs-keyword">value</span>;    <span class="hljs-comment">// 存放元素的值</span><br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span>[] buckets;      <span class="hljs-comment">// Hash桶</span><br><span class="hljs-keyword">private</span> Entry[] entries;    <span class="hljs-comment">// Entry数组，存放元素</span><br><span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> count;          <span class="hljs-comment">// 当前entries的index位置</span><br><span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> version;        <span class="hljs-comment">// 当前版本，防止迭代过程中集合被更改</span><br><span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> freeList;       <span class="hljs-comment">// 被删除Entry在entries中的下标index，这个位置是空闲的</span><br><span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> freeCount;      <span class="hljs-comment">// 有多少个被删除的Entry，有多少个空闲的位置</span><br><span class="hljs-keyword">private</span> IEqualityComparer&lt;TKey&gt; comparer;   <span class="hljs-comment">// 比较器</span><br><span class="hljs-keyword">private</span> KeyCollection keys;     <span class="hljs-comment">// 存放Key的集合</span><br><span class="hljs-keyword">private</span> ValueCollection values;     <span class="hljs-comment">// 存放Value的集合</span><br><br><br></code></pre></td></tr></table></figure><hr><h3 id="C-泛型问题"><a href="#C-泛型问题" class="headerlink" title="C# 泛型问题"></a>C# 泛型问题</h3><h4 id="泛型是什么-好处是什么"><a href="#泛型是什么-好处是什么" class="headerlink" title="泛型是什么,好处是什么"></a>泛型是什么,好处是什么</h4><p>多个代码对 【不同数据类型】 执行 【相同指令】的情况<br><strong>泛型：</strong>多个类型共享一组代码<br>泛型允许类型参数化，泛型类型是类型的模板<br><strong>5种泛型：</strong>&lt; **类、结构、接口、委托、方法** &gt;<br>类型占位符 <strong>T</strong> 来表示泛型</p><p>泛型类不是实际的类，而是类的模板<br>从泛型类型创建实例<br>声明泛型类型 &gt;&gt; 通过提供【真实类型】创建构造函数类型 &gt;&gt; 从构造类型创建实例<br>类&lt;T1,T2&gt; 泛型类型参数</p><p><strong>性能</strong>：泛型不会强行对值类型进行装箱和拆箱，或对引用类型进行向下强制类型转换，所以性能得到提高<br><strong>安全</strong>：通过知道使用泛型定义的变量的类型限制，编译器可以在一定程度上验证类型假设，所以泛型提高了程序的类型安全。</p><blockquote><p>泛型的好处是什么</p></blockquote><ol><li>可以为不同类型对象的相同行为进行通用处理，提升代码复用率</li><li>避免装箱拆箱，提升性能</li></ol><h4 id="泛型约束有几种"><a href="#泛型约束有几种" class="headerlink" title="泛型约束有几种"></a>泛型约束有几种</h4><ol><li>值类型约束 T:struct</li><li>引用类型约束 T:class</li><li>公共无参构造约束 T:new()</li><li>类约束 T:类名</li><li>接口约束 T:接口名</li><li>另一个泛型约束 T:U</li></ol><h3 id="C-中如何让一个类不能再被其他类所继承？"><a href="#C-中如何让一个类不能再被其他类所继承？" class="headerlink" title="C#中如何让一个类不能再被其他类所继承？"></a>C#中如何让一个类不能再被其他类所继承？</h3><p>使用密封关键字sealed修饰该类</p><h3 id="C-接口和抽象类问题"><a href="#C-接口和抽象类问题" class="headerlink" title="C#接口和抽象类问题"></a>C#接口和抽象类问题</h3><blockquote><p>什么是接口，描述一下接口的成员具体实现</p></blockquote><ol><li>接口interface，不能定义字段，可以定义【非静态的】属性、索引器、事件、方法</li><li>默认public，但不能写任何访问修饰符</li><li>接口是引用类型，可以通过as运算符强转，获取某对象的接口的引用</li><li>接口可以继承N个接口，继承类要实现所有接口的方法</li></ol><p>声明接口IA &gt; 继承接口的类B &gt; 类B实现接口所有方法<br>接口要小而精，定义一组方法，继承接口的派生类要实现接口的所有方法。<br>接口和抽象类是不能被实例化的对象（引用类型）。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DelegateTest</span>()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">ITest</span> <span class="hljs-comment">//只能包含非静态成员函数，隐式public，但不允许访问修饰符</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Method</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> a</span>)</span>; <span class="hljs-comment">//方法</span><br>        <span class="hljs-built_in">string</span> Property <span class="hljs-comment">//属性</span><br>        &#123;<br>            <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>;<br>        &#125;<br>        <span class="hljs-keyword">event</span> DelegateTest EventTest; <span class="hljs-comment">//事件，需要先定义一个委托</span><br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">this</span>[<span class="hljs-built_in">int</span> index] <span class="hljs-comment">//索引器</span><br>        &#123;<br>            <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>;<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p><strong>例子</strong>：</p><p>游戏门：抽象类，不能实例，很多行为，定义接口，破坏可以击碎<br>系统接口鼠标行为，停留进入离开<br>很多设计模式，是对接口的应用，面向接口编程，实现层面更加有层次。</p><blockquote><p>C#中接口的作用是什么？说说你的理解</p></blockquote><p>用于建立行为的继承关系，而不是对象<br>不同对象，有相同行为时，我们可以利用接口对不同对象的行为进行整合</p><blockquote><p>请描述interface和抽象类之间的不同</p></blockquote><table><thead><tr><th>接口</th><th>抽象类</th></tr></thead><tbody><tr><td>是一种行为，不能直接实例化</td><td>是一种不能实例化的对象</td></tr><tr><td>可以定义方法、属性、索引器、事件</td><td>可以定义字段、静态字段和方法、抽象方法、属性、构造函数</td></tr><tr><td>可以继承，继承多个接口</td><td>可以继承，只能继承一个类</td></tr><tr><td>直接实现所有成员</td><td>重写override抽象方法</td></tr><tr><td>接口和抽象都不能被实例化，派生类必须实现基类或接口的方法</td><td>接口和抽象都不能被实例化，派生类必须实现基类或接口的方法</td></tr><tr><td>可以多重实现，抽象类只能单一继承</td><td>可以派生自另一个抽象类</td></tr></tbody></table><blockquote><p>如何选择抽象类和接口</p></blockquote><ul><li><strong>表示对象的用抽象类</strong>，<strong>表示行为拓展的用接口</strong></li><li><strong>不同对象用有共同行为，我们往往可以使用接口来实现</strong></li></ul><h3 id="C-委托和事件问题"><a href="#C-委托和事件问题" class="headerlink" title="C#委托和事件问题"></a>C#委托和事件问题</h3><blockquote><p>委托和事件在使用上的区别是什么？</p></blockquote><ol><li>事件和委托的使用是一模一样的，事件就是特殊的委托</li><li>事件相对委托来说，事件在外部使用时只能 +&#x3D;、-&#x3D;，委托哪都能用</li><li>事件 不能再外部执行 委托哪都能执行</li><li>事件 不能作为函数的临时变量 委托可以</li></ol><table><thead><tr><th>序号</th><th>区别</th><th>委托</th><th>事件</th></tr></thead><tbody><tr><td>1</td><td>是否可以使用&#x3D;来赋值</td><td>是</td><td>否</td></tr><tr><td>2</td><td>是否可以在类外部进行调用</td><td>是</td><td>否</td></tr><tr><td>3</td><td>是否是一个类型</td><td>是</td><td>否，事件修饰的是一个对象</td></tr></tbody></table><p>事件是基于委托的</p><ol><li><p>类型兼容</p></li><li><p>存储方法的引用</p><p>委托是事件的“底层基础”</p><p>事件是委托的“上层建筑”</p></li></ol><blockquote><p>委托和事件的关系</p></blockquote><p>首先需要澄清的是： 事件不是委托类型的字段，也不是一种特殊委托类型的字段，也不是一种特殊方式声明的委托方式字段。<strong>事件只是委托类型字段的包装器、限制器，限制外界对委托字段的访问</strong>。委托类型的字段通过事件包装、限制之后，外界只能访问他的+&#x3D;、-&#x3D;操作符，换言之只能够【添加】或【移除】事件处理器，用来阻挡非法操作的“蒙版”，它绝对不是委托字段的本身。</p><blockquote><p>为什么要使用委托类型来声明事件、为什么事件是基于委托的</p></blockquote><p>站在事件的拥有者来说：是为了表明事件拥有者、能够对外部通知什么样的消息</p><p>站在事件订阅者、被通知者角度来说：是一种【约定】事件处理器能够收到什么样的消息也约束了我们使用什么样的方法、签名来处理响应这个事件，并且，我们会使用委托类型的实例去储存方法的引用、去储存未来这个事件处理器。当事件的响应者，向事件的拥有者，提供了一个与之匹配的事件的事件处理器之后需要找一个地方把事件处理器保存、记录、储存下来。能够记录、引用方法的这个任务，只有委托才能做到</p><blockquote><p>C#中委托和接口有什么区别？各用在什么场合？</p></blockquote><p><strong>委托delegate</strong>：unity事件与委托密切相关，回调机制，减少对象之间数据交互<br><strong>接口interface</strong>：多人协作，完全抽象，类单继承<br>委托是约束方法的集合<br>接口是约束类具备的功能集合，解决类单继承问题</p><h3 id="C-Action和Func问题"><a href="#C-Action和Func问题" class="headerlink" title="C#Action和Func问题"></a>C#Action和Func问题</h3><blockquote><p>C#中的Action和Func是什么？他们有什么区别？</p></blockquote><p>Action和Func是System命名空间下 C#为我们提供的两个写好的委托</p><ul><li><p><strong>Action</strong>本身是一个无参无返回值的委托<br>对应的Action&lt;&gt;泛型委托支持最多16个参数</p></li><li><p><strong>Func</strong>本身是一个无参有返回值的委托<br>对应的Func&lt;&gt;泛型委托支持最多16个参数，并且有返回值</p></li></ul><blockquote><p>Unity 中的UnityAction是什么？</p></blockquote><ol><li><p><strong>UnityAction</strong>是UnityEngine.Events命名空间下 <strong>Unity为我们提供的写好的委托</strong></p></li><li><p>UnityAction本身<strong>是一个无参无返回值的委托</strong><br>对应的UnityAction&lt;&gt;<strong>泛型委托支持最多4个参数</strong></p></li></ol><h3 id="C-Lambda问题"><a href="#C-Lambda问题" class="headerlink" title="C# Lambda问题"></a>C# Lambda问题</h3><blockquote><p>C# 函数 Func(string a, string b)用 Lambda 表达式怎么写?</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#">Lambda表达式（任意参数）=&gt; &#123; 表达式&#125; ； =&gt; 读作goesto<br>（a,b）=&gt; &#123; &#125; ;<br></code></pre></td></tr></table></figure><h3 id="C-回调函数指什么？一般在什么时候使用？（至少说出3种使用场景）"><a href="#C-回调函数指什么？一般在什么时候使用？（至少说出3种使用场景）" class="headerlink" title="C# 回调函数指什么？一般在什么时候使用？（至少说出3种使用场景）"></a>C# 回调函数指什么？一般在什么时候使用？（至少说出3种使用场景）</h3><p>回调函数指在程序设计中，将一个函数作为参数传递给另一个函数，并在另一个函数执行完毕后被调用的函数，在C#中，一般以委托形式出现</p><p>什么时候使用：<br>1.异步编程：异步逻辑执行完毕后，再执行回调函数<br>2.事件中心<br>3.UI界面中的空间逻辑回调，比如按钮点击<br>等等</p><h3 id="C-反射问题"><a href="#C-反射问题" class="headerlink" title="C# 反射问题"></a>C# 反射问题</h3><p>程序正在运行时，可以查看其他程序集或者自身的元数据</p><p><strong>一个运行的程序</strong><font color = "red"><b>查看本身或者其它程序的元数据的行为</b></font><strong>就叫做反射</strong></p><h4 id="反射的实现原理"><a href="#反射的实现原理" class="headerlink" title="反射的实现原理"></a>反射的实现原理</h4><p><strong>定义：</strong>运行时，动态获取类型信息,动态创建对象,动态访问成员的过程。<br><strong>另一种定义：</strong>审查元数据并收集元数据的信息。<br>元数据：编译后的最基本数据单元，就是一堆表，反射就是解析这些元数据。<br>反射是在运行期间获取到类、对象、方法、数据的一种手段<br>主要使用类库System.Reflection<br><strong>反射要点：</strong>如何获取类型，根据类型来动态创建对象，反射获取方法以及动态调用方法，动态创建委托</p><blockquote><p>反射的作用是什么？</p></blockquote><ol><li>程序运行时得到所有元数据，包括元数据的特性</li><li>程序运行时，实例化对象，操作对象</li><li>程序运行时创建新对象，用这些对象执行任务</li></ol><blockquote><p>如何利用反射获取类中所有公共成员</p></blockquote><p>用Type 和MemberInfo 来获取</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#">Type t = Type(Test);<br>MemberInfo[] infos  = t.GetMembers();<br></code></pre></td></tr></table></figure><blockquote><p>如何得到无参和有参构造函数并执行</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//无参</span><br>ConstructorInfo info = t.GetConstructor(<span class="hljs-keyword">new</span> Type[<span class="hljs-number">0</span>]);<br><span class="hljs-comment">//无参构造没有参数传null</span><br>Test obj = info.Invoke(<span class="hljs-literal">null</span>) <span class="hljs-keyword">as</span> Test;<br><br><span class="hljs-comment">//有参</span><br>ConstructorInfo info2 = t.GetConstructor(<span class="hljs-keyword">new</span> Type[]&#123;<span class="hljs-keyword">typeof</span>（<span class="hljs-built_in">int</span>&#125;);<br>obj = info2.Invoke(<span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>[]&#123;<span class="hljs-number">2</span>&#125;) <span class="hljs-keyword">as</span> Test;<br></code></pre></td></tr></table></figure><p>MemberInfo : 公共成员信息</p><p>ConstructorInfo : 构造函数信息</p><p>FieldInfo : 成员变量信息</p><p>MehodInfo ： 方法信息</p><blockquote><p>反射里如何快速实例化对象类</p></blockquote><p>先得到Type 然后<strong>Activator.CreatInstance</strong>快速实例化一个对象</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C#">Test test = <span class="hljs-keyword">typeof</span>(Test);<br><span class="hljs-comment">//无参构造</span><br>Test testObj = Activator.CreatInstance(testType) <span class="hljs-keyword">as</span> Test;<br></code></pre></td></tr></table></figure><blockquote><p>如何加载程序集，使用反射</p></blockquote><p>程序集类</p><ul><li>主要用来加载其他程序集，加载后才能用Type来使用不是自己程序集的内容。</li><li>如果使用的不是自己程序集中的内容 需要现加载程序集，比如dll文件</li></ul><p><font color = "red">三种方法加载程序集</font></p><ul><li><p><strong>同一文件下的其他程序集</strong></p><p><strong>Assembly.Load(“程序集名称”)</strong></p></li><li><p><strong>不同文件下的其他程序集</strong></p><p><strong>Assembly.LoadFrom(“包含程序集清单的文件的名称或路径”)</strong></p><p><strong>Assembly.LoadFile(“要加载的文件的完全限定路径”)</strong></p></li></ul><p>例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//1.先加载一个指定程序集</span><br>            Assembly asembly = Assembly.LoadFrom(<span class="hljs-string">@&quot;C:\Users\MECHREVO\Desktop\CSharp进阶教学\Lesson18_练习题\bin\Debug\netcoreapp3.1\Lesson18_练习题&quot;</span>);<br>            Type[] types = asembly.GetTypes();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; types.Length; i++)<br>            &#123;<br>                Console.WriteLine(types[i]);<br>            &#125;<br>            <span class="hljs-comment">//2.再加载程序集中的一个类对象 之后才能使用反射</span><br>            Type icon = asembly.GetType(<span class="hljs-string">&quot;Lesson18_练习题.Icon&quot;</span>);<br>            MemberInfo[] members = icon.GetMembers();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; members.Length; i++)<br>            &#123;<br>                Console.WriteLine(members[i]);<br>            &#125;<br>            <span class="hljs-comment">//通过反射 实例化一个 icon对象</span><br>            <span class="hljs-comment">//首先得到枚举Type 来得到可以传入的参数</span><br>            Type moveDir = asembly.GetType(<span class="hljs-string">&quot;Lesson18_练习题.E_MoveDir&quot;</span>);<br>            FieldInfo right = moveDir.GetField(<span class="hljs-string">&quot;Right&quot;</span>);<br>            <span class="hljs-comment">//直接实例化对象</span><br>            <span class="hljs-built_in">object</span> iconObj = Activator.CreateInstance(icon, <span class="hljs-number">10</span>, <span class="hljs-number">5</span>, right.GetValue(<span class="hljs-literal">null</span>));<br>            <span class="hljs-comment">//得到对象中的方法 通过反射</span><br>            MethodInfo move = icon.GetMethod(<span class="hljs-string">&quot;Move&quot;</span>);<br>            MethodInfo draw = icon.GetMethod(<span class="hljs-string">&quot;Draw&quot;</span>);<br>            MethodInfo clear = icon.GetMethod(<span class="hljs-string">&quot;Clear&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="C-中ref和out关键字有什么区别？知道Ref的深层原理是什么？"><a href="#C-中ref和out关键字有什么区别？知道Ref的深层原理是什么？" class="headerlink" title="C#中ref和out关键字有什么区别？知道Ref的深层原理是什么？"></a>C#中ref和out关键字有什么区别？知道Ref的深层原理是什么？</h3><ul><li><p><strong>ref</strong>修饰引用参数</p><p>参数必须赋值，带回返回值，又进又出</p></li><li><p><strong>out</strong>修饰输出参数</p><p>参数可以不赋值，带回返回值之前必须明确赋值，<br>引用参数和输出参数不会创建新的存储位置</p></li></ul><p>如果ref参数是值类型，原先的值类型数据，会随着方法里的数据改变而改变，<br>如果ref参数值引用类型，方法里重新赋值后，原对象堆中数据会改变，如果对引用类型再次创建新对象并赋值给ref参数，引用地址会重新指向新对象堆数据。方法结束后形参和新对象都会消失。实参还是指向原始对象，值不够数据改变了</p><h3 id="C-值和地址问题"><a href="#C-值和地址问题" class="headerlink" title="C# 值和地址问题"></a>C# 值和地址问题</h3><p><strong>请问A、B、C 三处打印结果分别为多少？为什么？</strong></p><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/addressProblem.png"></p><p>A是10，B和C为100</p><p>Test1处参数传递进去后，函数内部的形参value是在栈上重新开辟的空间，将传入参数的值拷贝到了该空间中，和传入参数没有关系</p><p>Test2处参数是指针类型，指针是用于存储内存地址的变量，我们传入的是值得地址&amp;test2Value，在函数内部改变的是地址中存储的值，所以外部的test2Value会随之改变</p><p>Test3处ref关键字，底层逻辑中是将value作为test3Value的一个别名，他们指向的空间一致，所以value改变后，外部的test3Value也会改变</p><h3 id="C-分布类如何写"><a href="#C-分布类如何写" class="headerlink" title="C# 分布类如何写"></a>C# 分布类如何写</h3><p>再类前加<strong>partial</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>&#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="C-协变和逆变"><a href="#C-协变和逆变" class="headerlink" title="C# 协变和逆变"></a>C# 协变和逆变</h3><p>协变：</p><ul><li>和谐的变化，自然的变化</li><li>因为 里氏替换原则 父类可以装子类 所以子类 变父类 例如string 变 object，感受是和谐的</li></ul><p>逆变：</p><ul><li>逆常规的变化，不正常的变化</li><li>因为 里氏替换原则 父类可以装子类，子类不能装父类 所以父类变子类，感受是不和谐的</li></ul><p><strong>协变和逆变是修饰泛型的</strong></p><p><strong>协变：out</strong></p><ul><li>out修饰的泛型 只能作为返回值</li></ul><p><strong>逆变：in</strong></p><ul><li>in修饰的泛型 只能作为参数</li></ul><p><strong>用于泛型中 戏时 泛型字母的，只有泛型接口和泛型委托能使用</strong></p><h3 id="C-using-关键字的两个作用"><a href="#C-using-关键字的两个作用" class="headerlink" title="C# using 关键字的两个作用"></a>C# using 关键字的两个作用</h3><ol><li>引用命名空间</li><li>安全使用引用对象</li></ol><h3 id="C-中new关键字的作用（至少说出3种）"><a href="#C-中new关键字的作用（至少说出3种）" class="headerlink" title="C#中new关键字的作用（至少说出3种）"></a>C#中new关键字的作用（至少说出3种）</h3><ol><li>创建新对象</li><li>子类函数声明时加上new关键字，可以隐藏掉父类方法</li><li>泛型约束中使用new关键词，表示需要无参构造</li></ol><h3 id="C-如何拓展方法"><a href="#C-如何拓展方法" class="headerlink" title="C# 如何拓展方法"></a>C# 如何拓展方法</h3><p>拓展方法：为现有非静态 变量类型 添加 新方法</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Tools</span><br>&#123;<br>    <span class="hljs-comment">//为int 拓展了一个成员方法</span><br>    <span class="hljs-comment">//成员方法 是需要 实例化对象后 才能使用的</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SpeakValue</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span></span>)</span><br>    &#123;<br>        <span class="hljs-comment">//拓展方法的逻辑   </span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//使用</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&#123;<br>    <span class="hljs-built_in">int</span> i = <span class="hljs-number">10</span>;<br>    i.SpeakValue();<br>    <span class="hljs-comment">// 输出拓展方法的逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure><p>作用：</p><ol><li>提升程序拓展性</li><li>不需要再对象中重写方法</li><li>不需要继承添加方法</li><li>为别人封装的类型写额外的方法</li></ol><p>特点：</p><ol><li>一定时是在静态类中</li><li>一定是个静态函数</li><li>第一个参数为拓展目标</li><li>第一个参数用this修饰</li></ol><p>注意：如果拓展名如果和已有参数相同，会直接调用已有方法</p><blockquote><p>如果我们想为Unity中的Transform类添加一个自定义的方法，应该如何处理？</p></blockquote><p>通过C#的拓展方法相关知识点进行添加</p><h3 id="什么是闭包？可以举例说明"><a href="#什么是闭包？可以举例说明" class="headerlink" title="什么是闭包？可以举例说明"></a>什么是闭包？可以举例说明</h3><p>闭包是指有权访问另一个函数作用域中的变量的函数<br>所以闭包一般都是指的一个函数<br>创建这种特殊闭包函数的方式往往是在一个函数中创建另一个函数</p><p><strong>闭包需要满足四个条件</strong></p><ol><li>有函数嵌套</li><li>内部函数引用外部作用域的变量参数</li><li>返回值是函数</li><li>创建一个对象函数，让其长期驻留</li></ol><p><strong>闭包的经典示例</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c#">    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>        &#123;<br>            Task.Run(() =&gt; Console.WriteLine(i));<br>        &#125;<br><br>        Console.ReadKey();<br>    &#125;<br><br>output:<br><span class="hljs-number">5</span><br><span class="hljs-number">5</span><br><span class="hljs-number">5</span><br><span class="hljs-number">5</span><br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>Task.Run中的委托其实就是我们的闭包，它把局部变量i捕获了，所以在执行这个闭包的时候可以使用到变量i，也就是闭包执行的时候i是多少，那么传入的参数就是多少。</p><p>但是按理说，i&#x3D;0时，也会执行闭包啊，为什么传入的不是0。<strong>猜测i&#x3D;0时，闭包并没有立马执行，包括i&#x3D;1,2,3,4等，只有在for循环结束了的时候（i&#x3D;5）时闭包才一起执行的，所以输出的都是5</strong>。我们可以把代码改为这样：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C#">        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>            &#123;<br>                Task task = Task.Run(() =&gt; Console.WriteLine(i));<br>                task.Wait();<br>            &#125;<br><br>            Console.ReadKey();<br>        &#125;<br>output:<br><span class="hljs-number">0</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br><br></code></pre></td></tr></table></figure><h3 id="C-线程、线程池、任务问题"><a href="#C-线程、线程池、任务问题" class="headerlink" title="C# 线程、线程池、任务问题"></a>C# 线程、线程池、任务问题</h3><blockquote><p>请说明Thread、ThreadPool、Task分别是什么？并简单说明彼此的区别</p></blockquote><ul><li>Thread是线程，可以使用他开启线程处理复杂逻辑，避免主线程卡顿</li><li>ThreadPool是线程池，他是C#为线程实现的缓存池，主要用于减少线程的创建，减少GC触发</li><li>Task是任务，他是基于线程池的优化，让我们可以更方便的控制线程</li></ul><blockquote><p>什么是线程池</p></blockquote><p>ThreadPool中有若干数量的线程，如果有任务需要处理时，会从线程池中获取一个空闲的线程来执行任务，当线程池中所有的线程都在忙碌时，又会有新任务要处理，线程池才会新建一个线程来处理该任务，如果线程数量到达设置的最大值，任务会排队，等待其他任务释放线程再执行。</p><p>优点：<strong>线程池能减少线程创建，节省开销，可以减少GC垃圾回收的触发</strong></p><p>缺点：<strong>不能控制线程池的执行顺序，也不能获取线程池内线程取消&#x2F;异常&#x2F;完成的通知</strong></p><blockquote><p>创建Task无返回值的三种方式</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C#">Task t1 = <span class="hljs-keyword">new</span> Task(()=&gt;&#123;&#125;);<br>t1.Start();<br><br>Task t2 = Task.Run(()=&gt;&#123;&#125;);<br><br>Task t3 = Task.Factory.StartNew(()=&gt;&#123;&#125;);<br></code></pre></td></tr></table></figure><p>如果需要返回值，直接加泛型，泛型里的就是返回类型</p><h3 id="C-同步和异步"><a href="#C-同步和异步" class="headerlink" title="C# 同步和异步"></a>C# 同步和异步</h3><p>同步和异步主要用于修饰方法</p><p><strong>同步方法：</strong></p><p>当一个方法被调用时，调用者需要等待该方法执行完毕后返回才能继续执行</p><p><strong>异步方法：</strong></p><p>当一个方法被调用时立即返回，并获取一个线程执行该方法内部的逻辑，调用者不用等待该方法执行完毕</p><p>使用<strong>async</strong>修饰异步方法</p><ol><li><strong>再异步方法中使用await关键字，否则异步方法会以同步执行</strong></li><li><strong>再异步方法名称建议以Async结尾</strong></li><li><strong>异步方法的返回值只能时void、Task、Task&lt;&gt;</strong></li><li><strong>异步方法中不能声明使用ref或out关键字修饰变量</strong></li></ol><blockquote><p>什么时候需要异步编程</p></blockquote><p>需要处理的逻辑会严重影响主线程执行的流畅性时，我们需要使用异步编程</p><p>例如：</p><ol><li>复杂逻辑计算</li><li>网络下载、网络通讯</li><li>资源加载</li></ol><h3 id="C-中元组对于我们的作用是什么？"><a href="#C-中元组对于我们的作用是什么？" class="headerlink" title="C#中元组对于我们的作用是什么？"></a>C#中元组对于我们的作用是什么？</h3><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%85%83%E7%BB%84.png"></p><ol><li>可以在不用写数据结构类的情况下</li><li>利用元组处理多返回值，或者临时数据的集合</li></ol><h3 id="内存泄漏问题"><a href="#内存泄漏问题" class="headerlink" title="内存泄漏问题"></a>内存泄漏问题</h3><blockquote><p>内存泄漏指什么？</p></blockquote><p>内存泄漏指的就是对象超过生命周期后而不能被GC回收，一般指<strong>不会再使用的引用对象由于某些操作而不能被GC垃圾回收，而一直占用着内存</strong></p><p>更风趣通俗一点的说就是：<strong>没用的家伙没有被当成垃圾回收</strong></p><blockquote><p>常见的内存泄漏有哪些？</p></blockquote><p>常见的内存泄漏有：</p><ol><li>静态引用</li><li>不使用的引用对象没有置null，一直被引用</li><li>文件操作时，没有使用using或者没有进行Dispose()</li><li>委托或事件注册后没有解除注册（有加就有减）<br>等等</li></ol><h3 id="序列化问题"><a href="#序列化问题" class="headerlink" title="序列化问题"></a>序列化问题</h3><blockquote><p>序列化是什么？</p></blockquote><p>序列化是将<strong>程序中数据对象转换为可以存储或传输的形式 的过程</strong>。</p><blockquote><p>常见的序列化方式有哪些？什么时候我们会用到序列化？</p></blockquote><p>我们常见的序列化方式 <strong>xml、Json、2进制等</strong>。就是将内存中的数据按照我们自己定义的规则进行序列化，序列化之后就可以用于存储和传输，当读取和接受数据时，只需要按照对应规则进行反序列化便可得到原始数据</p><p>所谓的存储读取和传输接受，其实一般指的就是<strong>数据持久化和网络通讯</strong><br>所以我们经常会在这两块知识点看到序列化反序列化这两个关键词</p><blockquote><p>文件中保存了文本信息，但是打开后却是乱码，一般是什么原因造成的？</p></blockquote><p>序列化和反序列化字符串时使用的编码格式不统一</p><h3 id="C-中try-catch-finally的执行顺序"><a href="#C-中try-catch-finally的执行顺序" class="headerlink" title="C#中try catch finally的执行顺序"></a>C#中try catch finally的执行顺序</h3><p>1.首先明确一点，就是不管怎样，finally一定会执行，即使程序有异常，并且在catch中thorw 了 ，finally还是会被执行。</p><p>2.当try和catch中有return时，finally仍然执行。</p><p>3.finally是在return后面的表达式运算完之后执行的，在执行完return时 ，程序并没有跳出，而是进入到finally中继续执行，</p><p> 如果在finally如果对返回值进行了重新赋值，分为两种情况：</p><p>（1）当返回值是值类型（包括string类型，虽然是引用类型，这是特殊的个例）时，返回的值不受影响，</p><p>​    就是在trycatch时，返回的值已经确定了。</p><p>（2）当返回值是引用类型时，会影响到返回值，</p><p>eg:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span>[] <span class="hljs-title">TestYinYong</span>()</span><br>     &#123;<br>         <span class="hljs-built_in">string</span>[] arr = &#123; <span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span> &#125;;<br>         <span class="hljs-keyword">try</span><br>         &#123;<br>             <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception();<br>         &#125;<br>         <span class="hljs-keyword">catch</span> (Exception)<br>         &#123;<br>             <span class="hljs-keyword">return</span> arr;<br>         &#125;<br>         <span class="hljs-keyword">finally</span><br>         &#123;<br>             arr[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;three&quot;</span>;<br>         &#125;<br>     &#125;<br></code></pre></td></tr></table></figure><p>此时返回的值是：{ “one”, “three” };</p><p>4.finally中不能有return语句，编译都无法通过，提示：控制不能离开finally子句主体</p><h3 id="C-内存抖动指什么？如何避免内存抖动"><a href="#C-内存抖动指什么？如何避免内存抖动" class="headerlink" title="Ｃ# 内存抖动指什么？如何避免内存抖动"></a>Ｃ# 内存抖动指什么？如何避免内存抖动</h3><p>答案：<br>内存抖动指<strong>短时间内有大量的对象被创建或者被回收的现象</strong><br>频繁的内存抖动会造成 GC 频繁运行，造成卡顿</p><p><strong>避免方式：</strong><br>对象池<br>享元模式<br>等</p><h3 id="C-索引器问题"><a href="#C-索引器问题" class="headerlink" title="C# 索引器问题"></a>C# 索引器问题</h3><p><strong>索引器概念：</strong></p><p>让对象可以让数组已有通过索引访问其中元素，使程序看起来更直观，更容易编写</p><blockquote><p>如何编写索引器</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">private</span> Person[] friend;<br><span class="hljs-keyword">public</span> Person <span class="hljs-keyword">this</span>[<span class="hljs-built_in">int</span> index]<br>&#123;<br>    <span class="hljs-keyword">get</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> friends[index];<br>    &#125;<br>    <span class="hljs-keyword">set</span><br>    &#123;<br>        friends[index] = <span class="hljs-keyword">value</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="C-GC问题"><a href="#C-GC问题" class="headerlink" title="C# GC问题"></a>C# GC问题</h3><blockquote><p>GC是什么</p></blockquote><ul><li>垃圾回收的过程是遍历堆上动态分配的所有对象</li><li>通过识别他们是否被引用拉确定那些对象是垃圾，哪些对象仍要被使用</li><li>所谓的垃圾就是没有被任何遍历，对象引用的内容</li><li>垃圾就需要被回收释放</li></ul><p><strong>注意：</strong></p><ul><li><strong>GC只负责堆（Heap）内存的垃圾回收</strong></li><li>引用内心都是存在堆中的，所以它的分配和释放都通过垃圾回收机制来管理</li><li><strong>栈上内存是由系统自动管理的</strong>，值类型在栈中分配内存的，他们由自己的生命周期，不用堆他们进行管理，会自动分配和释放</li></ul><blockquote><p><strong>C# GC内存回收机制大致原理</strong></p></blockquote><p>0代内存1代内存2代内存</p><p><strong>代的概念</strong></p><ul><li>代是GC使用的一种算法（分代算法）</li><li>新分配的对象都会被配置在第0代内存中</li><li>每次分配都可能会进行GC释放内存（0代内存满时）</li></ul><p>在一次内存回收过程开始时，垃圾回收器认为堆中全是垃圾，会进行以下两个步骤</p><ol><li><strong>标记对象，从根（静态字段、方法参数）开始检查引用对象，标记后为可达对象，未标记为不可达对象，不可达对象就认为是垃圾</strong></li><li><strong>搬迁对象压缩堆（挂起执行托管代码线程）释放未标记的对象 搬迁可达对象，修改引用地址</strong></li></ol><p>大对象总被认为是第二代内存，目的是减少性能损耗，提高性能</p><p>不会对大对象进行搬迁压缩 85000字节<strong>（83kb）以上的对象为大对象</strong></p><blockquote><p>请简述GC（垃圾回收）产生的原因，并至少说出避免GC发生的三种方式？</p></blockquote><ul><li><p>GC产生原因</p><p>是 避免堆内存溢出而产生的回收机制<br>当不再使用的堆内存占用达到一定上限时，将会进行垃圾回收</p></li><li><p>避免方式：</p><ol><li>尽量减少new对象，尽量复用对象（可使用缓存池）</li><li>用StringBuilder替换String，避免字符串拼接时产生垃圾</li><li>公共对象用静态声明<br>等等</li></ol></li></ul><h3 id="请简要说明-Net跨语言原理"><a href="#请简要说明-Net跨语言原理" class="headerlink" title="请简要说明.Net跨语言原理"></a>请简要说明.Net跨语言原理</h3><p><strong>.Net制定了了CLI（公共语言架构）的规则</strong><br>只要是按照该规则设计的语言在进行.Net相关开发时<br><strong>编译器会将源代码（C#、VB等等）编译为CIL（公共中间语言）通用中间代码</strong>。<br>也就是说不管什么语言进行开发，最终都会统一规范变为中间代码<br>最终通过<strong>CLR（公共语言运行时或者称为.Net虚拟）将中间代码翻译为对应操作系统的原生代码（机器码）</strong>在操作系统（Windows）上运行</p><p><img src="https://img-blog.csdn.net/20160528132344296" alt="img"></p><h3 id="网络游戏开发中，网络传输数据的基本流程是什么？"><a href="#网络游戏开发中，网络传输数据的基本流程是什么？" class="headerlink" title="网络游戏开发中，网络传输数据的基本流程是什么？"></a>网络游戏开发中，网络传输数据的基本流程是什么？</h3><p>客户端将自定义类对象数据序列化为2进制数据发送给服务端</p><p>服务端将收到的2进制数据反序列化为对应的类对象进行逻辑处理</p><p>如果是服务端发送给客户端的消息也是同理</p><hr><h2 id="🌙Lua、XLua与热更新"><a href="#🌙Lua、XLua与热更新" class="headerlink" title="🌙Lua、XLua与热更新"></a>🌙Lua、XLua与热更新</h2><h3 id="Lua数据类型"><a href="#Lua数据类型" class="headerlink" title="Lua数据类型"></a>Lua数据类型</h3><p>Lua是动态类型语言，变量不要类型定义,只需要为变量赋值。 值可以存储在变量中，作为参数传递或结果返回。</p><p>Lua中有<strong>8个基本类型</strong>分别为：<strong>nil、boolean、number、string、userdata、function、thread和table</strong>。</p><p>其中：Lua 把 false 和 nil 看作是”假”，其他的都为”真”:</p><h3 id="pairs-和-ipairs区别"><a href="#pairs-和-ipairs区别" class="headerlink" title="pairs 和 ipairs区别"></a>pairs 和 ipairs区别</h3><ul><li><p><strong>pairs</strong></p><p>迭代 table，可以遍历表中所有的 key 可以返回 nil</p></li><li><p><strong>ipairs</strong></p><p>迭代数组，不能返回 nil,如果遇到 nil 则退出</p></li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> tab= &#123; [<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;a&quot;</span>, [<span class="hljs-number">3</span>] = <span class="hljs-string">&quot;b&quot;</span>, [<span class="hljs-number">4</span>] = <span class="hljs-string">&quot;c&quot;</span> &#125; <br><br><span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(tab) <span class="hljs-keyword">do</span>        <span class="hljs-comment">-- 输出 &quot;a&quot; ,&quot;b&quot;, &quot;c&quot;  ,    </span><br><br>   <span class="hljs-built_in">print</span>( tab[i] ) <br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(tab) <span class="hljs-keyword">do</span>    <span class="hljs-comment">-- 输出 &quot;a&quot; ,k=2时断开</span><br><br>    <span class="hljs-built_in">print</span>( tab[i] )<br><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="Lua表中问题"><a href="#Lua表中问题" class="headerlink" title="Lua表中问题"></a>Lua表中问题</h3><blockquote><p>下列代码中是否会打印 1</p></blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua">Student = &#123;<br>    age = <span class="hljs-number">1</span>,<br>    Up = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>        <span class="hljs-built_in">print</span>(age)<br>    <span class="hljs-keyword">end</span><br>&#125;<br></code></pre></td></tr></table></figure><p>不会，这个<strong>print(age) 和 表中的age 没有关系</strong></p><p>print(a)里面的age是一个全局变量</p><p>如果要使用，改成</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--第一钟</span><br><span class="hljs-built_in">print</span>(Student.age)<br><span class="hljs-comment">--第二种 把自己作为一个参数 </span><br>Up = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(t)</span></span><br>    <span class="hljs-built_in">print</span>(t.age)<br><span class="hljs-keyword">end</span><br><span class="hljs-comment">--调用时,把自己作为参数传入自己</span><br>Student.Up(Student)<br><br><span class="hljs-comment">--第三种 使用语法糖 重要！！！</span><br>Up = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(t)</span></span><br>    <span class="hljs-built_in">print</span>(t.age)<br><span class="hljs-keyword">end</span><br>Student:Up()<br></code></pre></td></tr></table></figure><blockquote><p>Lua 中0 . 和 ：的区别</p></blockquote><ul><li><p><strong>：(冒号）</strong></p><p>冒号调用方法，会默认把调用者 作为第一个参数传入方法中</p><p>注：内部不能使用：，只能在外部使用</p></li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> t = &#123; x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span> &#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">t:SetPos</span><span class="hljs-params">(newX, newY)</span></span><br>  <span class="hljs-comment">--self会默认调用第一个参数 ： 的第一个参数就是表本身</span><br>  <span class="hljs-built_in">self</span>.x = newX<br>  <span class="hljs-built_in">self</span>.y = newY<br><span class="hljs-keyword">end</span><br><br>t:SetPos(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)<br></code></pre></td></tr></table></figure><ul><li><p><strong>.  (点)</strong></p><p>正常调用方法，直接访问表中的元素，有啥传啥</p></li></ul><h3 id="Lua元方法"><a href="#Lua元方法" class="headerlink" title="Lua元方法"></a>Lua元方法</h3><blockquote><p>Lua中常用的元方法有哪些？至少说出3个原方法</p></blockquote><p><code>__</code>index<br><code>__</code>newindex<br><code>__</code>tostring<br><code>__</code>call<br><code>__</code>add 运算符+<br><code>__</code>sub 运算符-<br><code>__</code>mul 运算符*<br><code>__</code>div 运算符&#x2F;<br><code>__</code>mod 运算符%<br><code>__</code>unm 运算符-<br><code>__</code>concat 运算符..<br><code>__</code>eq 运算符&#x3D;&#x3D;<br><code>__</code>lt 运算符&lt;<br><code>__</code>le 运算符&lt;&#x3D;<br>等</p><h3 id="Lua元表-Metatable"><a href="#Lua元表-Metatable" class="headerlink" title="Lua元表(Metatable)"></a>Lua元表(Metatable)</h3><p>在 Lua table 中我们可以访问对应的key来得到value值，但是却无法对两个 table 进行操作。</p><p>因此 Lua 提供了<strong>元表(Metatable)，允许我们改变table的行为，每个行为关联了对应的元方法</strong>。</p><p>例如，使用元表我们可以定义Lua如何计算两个table的相加操作a+b。</p><p>当Lua试图对两个表进行相加时，先检查两者之一是否有元表，之后检查是否有一个叫”__add”的字段，若找到，则调用对应的值。”  _add”等即时字段，其对应的值（往往是一个函数或是table）就是”元方法”。</p><p>有两个很重要的函数来处理元表：</p><ul><li><p><strong>setmetatable(table,metatable):</strong></p><p>对指定table设置元表(metatable)，如果元表(metatable)中存在__metatable键值，setmetatable会失败 。</p></li><li><p><strong>getmetatable(table)</strong></p><p>返回对象的元表(metatable)。</p></li><li><p><strong>__index 元方法</strong></p></li></ul><p>这是 metatable 最常用的键。</p><p>当你通过键来访问 table 的时候，如果这个键没有值，那么Lua就会寻找该table的metatable（假定有metatable）中的_index 键。如果 __index包含一个表格，Lua会在表格中查找相应的键。</p><p>Lua查找一个表元素时的规则，其实就是如下3个步骤:</p><ol><li><p>在表中查找，如果找到，返回该元素，找不到则继续</p></li><li><p>判断该表是否有元表，如果没有元表，返回nil，有元表则继续。</p></li><li><p>判断元表有没有<code>__</code>index方法，如果<code>__</code>index方法为nil，则返回nil；如果<code>__</code>index方法是一个表，则重复1、2、3；如果<code>__</code>index方法是一个函数，则返回该函数的返回值。</p></li></ol><ul><li><p><strong><code>__</code>newindex 元方法</strong></p><p><code>__</code>newindex 元方法用来对表更新，__index则用来对表访问 。</p></li></ul><p>当你给表的一个缺少的索引赋值，解释器就会查找__newindex 元方法：如果存在则调用这个函数而不进行赋值操作。</p><ul><li><strong>__call 元方法</strong></li></ul><p>​   <code>__</code>call 元方法用于控制 function 的调用行为。</p><ul><li><strong>__tostring 元方法</strong></li></ul><p>​   <code>__</code>tostring 元方法用于修改表的输出行为。</p><ul><li><p><strong>rawget（table，“key”）</strong></p><p>当我们使用它时，会去找自己身上有没有这个变量，不会去metatable找</p></li><li><p><strong>rawset(table,”key”,value)</strong></p></li><li><p>会忽略newindex的设置 只会改自己的变量</p></li></ul><blockquote><p>_index  和 _newindex 的区别</p></blockquote><p>在 Lua 中，<code>__index</code> 和 <code>__newindex</code> 是元方法，用于控制表的索引操作和新索引操作。它们都可以用于实现数据的动态访问和更新</p><ul><li><p><strong><code>__index</code></strong> </p><p><code>__index</code> 元方法会在表中<strong>查找不存在的键</strong>时被调用</p></li><li><p><strong><code>__newindex</code></strong></p><p><code>__newindex</code> 元方法则会在表中<strong>设置不存在的键</strong>时被调用。</p></li></ul><h3 id="Lua-闭包的体现是什么"><a href="#Lua-闭包的体现是什么" class="headerlink" title="Lua 闭包的体现是什么"></a>Lua 闭包的体现是什么</h3><p>函数里面返回一个函数，改变函数变量里面的生命周期</p><p>闭包&#x3D;函数+引用环境<br>子函数可以使用父函数中的局部变量，这种行为可以理解为闭包</p><h3 id="Lua如何实现面向对象的三大特性？"><a href="#Lua如何实现面向对象的三大特性？" class="headerlink" title="Lua如何实现面向对象的三大特性？"></a>Lua如何实现面向对象的三大特性？</h3><p>面向对象三大特性</p><ul><li>封装：利用<strong>table进行封装</strong></li><li>继承：利用<strong>元表和<code>__</code>index</strong>模拟继承关系<br>       设置<strong>子类的元表为父类</strong>，<strong>父类的_index为父类自己</strong><br>       当<strong>子类</strong>身上<strong>找不到对应属性和方法</strong>时<br>       会<strong>查找元表的<code>__</code>index中的内容，也就是会查找父类中的内容</strong><br>       通过这种方式来模拟继承</li><li>多态：子类自己去实现带：的同名方法即可</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--面向对象三大特性 ： 封装 继承 多态</span><br><br>Object = &#123;&#125;<br><br><span class="hljs-comment">--封装</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Object:new</span><span class="hljs-params">()</span></span><br><span class="hljs-keyword">local</span> obj = &#123;&#125;<br>    <span class="hljs-built_in">self</span>.<span class="hljs-built_in">__index</span> = <span class="hljs-built_in">self</span>;<br>    <span class="hljs-built_in">setmetatable</span>(obj,<span class="hljs-built_in">self</span>)<br>    <span class="hljs-keyword">return</span> obj<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">--继承</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Object:subClass</span><span class="hljs-params">(classname)</span></span><br>    <span class="hljs-built_in">_G</span>[classname] = &#123;&#125;<br>    <span class="hljs-keyword">local</span> obj = <span class="hljs-built_in">_G</span>[classname]<br>    <span class="hljs-built_in">self</span>.<span class="hljs-built_in">__index</span> = <span class="hljs-built_in">self</span><br>    obj.base = <span class="hljs-built_in">self</span><br>    <span class="hljs-built_in">setmetatable</span>(obj,<span class="hljs-built_in">self</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="Lua-中-require，loadfile和dofile的区别"><a href="#Lua-中-require，loadfile和dofile的区别" class="headerlink" title="Lua 中 require，loadfile和dofile的区别?"></a>Lua 中 require，loadfile和dofile的区别?</h3><p>首先区分loadfile，loadfile只负责编译并不会执行模块代码，而require和dofile都会编译且执行</p><h3 id="Lua-协同程序-coroutine"><a href="#Lua-协同程序-coroutine" class="headerlink" title="Lua 协同程序(coroutine)"></a><strong>Lua 协同程序(coroutine)</strong></h3><p><strong>什么是协同(coroutine)？</strong></p><p>Lua 协同程序(coroutine)与线程比较类似：拥有独立的堆栈，独立的局部变量，独立的指令指针，同时又与其它协同程序共享全局变量和其它大部分东西。</p><p>协同是非常强大的功能，但是用起来也很复杂。</p><p><strong>线程和协同程序区别</strong></p><p>线程与协同程序的主要区别在于，一个具有多个线程的程序可以同时运行几个线程，而协同程序却需要彼此协作的运行。</p><p>在任一指定时刻只有一个协同程序在运行，并且这个正在运行的协同程序只有在明确的被要求挂起的时候才会被挂起。</p><p>协同程序有点类似同步的多线程，在等待同一个线程锁的几个线程有点类似协同。</p><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Lua%E5%8D%8F%E7%A8%8B.png"></p><h3 id="Lua-深拷贝和浅拷贝的区别"><a href="#Lua-深拷贝和浅拷贝的区别" class="headerlink" title="Lua 深拷贝和浅拷贝的区别"></a>Lua 深拷贝和浅拷贝的区别</h3><ul><li><p>浅拷贝</p></li><li><p>使用 &#x3D; 运算符号进行浅拷贝</p><p>拷贝对象是string、number、bool基本类型。拷贝的过程就是复制黏贴！修改新拷贝出来的对象，不会影响原先对象的值，两者互不干涉</p></li><li><p>深拷贝</p><p>拷贝对象是table表，拷贝出来的对象和原先对象时同一个对象，占用同一个对象，只是一个人两个名字，类似C#引用地址，指向同一个堆里的数据~，两者任意改变都会影响对方。</p></li></ul><h3 id="Lua-调用-C-重载时会遇到什么问题？该怎么解决"><a href="#Lua-调用-C-重载时会遇到什么问题？该怎么解决" class="headerlink" title="Lua 调用 C#重载时会遇到什么问题？该怎么解决"></a>Lua 调用 C#重载时会遇到什么问题？该怎么解决</h3><p>Lua 虽然支持调用重载 但是因为lua中的数值类型只有Number</p><p>所以对C#中多精度的重载函数支持不好 分不清</p><p><strong>解决：</strong></p><p>Xlua 提供了解决方法</p><ol><li>通过Type得到C#函数</li><li>通过xlua.tofunction转为lua 然后使用</li></ol><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 利用反射机制</span><br><span class="hljs-comment">-- Type 是反射的关键类</span><br><span class="hljs-comment">-- 利用lua的typeof</span><br><br><span class="hljs-comment">--得到参数是int的重载</span><br><span class="hljs-keyword">local</span> m1 = typeof(CS.ClassName):GetMethod(<span class="hljs-string">&quot;FunctionName&quot;</span>,&#123;typeof(CS.System.Int32)&#125;)<br><span class="hljs-comment">--folat 的重载</span><br><span class="hljs-keyword">local</span> m2 = typeof(CS.ClassName):GetMethod(<span class="hljs-string">&quot;FunctionName&quot;</span>,&#123;typeof(CS.System.Single)&#125;)<br><br><span class="hljs-comment">--通过 xlua 提供的一个方法 把他转成lua函数</span><br><span class="hljs-keyword">local</span> f1 = xlua.tofunction(m1)<br><span class="hljs-keyword">local</span> f2 = xlua.tofunction(m2)<br><br>f1(<span class="hljs-number">1</span>)<br>f2(<span class="hljs-number">1.1</span>)<br><br></code></pre></td></tr></table></figure><h3 id="如何让系统类型和第三方代码能和Lua互相访问"><a href="#如何让系统类型和第三方代码能和Lua互相访问" class="headerlink" title="如何让系统类型和第三方代码能和Lua互相访问"></a>如何让系统类型和第三方代码能和Lua互相访问</h3><p>利用加特性[CSharpCallLua]和[LuaCallCSharp]解决，但是系统类和第三方代码是不能修改的</p><ul><li><p><strong>[CSharpCallLua]</strong> </p><p>C#调用lua代码的时候 用自定义委托装Lua函数的时候会在委托的时候加[CSharpCallLua] ，让Xlua识别这个委托是用来装lua函数的</p><p>接口也会使用这个特性</p></li><li><p><strong>[LuaCallCSharp]</strong></p><p>拓展方法是会加入这个特性</p><p>该特性每个被lua调用的类都加可以提示性能</p></li></ul><p><strong>解决方案：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//写一个静态类</span><br><span class="hljs-keyword">public</span> staitc <span class="hljs-keyword">class</span> <span class="hljs-title">ClassName</span><br>&#123;<br>    [<span class="hljs-meta">CSharpCallLua</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Type&gt; name = <span class="hljs-keyword">new</span> List&lt;Type&gt;()<br>    &#123;<br>        <span class="hljs-keyword">typeof</span>(UnityAction&lt;类型&gt;)<br>    &#125;<br>    --之后生成Xlua代码<br>    --[LuaCallCSharp]同理<br>    [<span class="hljs-meta">LuaCallCSharp</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Type&gt; name = <span class="hljs-keyword">new</span> List&lt;Type&gt;()<br>    &#123;<br>        <span class="hljs-keyword">typeof</span>(GameObject)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//好处:把所有特性汇总在这个地方</span><br></code></pre></td></tr></table></figure><h3 id="Lua-支持与不支持哪种类型的泛型函数、如何变为支持"><a href="#Lua-支持与不支持哪种类型的泛型函数、如何变为支持" class="headerlink" title="Lua 支持与不支持哪种类型的泛型函数、如何变为支持"></a>Lua 支持与不支持哪种类型的泛型函数、如何变为支持</h3><p><strong>支持：</strong></p><p>有约束有参数的泛型函数</p><p><strong>不支持：</strong></p><ol><li>没有约束的泛型函数</li><li>有约束没有参数的泛型函数</li><li>非Class的约束</li></ol><blockquote><p>如何变支持</p></blockquote><p>得到通用函数 设置泛型类型再使用</p><p>xlua提供了一个方法 : xlua.get_generic_method</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> name = xlua.get_generic_method(CS.ClassName,<span class="hljs-string">&quot;FuncName&quot;</span>)<br><span class="hljs-keyword">local</span> name_R = name(CS.System.指定类型)<br>name_R(CS.ClassName(),指定类型参数)<br></code></pre></td></tr></table></figure><p><font color = "red"><b>注意 有一定使用限制！！！</b></font></p><p>如果打包为 Mono 这种方式支持使用</p><p>IL2CPP打包 如果泛型参数是引用类型才能使用</p><p>IL2CPP打包 如果是值类型，除非C#那边已经调用过 同类型的泛型参数 lua才能够被使用</p><h3 id="Resource-和-AssetBundle-的区别"><a href="#Resource-和-AssetBundle-的区别" class="headerlink" title="Resource 和 AssetBundle 的区别"></a>Resource 和 AssetBundle 的区别</h3><ul><li><p><strong>Resource</strong></p><ol><li><p>打包时定死</p></li><li><p>只读</p></li><li><p>无法修改</p></li></ol></li><li><p><strong>AssetBundle</strong></p><ol><li>存储位置可以自定</li><li>压缩方式自定义</li><li>后期可以动态更新</li></ol></li></ul><h3 id="请简述热更新的流程"><a href="#请简述热更新的流程" class="headerlink" title="请简述热更新的流程"></a>请简述热更新的流程</h3><p>本地存在资源对比文件和已有资源</p><ol><li><p>下载资源服务器中的对比文件</p></li><li><p>将下载下来的远端对比文件和本地的做对比</p><p>记录需要更新的资源和要移除的资源</p></li><li><p>根据第二步中记录的信息，进行资源下载和移除</p></li><li><p>更新本地对比文件，其内容和刚才下载的远端对比文件一致</p></li></ol><blockquote><p>热更新方案有哪些？</p></blockquote><ul><li><p><strong>整包</strong>：存放在上SteamingAssets里<br>——策略：完整更新资源放在包里</p><p>——优点：首次更新少</p><p>——缺点：安装包下载时间长，首次安装久</p></li><li><p><strong>分包</strong><br>——策略：少部分资源放在包里，大部分更新资源存放在更新资源器中</p><p>——优点：安装包小，安装时间短，下载快</p><p>——缺点：首次更新下载解压缩包时间旧</p></li></ul><h3 id="Unity热更新解决方案中，Lua和ILRuntime方案的本质是什么？"><a href="#Unity热更新解决方案中，Lua和ILRuntime方案的本质是什么？" class="headerlink" title="Unity热更新解决方案中，Lua和ILRuntime方案的本质是什么？"></a>Unity热更新解决方案中，Lua和ILRuntime方案的本质是什么？</h3><p><strong>Lua热更本质：</strong><br>Lua是解释型语言，不需要实现编译，在运行时动态解释执行。xLua和toLua等Lua热更新解决方案，是通过在Unity中内置Lua虚拟机（解释器）来执行Lua逻辑的</p><p><strong>ILruntime热更本质：</strong><br>ILRuntime通过读取DLL文件中的IL汇编码，通过在Unity中内置的IL解释执行虚拟机（解释器）来执行热更DLL中的代码</p><p>总体来说，他们都是在Unity中内置各自的解释器（写好的用于解释执行相关的代码）来执行我们的热更新代码</p><h3 id="如果不考虑IOS平台，只在Windows和Android平台上发布游戏，如何在不使用第三方热更新方案的前提下实现热更新功能"><a href="#如果不考虑IOS平台，只在Windows和Android平台上发布游戏，如何在不使用第三方热更新方案的前提下实现热更新功能" class="headerlink" title="如果不考虑IOS平台，只在Windows和Android平台上发布游戏，如何在不使用第三方热更新方案的前提下实现热更新功能"></a>如果不考虑IOS平台，只在Windows和Android平台上发布游戏，如何在不使用第三方热更新方案的前提下实现热更新功能</h3><p><strong>C#的反射</strong><br>可以通过热更DLL文件的形式，加载程序集（dll）<br>利用反射执行热更DLL包中的逻辑</p><hr><h2 id="🌙计算机网络"><a href="#🌙计算机网络" class="headerlink" title="🌙计算机网络"></a>🌙计算机网络</h2><h3 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP UDP"></a>TCP UDP</h3><p>TCP&#x2F;IP协议（一）网络基础知识 网络七层协议<br><a href="https://www.cnblogs.com/wanghuaijun/p/10092930.html">https://www.cnblogs.com/wanghuaijun/p/10092930.html</a></p><ul><li><p><strong>TCP</strong>(Transmission Control Protocol 传输控制协议)：<strong>是一种面向连接的、可靠的、基于字节流的传输层通信协议</strong>，使用三次握手协议建立连接、四次挥手断开连接。面向连接意味着两个使用TCP的应用(通常是一个客户端和一个服务器)在彼此交换数据包之前必须先建立一个TCP连接。在一个TCP连接中，仅有两方进行彼此通信，广播和多播不能用TCP。TCP 协议的作用是，保证数据通信的完整性和可靠性，防止丢包。TCP把连接作为最基本的对象，每一条TCP连接都有两个端点，这种端点我们叫作套接字(socket)，端口号拼接到IP地址即构成了套接字。</p><p><strong>特点：</strong></p><ol><li>面向连接</li><li>一对一</li><li>可靠性高</li><li>有序的</li></ol><blockquote><p>TCP协议的可靠性是如何达到的？</p></blockquote><p>TCP协议是通过检验和、确认应答信号、重发机制、连接管理、流量控制、拥塞控制等手段达到可靠的</p></li><li><p><strong>UDP</strong>(User Datagram Protocol 用户数据报协议)：<strong>是OSI</strong>(Open System Interconnection 开放式系统互联)<strong>参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务</strong>。UDP协议的主要作用是将网络数据流量压缩成数据包的形式。</p></li><li><p>区别：</p><ul><li>TCP提供的是面向连接的、可靠的数据流传输；UDP提供的是非面向连接的、不可靠的数据流传输。</li><li>TCP提供可靠的服务，通过TCP连接传送的数据，无差错、不丢失、不重复，按序到达；UDP尽最大努力交付，即不保证可靠交付。</li><li>TCP面向字节流；UDP面向报文。</li><li>TCP连接只能是点到点的；UDP支持一对一、一对多、多对一和多对多的交互通信。</li><li>UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。</li><li>TCP对系统资源要求较多，UDP对系统资源要求较少。TCP首部有20字节；UDP的首部只有8个字节。</li><li>TCP的逻辑通信信道是全双工的可靠信道；UDP的逻辑通信信道是不可靠信道。</li><li>基于TCP的应用：HTTP、WebSocker、重要数据文件传输等常见</li><li>基于UDP的应用：QQ等部分实时通信软件、视频&#x2F;音频下载传输等。</li></ul></li></ul><table><thead><tr><th></th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>连接方面</td><td>面向连接</td><td>无连接</td></tr><tr><td>是否可靠</td><td>可靠</td><td>不可靠</td></tr><tr><td>传输效率</td><td>相对UDP低</td><td></td></tr><tr><td>连接对象</td><td>一对一</td><td>n对n</td></tr></tbody></table><h3 id="三次握手，4次挥手"><a href="#三次握手，4次挥手" class="headerlink" title="三次握手，4次挥手"></a>三次握手，4次挥手</h3><ul><li><strong>三次握手</strong><ul><li>第一次握手：<strong>TCP连接请求，告诉服务器我要和你建立连接</strong>。客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 SYN_Send状态。</li><li>第二次握手：<strong>TCP授予连接，告诉客户端批准连接。</strong>服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD的状态。</li><li>第三次握手：<strong>TCP确认连接，告诉服务器，来就来</strong>。客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 establised状态。</li><li>服务器收到 ACK 报文之后，也处于 establised 状态，此时，双方以建立起了链接。</li></ul></li><li><strong>四次挥手</strong><ul><li>第一次挥手：<strong>告诉服务器我数据发完了，你如果还有消息就快发完</strong>。客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于CLOSED_WAIT1状态。</li><li>第二次握手：<strong>告诉客户端我知道了，请继续等待我的消息</strong>。服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT2状态。</li><li>第三次挥手：<strong>告诉客户端消息发完了，你可以正式断开连接了</strong>。如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK的状态。</li><li>第四次挥手：<strong>告诉服务器我等一会如果没有收到你回复我就断开了</strong>。客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态</li><li>服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</li></ul></li></ul><p><strong>总结</strong>：三次握手表示客户端和服务端进行连接的过程，四次挥手是两台设备断开连接做的什么</p><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/TCP%26UDP.png"></p><h3 id="状态同步-帧同步"><a href="#状态同步-帧同步" class="headerlink" title="状态同步,帧同步"></a>状态同步,帧同步</h3><p>帧同步和状态同步该怎么选（上）<br><a href="https://zhuanlan.zhihu.com/p/104932624">https://zhuanlan.zhihu.com/p/104932624</a></p><p>帧同步和状态同步<br><a href="https://zhuanlan.zhihu.com/p/33898014">https://zhuanlan.zhihu.com/p/33898014</a></p><h3 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h3><p>OSI（Open System Interconnection）是由国际标准化组织（ISO）制定的网络模型，该模型定义了不同计算机如何互相连接，是设计和描述计算机网络通信的基本框架。<a href="https://so.csdn.net/so/search?q=OSI%E6%A8%A1%E5%9E%8B&spm=1001.2101.3001.7020">OSI模型</a>将网络通信分为7层：</p><p><img src="https://img-blog.csdnimg.cn/20210530224055792.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzeTc3Nzc3Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>OSI仅是一个理论上的模型，实际使用的是TCP&#x2F;IP网络模型，TCP&#x2F;IP模型将OSI模型的应用层，表示层和会话层合并为应用层：</p><p><img src="https://img-blog.csdnimg.cn/20210530224106137.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzeTc3Nzc3Nw==,size_16,color_FFFFFF,t_70" alt="img"></p><hr><h2 id="🌙Unity-网络编程"><a href="#🌙Unity-网络编程" class="headerlink" title="🌙Unity 网络编程"></a>🌙Unity 网络编程</h2><h3 id="Socket套接字有3种不同的类型"><a href="#Socket套接字有3种不同的类型" class="headerlink" title="Socket套接字有3种不同的类型"></a>Socket套接字有3种不同的类型</h3><ol><li><p>流套接字</p><ul><li>主要用于实现TCP通信，提供了面向连接、可靠的、有序的、数据无差错且无重复的数据传输服务</li></ul></li><li><p>数据报套接字</p><ul><li>主要用于实现UDP通信，提供了无连接的通信服务，数据包的长度不能大于32KB，不提供正确性检查，不保证顺序，可能出现重发、丢失等情况</li></ul></li><li><p>原始套接字（不常用，不深入)</p><ul><li>主要用于实现IP数据包通信，用于直接访问协议的较低层，常用于侦听和分析数据包</li></ul></li></ol><h3 id="服务端和客户端需要做什么"><a href="#服务端和客户端需要做什么" class="headerlink" title="服务端和客户端需要做什么"></a>服务端和客户端需要做什么</h3><p>客户端：</p><ol><li>创建套接字Socket </li><li>用Connect方法与服务端相连</li><li>用Send和Receive相关方法收发数据</li><li>用Shutdown方法释放连接 </li><li>关闭套接字</li></ol><p>服务端 </p><ol><li>创建套接字Socket</li><li>用Bind方法将套接字与本地地址绑定</li><li>用Listen方法监听 </li><li>用Accept方法等待客户端连接 </li><li>建立连接，Accept返回新套接字 </li><li>用Send和Receive相关方法收发数据</li><li>用Shutdown方法释放连接</li><li>关闭套接字</li></ol><hr><h2 id="🌙计算机图形学（基于Games101）"><a href="#🌙计算机图形学（基于Games101）" class="headerlink" title="🌙计算机图形学（基于Games101）"></a>🌙计算机图形学（基于Games101）</h2><blockquote><p> <strong>笔记来自于：<a href="https://www.yuque.com/gaoshanliushui-mbfny/sst4c5/oq643c">https://www.yuque.com/gaoshanliushui-mbfny/sst4c5/oq643c</a></strong></p></blockquote><hr><h2 id="🌙算法"><a href="#🌙算法" class="headerlink" title="🌙算法"></a>🌙算法</h2><h3 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h3><p><a href="https://leetcode.cn/problemset/all/">题库 - 力扣 (LeetCode) 全球极客挚爱的技术成长平台</a></p><p><strong>每日一题</strong></p><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/V2QJXN%25LGY17_GWQIJ%24%7D1W1.png"></p><h3 id="代码随想录"><a href="#代码随想录" class="headerlink" title="代码随想录"></a>代码随想录</h3><p><a href="https://programmercarl.com/">代码随想录 (programmercarl.com)</a></p><h3 id="十大排序算法"><a href="#十大排序算法" class="headerlink" title="十大排序算法"></a>十大排序算法</h3><h4 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h4><p><img src="https://img-blog.csdnimg.cn/1daa0def8e454f61836f28a8d1cb2e0b.gif" alt="在这里插入图片描述"></p><p><strong>口诀：</strong></p><p>外层循环 n-1;内层循环 n-1-i;两两比较做互换；</p><blockquote><p>以下代码在控制台操作，输入数字以‘逗号’隔开</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BubbleSort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] array</span>)</span><br>&#123;<br><span class="hljs-built_in">bool</span> isSort = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; array.Length; ++i)<br>    &#123;<br>    isSort = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; array.Length - i - <span class="hljs-number">1</span>; ++j)<br>        &#123;<br>        <span class="hljs-keyword">if</span> (array[j] &gt; array[j + <span class="hljs-number">1</span>])<br>            &#123;<br>            isSort = <span class="hljs-literal">true</span>;<br><br>array[j] ^= array[j + <span class="hljs-number">1</span>];<br>                array[j + <span class="hljs-number">1</span>] ^= array[j];<br>                array[j] ^= array[j + <span class="hljs-number">1</span>];<br><br>&#125;<br>        &#125;<br>        <br>  <span class="hljs-keyword">if</span> (!isSort)<br>  <span class="hljs-keyword">break</span>;<br>                <br>     &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>程序执行结果：</p><p><img src="https://img-blog.csdnimg.cn/15b1cfff79a049f0bef2dc98617d8d8d.png" alt="在这里插入图片描述"></p><h4 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2.插入排序"></a>2.插入排序</h4><p><img src="https://img-blog.csdnimg.cn/d7de02f14c6c45f7ad9e75888ed6254b.gif" alt="在这里插入图片描述"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InsertSort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] array</span>)</span><br>&#123;<br>    <span class="hljs-built_in">int</span> noSortValue;<br>    <span class="hljs-built_in">int</span> sortIndex;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; array.Length; ++i)<br>    &#123;<br>        noSortValue = array[i];<br>        sortIndex = i - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (sortIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; array[sortIndex] &gt; noSortValue)<br>        &#123;<br>            array[sortIndex + <span class="hljs-number">1</span>] = array[sortIndex];<br>            --sortIndex;<br>        &#125;<br>        array[sortIndex + <span class="hljs-number">1</span>] = noSortValue;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序执行结果：</p><p><img src="https://img-blog.csdnimg.cn/15b1cfff79a049f0bef2dc98617d8d8d.png" alt="在这里插入图片描述"></p><h4 id="3-选择排序"><a href="#3-选择排序" class="headerlink" title="3.选择排序"></a>3.选择排序</h4><p><img src="https://img-blog.csdnimg.cn/b72900449cb44c15999f8d89c286bb69.gif" alt="在这里插入图片描述"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SelectionSort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] array</span>)</span><br>&#123;<br>    <span class="hljs-built_in">int</span> index;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; array.Length; i++)<br>    &#123;<br>        index = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = i + <span class="hljs-number">1</span>; j &lt; array.Length; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (array[index] &gt; array[j])<br>            &#123;<br>                index = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (index != i)<br>        &#123;<br>            array[i] ^= array[index];<br>            array[index] ^= array[i];<br>            array[i] ^= array[index];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序执行结果：</p><p><img src="https://img-blog.csdnimg.cn/5ca6790d2c4740ba86e8b956475dd2bd.png" alt="在这里插入图片描述"></p><h4 id="4-快速排序"><a href="#4-快速排序" class="headerlink" title="4.快速排序"></a>4.快速排序</h4><p><img src="https://img-blog.csdnimg.cn/5ff1f36a0e694cbc9ffd5f2e6089a821.gif" alt="在这里插入图片描述"></p><p>快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists)。</p><p><strong>步骤为：</strong></p><ol><li><p>从数列中挑出一个元素，称为 “基准”（pivot）。</p></li><li><p>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆放在基准的后面（相同的数可以到任一边）。在这个分割结束之后，该基准就处于数列的中间位置。这个称为分割（partition）操作。</p></li><li><p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p></li></ol><p>递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个演算法总会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">QuickSort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] array, <span class="hljs-built_in">int</span> left, <span class="hljs-built_in">int</span> right</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (left &gt;= right)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">int</span> tempLeft, tempRight, temp;<br>    temp = array[left];<br>    tempLeft = left;<br>    tempRight = right;<br><br>    <span class="hljs-keyword">while</span> (tempLeft != tempRight)<br>    &#123;<br>        <span class="hljs-comment">//比较位置交换</span><br>        <span class="hljs-comment">//首先从右边开始比较，看值有没有资格标识的右侧</span><br>        <span class="hljs-comment">//移动右侧游标</span><br>        <span class="hljs-keyword">while</span> (tempLeft &lt; tempRight &amp;&amp;<br>            array[tempRight] &gt; temp)<br>        &#123;<br>            tempRight--;<br>        &#125;<br>        <span class="hljs-comment">//移动结束可以换位置</span><br>        array[tempLeft] = array[tempRight];<br><br>        <span class="hljs-comment">//移动左侧游标</span><br>        <span class="hljs-keyword">while</span> (tempLeft &lt; tempRight &amp;&amp;<br>            array[tempLeft] &lt; temp)<br>        &#123;<br>            tempLeft++;<br>        &#125;<br>        array[tempRight] = array[tempLeft];<br>    &#125;<br><br>    array[tempRight] = temp;<br>    QuickSort(array, left, tempRight - <span class="hljs-number">1</span>);<br>    QuickSort(array, tempLeft + <span class="hljs-number">1</span>, right);<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="5-希尔排序"><a href="#5-希尔排序" class="headerlink" title="5.希尔排序"></a>5.希尔排序</h4><p>插入排序的升级</p><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/640.gif"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">XiErSort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] array</span>)</span><br>&#123;<br>    <span class="hljs-built_in">int</span> noSortValue;<br>    <span class="hljs-built_in">int</span> sortIndex;<br>    <span class="hljs-comment">//第一次步长是第一次数组/2  所以：int step = arr.Length/2</span><br>    <span class="hljs-comment">//之后每次步长变化是step/2</span><br>    <span class="hljs-comment">//最小步长为1 stem&gt;0</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> step = array.Length / <span class="hljs-number">2</span>; step &gt; <span class="hljs-number">0</span>; step /= <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = step; i &lt; array.Length; i++)<br>        &#123;<br>            noSortValue = array[i];<br>            sortIndex = i - step;<br>            <span class="hljs-keyword">while</span> (sortIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; noSortValue &lt; array[sortIndex])<br>            &#123;<br>                array[sortIndex + step] = array[sortIndex];<br>                sortIndex -= step;<br>            &#125;<br>            array[sortIndex + step] = noSortValue;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>程序执行结果：</p><p><img src="https://img-blog.csdnimg.cn/2b6aaaf6b5914b2eb6efa5e559c18840.png" alt="在这里插入图片描述"></p><h4 id="6-堆排序"><a href="#6-堆排序" class="headerlink" title="6.堆排序"></a>6.堆排序</h4><p>堆排序首先是构建最大堆或最小堆。最大堆是用来正序排序，最小堆是用来倒序排序。</p><p>最大堆是指二叉树中每个结点的值都比其左右子结点的值大。同理最小堆是指二叉树中每个结点的值都比其左右子结点的值小。</p><p>对于二叉树不了解，在这里可以只有一个印象就可以。二叉树就是一个结点最多只有两个左右子结点。至于什么是完全二叉树，这里就不在过多解释，以后有机会写数据结构的时候，会着重解释，但是有一点要知道，数列从上往下，从左往右，按照只有一个根结点，且每个结点有两个子结点这样构建二叉树，那么他就是一颗完全二叉树。</p><p>下面我用一张图，来表示上面的概念，并加深印象。</p><p><img src="https://img-blog.csdnimg.cn/e33fa55d2e98407ea12bbc0b99221487.png" alt="在这里插入图片描述"></p><p>完全二叉树：<br>可以发现其实每个结点的下标和其左右子结点的下标是有一定关系的，即结点下标为n，左子结点下标为：2n+1，右子结点的下标为：2n+2。</p><p>最大堆：</p><p><img src="https://img-blog.csdnimg.cn/8f1362ccb2a043d98977410ba95406e2.png" alt="在这里插入图片描述"></p><p>上图为第一次构建最大堆的结果</p><p>可以看出因为根结点要比左右子结点数值大，而且其左右子结点要比其孙子结点数值大，以此类推，此时的根结点即为数列的最大值。</p><p>那么我们如何把一个无序构建成一个最大堆。首先看最大堆的最大特点就是：父结点的数值一定比左右结点数值大，我们依照这个规则不断的调整结点使其满足条件即可。</p><p>再仔细观察堆我们发现，由一半以上的结点是没有孩子结点的，这部分结点就称为叶子结点，那么也就是说，这部分结点是不需要向下调整的。我们选择从(length&#x2F;2)-1的下标开始依次从0下标的方向进行调整。每次调整之后，调整的结点还要继续比较他的子结点看看是否仍然满足最大堆特点，一直调整到叶子结点。这样做的目的就是使数列的大值向上浮，小值向下沉。直到下标0结点（根结点）调整完成，此时就是一个最大堆。</p><p>此时根结点是一个最大值，我们把最大值排在无序数列最后，即把最大值与队尾交换位置。此时我们发现除了根结点，其他结点仍然是符合最大堆特点的（注意，从这个位置往后，我们讲述的情况都是排除了最后一个数，因为他已经排好了位置）。这时我们只用调整根结点就可以了，调整之后，就得到了数列的第二个最大值。依次调整，直到数列排好即可。</p><p><img src="https://img-blog.csdnimg.cn/5eaad2f07d4e400daff97217f6b7ab49.gif" alt="在这里插入图片描述"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HeapCompare</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] array, <span class="hljs-built_in">int</span> nowIndex, <span class="hljs-built_in">int</span> arrayLength</span>)</span><br>&#123;<br>    <span class="hljs-comment">//通过传入的索引的到它对应的左右叶子结点的索引</span><br>    <span class="hljs-built_in">int</span> left = <span class="hljs-number">2</span> * nowIndex + <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">int</span> right = <span class="hljs-number">2</span> * nowIndex + <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">//用于记录较大数的索引</span><br>    <span class="hljs-built_in">int</span> bigggerIndex = nowIndex;<br>    <span class="hljs-comment">//先比左再比右</span><br>    <span class="hljs-keyword">if</span> (left &lt; arrayLength &amp;&amp; array[left] &gt; array[bigggerIndex])<br>    &#123;<br>        bigggerIndex = left;<br>    &#125;<br>    <span class="hljs-comment">//比较右结点</span><br>    <span class="hljs-keyword">if</span> (right &lt; arrayLength &amp;&amp; array[right] &gt; array[bigggerIndex])<br>    &#123;<br>        bigggerIndex = right;<br>    &#125;<br>    <span class="hljs-comment">//如果比较过后 发现最大索引发送变化 那就要换位置了</span><br>    <span class="hljs-keyword">if</span> (bigggerIndex != nowIndex)<br>    &#123;<br>        array[nowIndex] ^= array[bigggerIndex];<br>        array[bigggerIndex] ^= array[nowIndex];<br>        array[nowIndex] ^= array[bigggerIndex];<br><br>        <span class="hljs-comment">//通过递归是否影响了叶子结点的三角关系</span><br>        HeapCompare(array, bigggerIndex, arrayLength);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildBigHeap</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] array</span>)</span><br>&#123;<br>    <span class="hljs-comment">//从最大的非叶子结点索引开始，不停往前构建大堆顶</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = array.Length / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>    &#123;<br>        HeapCompare(array, i, array.Length);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HeapSort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] array</span>)</span><br>&#123;<br>    <span class="hljs-comment">//构建大堆顶</span><br>    BuildBigHeap(array);<br>    <span class="hljs-comment">//执行过后最大的数再最上层</span><br>    <span class="hljs-comment">//往屁股后面方 得到屁股后面最后一个索引</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = array.Length - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--)<br>    &#123;<br>        <span class="hljs-comment">//直接把 堆顶的顶端的数 放到最后一个</span><br>        array[<span class="hljs-number">0</span>] ^= array[i];<br>        array[i] ^= array[<span class="hljs-number">0</span>];<br>        array[<span class="hljs-number">0</span>] ^= array[i];<br>        <span class="hljs-comment">//重新进行大堆顶调整</span><br>        HeapCompare(array, <span class="hljs-number">0</span>, i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7-归并排序"><a href="#7-归并排序" class="headerlink" title="7.归并排序"></a>7.归并排序</h4><p>归并排序是建立在归并操作上的一种有效，稳定的排序算法，该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。 将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。 若将两个有序表合并成一个有序表，称为二路归并。</p><p>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p><ul><li><p>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；</p></li><li><p>自下而上的迭代；</p></li></ul><p><strong>算法步骤</strong></p><ol><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li><li>重复步骤 3 直到某一指针达到序列尾；</li><li>将另一序列剩下的所有元素直接复制到合并序列尾。</li></ol><p><img src="https://img-blog.csdnimg.cn/0c66af0a2da0474d94384b06847ba235.gif" alt="在这里插入图片描述"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span>[] <span class="hljs-title">MergeSort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] array</span>)</span><br>&#123;<br>    <span class="hljs-comment">// 递归结束条件</span><br>    <span class="hljs-keyword">if</span> (array.Length &lt; <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> array;<br>    <span class="hljs-comment">//1.数组分两段  得到一个中间索引</span><br>    <span class="hljs-built_in">int</span> mid = array.Length / <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">//2.初始化左右数组</span><br>    <span class="hljs-built_in">int</span>[] left = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[mid];<br>    <span class="hljs-built_in">int</span>[] right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[array.Length - mid];<br>    <span class="hljs-comment">//左右初始化内容</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; array.Length; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; mid)<br>            left[i] = array[i];<br>        <span class="hljs-keyword">else</span><br>            right[i - mid] = array[i];<br>    &#125;<br>    <span class="hljs-comment">//3.递归再分再排序</span><br>    <span class="hljs-keyword">return</span> Sort(MergeSort(left), MergeSort(right));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span>[] <span class="hljs-title">Sort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] left, <span class="hljs-built_in">int</span>[] right</span>)</span><br>&#123;<br><br>    <span class="hljs-comment">//先准备一个新数组</span><br>    <span class="hljs-built_in">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[left.Length + right.Length];<br>    <span class="hljs-built_in">int</span> leftIndex = <span class="hljs-number">0</span>;<span class="hljs-comment">//左数组索引</span><br>    <span class="hljs-built_in">int</span> rightIndex = <span class="hljs-number">0</span>;<span class="hljs-comment">//右数组索引</span><br><br>    <span class="hljs-comment">//最终目的是要填满这个新数组</span><br>    <span class="hljs-comment">//不会初心两侧都放完还在进循环</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; array.Length; i++)<br>    &#123;<br>        <span class="hljs-comment">//左侧放完了，代表右侧全部大于左侧直接方对面</span><br>        <span class="hljs-keyword">if</span> (leftIndex &gt;= left.Length)<br>        &#123;<br>            array[i] = right[rightIndex];<br>            rightIndex++;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rightIndex &gt;= right.Length)<br>        &#123;<br>            array[i] = left[leftIndex];<br>            leftIndex++;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left[leftIndex] &lt; right[rightIndex])<br>        &#123;<br>            array[i] = left[leftIndex];<br>            leftIndex++;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            array[i] = right[rightIndex];<br>            rightIndex++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> array;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="8-计数排序"><a href="#8-计数排序" class="headerlink" title="8.计数排序"></a>8.计数排序</h4><p><img src="https://img-blog.csdnimg.cn/9fbfeab31f384aad9329a49fe345f678.gif" alt="在这里插入图片描述"></p><p>计数排序是一种适合于最大值和最小值的差值不是不是很大的排序。例如 temp[i] &#x3D; m, 表示元素 i 一共出现了 m 次</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CountSort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] arr</span>)</span><br> &#123;<br>     <span class="hljs-comment">//1.得到数列的最大值 和 最小值</span><br>     <span class="hljs-built_in">int</span> Max = arr[<span class="hljs-number">0</span>];<br>     <span class="hljs-built_in">int</span> Min = arr[<span class="hljs-number">0</span>];<br> <br>     <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; arr.Length; i++)<br>     &#123;<br>         <span class="hljs-keyword">if</span> (arr[i] &gt; Max) Max = arr[i];<br>         <span class="hljs-keyword">if</span> (arr[i] &lt; Min) Min = arr[i];<br>     &#125;<br>     <span class="hljs-comment">//2.根据数列最大值确定统计数组的长度</span><br>     <span class="hljs-built_in">int</span>[] newArr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[Max -Min+ <span class="hljs-number">1</span>];<br>     <span class="hljs-comment">//3.遍历数列，填充统计数组 记得加上 偏移量Min</span><br>     <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.Length; i++)<br>     &#123;<br>         newArr[arr[i]-Min]++;<br>     &#125;<br>     <span class="hljs-comment">//4.遍历统计数组，输出结果 记得加上 偏移量Min</span><br>     <span class="hljs-built_in">int</span> Index = <span class="hljs-number">0</span>;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; newArr.Length; i++)<br>     &#123;<br>         <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; newArr[i]; j++)<br>         &#123;<br>             arr[Index++] = i+Min;<br>         &#125;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h4 id="9-桶排序"><a href="#9-桶排序" class="headerlink" title="9.桶排序"></a>9.桶排序</h4><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p><p><strong>算法步骤</strong></p><ol><li>设置一个定量的数组当作空桶；</li><li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li><li>对每个不是空的桶进行排序；</li><li>从不是空的桶里把排好序的数据拼接起来。</li></ol><p><img src="https://img-blog.csdnimg.cn/b7e8e42333e1432bb1a494d301c1c41e.gif" alt="在这里插入图片描述"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 桶排序</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span> &#123;<br>        <span class="hljs-built_in">double</span>[] array = &#123; <span class="hljs-number">0.43</span>, <span class="hljs-number">0.69</span>, <span class="hljs-number">0.11</span>, <span class="hljs-number">0.72</span>, <span class="hljs-number">0.28</span>, <span class="hljs-number">0.21</span>, <span class="hljs-number">0.56</span>, <span class="hljs-number">0.80</span>, <span class="hljs-number">0.48</span>, <span class="hljs-number">0.94</span>, <span class="hljs-number">0.32</span>, <span class="hljs-number">0.08</span> &#125;;<br><br>        BucketSort(array, <span class="hljs-number">10</span>);<br>        ShowSord(array);<br><br>        Console.ReadKey();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ShowSord</span>(<span class="hljs-params"><span class="hljs-built_in">double</span>[] array</span>)</span> &#123;<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> num <span class="hljs-keyword">in</span> array) &#123;<br>            Console.Write(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;num&#125;</span> &quot;</span>);<br>        &#125;<br>        Console.WriteLine();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BucketSort</span>(<span class="hljs-params"><span class="hljs-built_in">double</span>[] array, <span class="hljs-built_in">int</span> bucketNum</span>)</span> &#123;<br>        <span class="hljs-comment">//创建bucket时，在二维中增加一组标识位，其中bucket[x, 0]表示这一维所包含的数字的个数</span><br>        <span class="hljs-comment">//通过这样的技巧可以少写很多代码</span><br>        <span class="hljs-built_in">double</span>[,] bucket = <span class="hljs-keyword">new</span> <span class="hljs-built_in">double</span>[bucketNum, array.Length + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> num <span class="hljs-keyword">in</span> array) &#123;<br>            <span class="hljs-built_in">int</span> bit = (<span class="hljs-built_in">int</span>)(<span class="hljs-number">10</span> * num);<br>            bucket[bit, (<span class="hljs-built_in">int</span>)++bucket[bit, <span class="hljs-number">0</span>]] = num;<br>        &#125;<br>        <span class="hljs-comment">//为桶里的每一行使用插入排序</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; bucketNum; j++) &#123;<br>            <span class="hljs-comment">//为桶里的行创建新的数组后使用插入排序</span><br>            <span class="hljs-built_in">double</span>[] insertion = <span class="hljs-keyword">new</span> <span class="hljs-built_in">double</span>[(<span class="hljs-built_in">int</span>)bucket[j, <span class="hljs-number">0</span>]];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> k = <span class="hljs-number">0</span>; k &lt; insertion.Length; k++) &#123;<br>                insertion[k] = bucket[j, k + <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-comment">//插入排序</span><br>            StraightInsertionSort(insertion);<br>            <span class="hljs-comment">//把排好序的结果回写到桶里</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> k = <span class="hljs-number">0</span>; k &lt; insertion.Length; k++) &#123;<br>                bucket[j, k + <span class="hljs-number">1</span>] = insertion[k];<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//将所有桶里的数据回写到原数组中</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> count = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; j &lt; bucketNum; j++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> k = <span class="hljs-number">1</span>; k &lt;= bucket[j, <span class="hljs-number">0</span>]; k++) &#123;<br>                array[count++] = bucket[j, k];<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">StraightInsertionSort</span>(<span class="hljs-params"><span class="hljs-built_in">double</span>[] array</span>)</span> &#123;<br>        <span class="hljs-comment">//插入排序</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; array.Length; i++) &#123;<br>            <span class="hljs-built_in">double</span> sentinel = array[i];<br>            <span class="hljs-built_in">int</span> j = i - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; sentinel &lt; array[j]) &#123;<br>                array[j + <span class="hljs-number">1</span>] = array[j];<br>                j--;<br>            &#125;<br>            array[j + <span class="hljs-number">1</span>] = sentinel;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="10-基数排序"><a href="#10-基数排序" class="headerlink" title="10.基数排序"></a>10.基数排序</h4><p>基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数；</p><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</p><p>基数相对于其他排序，算法逻辑和代码都相对简单。<br>代码方面，也都是和另外两个排序的顺序一致。<br>与另外两个非比较排序不同的是：<br>计数排序和桶排序是基于数组索引来的，所以只能排序整数<br>但是基于数的计数而定，所以在改造后，理论上是也可以排序非整数</p><p><strong>算法步骤</strong></p><ol><li><p>求最值，取得数组中的最大数，并取得位数；</p></li><li><p>初新组，此处新组是指新桶，桶大小为10(因为基数只有0-10)；</p></li><li><p>正填充，将对应基数的数字放到对应的桶中</p></li><li><p>将桶中的数据反填充到array数组中</p></li></ol><blockquote><p>注：正反填充需要进行循环，循环次数为步骤一的位数 </p></blockquote><p><img src="https://img-blog.csdnimg.cn/de00f05f30634bf3aa413803b3f35d4b.gif" alt="在这里插入图片描述"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span>[] <span class="hljs-title">RadixSort2</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] array</span>)</span><br>&#123;<br>    <span class="hljs-comment">//求最(大)值</span><br>    <span class="hljs-built_in">int</span> max = array[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> array)<br>    &#123;<br>        max = item &gt; max ? item : max;<br>    &#125;<br><br>    <span class="hljs-built_in">int</span> maxDigit = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(max!=<span class="hljs-number">0</span>)<br>    &#123;<br>        max /= <span class="hljs-number">10</span>;maxDigit++;<br>    &#125;<br>    <span class="hljs-comment">//初新桶</span><br>    <span class="hljs-keyword">var</span> bucket = <span class="hljs-keyword">new</span> List&lt;List&lt;<span class="hljs-built_in">int</span>&gt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        bucket.Add(<span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;());<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; maxDigit; i++)<br>    &#123;<br>        <span class="hljs-comment">//正填充</span><br>        <span class="hljs-built_in">int</span> div = (<span class="hljs-built_in">int</span>)Math.Pow(<span class="hljs-number">10</span>, (i + <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> array)<br>        &#123;<br>            <span class="hljs-comment">//获取基数</span><br>            <span class="hljs-built_in">int</span> radix = (item % div) / (div / <span class="hljs-number">10</span>);<br>            bucket[radix].Add(item);<br>        &#125;<br>        <span class="hljs-comment">//反填充（//反填充要注意顺序）</span><br>        <span class="hljs-built_in">int</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> bucket)<br>        &#123;<br>            <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> it <span class="hljs-keyword">in</span> item)<br>            &#123;<br>                array[index++] = it;                        <br>            &#125;<br>            item.Clear();<span class="hljs-comment">//清除数据</span><br>        &#125;                <br>    &#125;<br>    <span class="hljs-keyword">return</span> array;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/49a4114d2323450792d15706511acdf4.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/842750f7516f4a62aa62e32a07190c1d.png" alt="在这里插入图片描述"></p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://raindust.blog.csdn.net/article/details/104127820">C#十大排序算法</a><br><a href="https://www.cnblogs.com/weiios/p/3933994.html">C#快速排序详解</a><br><a href="https://www.jianshu.com/p/e4d0990dd0bd">排序算法2|简单选择排序与堆排序（C#）</a><br><a href="https://www.cnblogs.com/cdaniu/p/16370507.html">【C# 排序】归并排序 merge sort</a><br><a href="https://blog.csdn.net/liuyi89430/article/details/107612559">C#计数排序</a><br><a href="https://bbs.huaweicloud.com/blogs/313568">【愚公系列】2021年11月 C#版 数据结构与算法解析(桶排序)</a><br><a href="https://www.freesion.com/article/96281055419/">C# 算法之基数排序排序(非比较排序之三)</a></p><hr><h2 id="🌙设计模式"><a href="#🌙设计模式" class="headerlink" title="🌙设计模式"></a>🌙设计模式</h2><p><a href="https://www.cnblogs.com/Impulse/p/4685463.html">C#设计模式总结 - 凡的世界 - 博客园 (cnblogs.com)</a></p><p><a href="https://bmtan.cc/2022/06/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">C# 设计模式 - Bmtan</a></p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>C#</tag>
      
      <tag>计算机网络</tag>
      
      <tag>Lua</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AssetBundle包 同步异步加载</title>
    <link href="/2022/07/30/AssetBundle%20%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD/"/>
    <url>/2022/07/30/AssetBundle%20%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="AssetBundle-同步与异步加载"><a href="#AssetBundle-同步与异步加载" class="headerlink" title="AssetBundle 同步与异步加载"></a>AssetBundle 同步与异步加载</h1><h2 id="AssetBundle相关Api"><a href="#AssetBundle相关Api" class="headerlink" title="AssetBundle相关Api"></a>AssetBundle相关Api</h2><h3 id="AssetBundle-LoadAsset"><a href="#AssetBundle-LoadAsset" class="headerlink" title="AssetBundle.LoadAsset"></a><a href="https://docs.unity.cn/cn/2022.1/ScriptReference/AssetBundle.html">AssetBundle</a>.LoadAsset</h3><p>public Object <strong>LoadAsset</strong> (string <strong>name</strong>);</p><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>从捆绑包中加载名为 <code>name</code> 的资源。</p><p>您应该准确指定 AssetBundleBuild 对象中的名称，即对象的相对路径加文件扩展名。</p><p>在版本 5.0 之前，用户可以使用 Load 直接获取单个组件。该函数现已弃用。请改为使用 LoadAsset 加载游戏对象，然后在对象上查找组件。</p><hr><p>public Object <strong>LoadAsset</strong> (string <strong>name</strong>, Type <strong>type</strong>);</p><hr><h3 id="AssetBundleManifest-GetAllDependencies"><a href="#AssetBundleManifest-GetAllDependencies" class="headerlink" title="AssetBundleManifest.GetAllDependencies"></a><a href="https://docs.unity.cn/cn/2022.1/ScriptReference/AssetBundleManifest.html">AssetBundleManifest</a>.GetAllDependencies</h3><p>public string[] <strong>GetAllDependencies</strong> (string <strong>assetBundleName</strong>);</p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><table><thead><tr><th>assetBundleName</th><th>资源捆绑包的名称。</th></tr></thead></table><h4 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h4><p>获取给定 AssetBundle 的所有依赖 AssetBundle。</p><hr><h3 id="AssetBundle-Unload"><a href="#AssetBundle-Unload" class="headerlink" title="AssetBundle.Unload"></a><a href="https://docs.unity.cn/cn/2022.1/ScriptReference/AssetBundle.html">AssetBundle</a>.Unload</h3><p>public void <strong>Unload</strong> (bool <strong>unloadAllLoadedObjects</strong>);</p><h4 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h4><table><thead><tr><th>unloadAllLoadedObjects</th><th>确定是否还将卸载从 AssetBundle 加载的对象的当前实例。</th></tr></thead></table><h4 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h4><p>卸载 AssetBundle 释放其数据。</p><p>When <code>unloadAllLoadedObjects</code> is false, compressed file data inside the bundle itself will be freed, but any instances of objects loaded from this bundle will remain intact. After calling UnloadAsync on an AssetBundle, you cannot load any more objects from that bundle and other operations on the bundle will throw InvalidOperationException.After calling UnloadAsync on an AssetBundle, you cannot load any more objects from that bundle and other operations on the bundle will throw InvalidOperationException.</p><p>当 <code>unloadAllLoadedObjects</code> 为 true 时，也将销毁从该捆绑包加载的所有对象。如果场景中有 GameObjects 引用这些资源，则对它们的引用将丢失。</p><p>不管是哪种情况，除非重新加载该捆绑包，否则将无法再从它加载任何其他对象。</p><p>有关所使用的不同压缩格式及其在加载时对内存的影响的说明，请参阅<a href="https://docs.unity.cn/cn/2022.1/Manual/AssetBundles-Building.html">构建 AssetBundle</a>。</p><p>另请参阅：<a href="https://docs.unity.cn/cn/2022.1/ScriptReference/AssetBundle.UnloadAllAssetBundles.html">AssetBundle.UnloadAllAssetBundles</a>。</p><hr><h3 id="AssetBundle-UnloadAllAssetBundles"><a href="#AssetBundle-UnloadAllAssetBundles" class="headerlink" title="AssetBundle.UnloadAllAssetBundles"></a><a href="https://docs.unity.cn/cn/2022.1/ScriptReference/AssetBundle.html">AssetBundle</a>.UnloadAllAssetBundles</h3><p>public static void <strong>UnloadAllAssetBundles</strong> (bool <strong>unloadAllObjects</strong>);</p><h4 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h4><table><thead><tr><th>unloadAllObjects</th><th>确定是否还将卸载从 AssetBundle 加载的对象的当前实例。</th></tr></thead></table><h4 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h4><p>卸载当前已加载的所有 AssetBundle。</p><p>当 <code>unloadAllObjects</code> 为 false 时，将释放当前加载的捆绑包中的压缩文件数据，但已从捆绑包中加载的任何对象实例将保持不变。</p><p>当 <code>unloadAllObjects</code> 为 true 时，也将销毁从当前已加载的捆绑包加载的所有对象。如果场景中有 GameObject 引用这些资源，则对它们的引用将丢失。</p><p>不管是哪种情况，除非重新加载当前已加载的捆绑包，否则无法再从它们加载任何其他对象。</p><p>有关所使用的不同压缩格式及其在加载时对内存的影响的说明，请参阅<a href="https://docs.unity.cn/cn/2022.1/Manual/AssetBundles-Building.html">构建 AssetBundle</a>。</p><p>另请参阅：<a href="https://docs.unity.cn/cn/2022.1/ScriptReference/AssetBundle.Unload.html">AssetBundle.Unload</a>。</p><hr><h2 id="AB包管理器"><a href="#AB包管理器" class="headerlink" title="AB包管理器"></a>AB包管理器</h2><p><strong>目的</strong>：让外部更方便的进行资源加载</p><blockquote><p>声明AssetBundle、AssetBundleManifest和字典存储加载过的ab包</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//主包</span><br>   <span class="hljs-keyword">private</span> AssetBundle mainAB = <span class="hljs-literal">null</span>;<br>   <span class="hljs-comment">//依赖包获取用的配置文件</span><br>   <span class="hljs-keyword">private</span> AssetBundleManifest manifest = <span class="hljs-literal">null</span>;<br><br><span class="hljs-comment">//AB包不能重复加载 重复会报错</span><br>   <span class="hljs-comment">//字典 用字典来存储 加载过的ab包</span><br>   <span class="hljs-keyword">private</span> Dictionary&lt;<span class="hljs-built_in">string</span>, AssetBundle&gt; abDic = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">string</span>, AssetBundle&gt;();<br></code></pre></td></tr></table></figure><blockquote><p>PathUrl 和 MainABName 属性 方便获取路径和主包名</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> PathUrl<br>    &#123;<br>        <span class="hljs-keyword">get</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> Application.streamingAssetsPath + <span class="hljs-string">&quot;/&quot;</span>;<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 主包名 方便修改</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> MainABName<br>    &#123;<br>        <span class="hljs-keyword">get</span><br>        &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> UNITY_IOS</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;IOS&quot;</span><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> UNITY_ANDROID</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Android&quot;</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;PC&quot;</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p>LoadAB 用于加载AB包、获取依赖包相关信息、加载资源来源包等共同操作</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LoadAB</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> abName</span>)</span><br>    &#123;<br>        <span class="hljs-comment">//加载AB包</span><br>        <span class="hljs-keyword">if</span> (mainAB == <span class="hljs-literal">null</span>)<br>        &#123;<br>            mainAB = AssetBundle.LoadFromFile(PathUrl + MainABName);<br>            manifest = mainAB.LoadAsset&lt;AssetBundleManifest&gt;(<span class="hljs-string">&quot;AssetBundleManifest&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//我们获取依赖包的相关信息</span><br>        <span class="hljs-built_in">string</span>[] strs = manifest.GetAllDependencies(abName);<br>        AssetBundle ab = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; strs.Length; i++)<br>        &#123;<br>            <span class="hljs-comment">//判断包是否加载过</span><br>            <span class="hljs-keyword">if</span> (!abDic.ContainsKey(strs[i]))<br>            &#123;<br>                ab = AssetBundle.LoadFromFile(PathUrl + strs[i]);<br>                abDic.Add(strs[i], ab);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//加载资源来源包</span><br>        <span class="hljs-comment">//如果没有加载过 再加载</span><br>        <span class="hljs-keyword">if</span> (!abDic.ContainsKey(abName))<br>        &#123;<br>            ab = AssetBundle.LoadFromFile(PathUrl + abName);<br>            abDic.Add(abName, ab);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="同步加载"><a href="#同步加载" class="headerlink" title="同步加载"></a>同步加载</h2><h3 id="同步加载-1"><a href="#同步加载-1" class="headerlink" title="同步加载"></a>同步加载</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//同步加载</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">LoadRes</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> abName, <span class="hljs-built_in">string</span> resName</span>)</span><br>    &#123;<br>        <span class="hljs-comment">//加载AB包</span><br>        LoadAB(abName);<br><br>        <span class="hljs-comment">//为了外面方便 在加载资源时 判断一下 资源是不是GameObject</span><br>        <span class="hljs-comment">//如果是 直接实例化 再返回给外部</span><br><br><br>        Object obj = abDic[abName].LoadAsset(resName);<br>        <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">is</span> GameObject)<br>            <span class="hljs-keyword">return</span> Instantiate(obj);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> obj;<br>        <br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="同步加载-通过type指定类型"><a href="#同步加载-通过type指定类型" class="headerlink" title="同步加载 通过type指定类型"></a>同步加载 通过type指定类型</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">LoadRes</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> abName, <span class="hljs-built_in">string</span> resName,System.Type type</span>)</span><br>    &#123;<br>        <span class="hljs-comment">//加载AB包</span><br>        LoadAB(abName);<br><br>        <span class="hljs-comment">//为了外面方便 在加载资源时 判断一下 资源是不是GameObject</span><br>        <span class="hljs-comment">//如果是 直接实例化 再返回给外部</span><br><br><br>        Object obj = abDic[abName].LoadAsset(resName,type);<br>        <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">is</span> GameObject)<br>            <span class="hljs-keyword">return</span> Instantiate(obj);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> obj;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="同步加载，根据泛型指定类型"><a href="#同步加载，根据泛型指定类型" class="headerlink" title="同步加载，根据泛型指定类型"></a>同步加载，根据泛型指定类型</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//同步加载，根据泛型指定类型</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">LoadRes</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-built_in">string</span> abName, <span class="hljs-built_in">string</span> resName</span>) <span class="hljs-keyword">where</span> T:Object</span><br>    &#123;<br>        <span class="hljs-comment">//加载AB包</span><br>        LoadAB(abName);<br><br>        <span class="hljs-comment">//为了外面方便 在加载资源时 判断一下 资源是不是GameObject</span><br>        <span class="hljs-comment">//如果是 直接实例化 再返回给外部</span><br><br><br>        T obj = abDic[abName].LoadAsset&lt;T&gt;(resName);<br>        <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">is</span> GameObject)<br>            <span class="hljs-keyword">return</span> Instantiate(obj);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> obj;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="异步加载"><a href="#异步加载" class="headerlink" title="异步加载"></a>异步加载</h2><p><font color="FF0000"><b>！！！ 这里的异步加载 AB包并没有使用异步加载，只是从AB包中 加载资源时 使用异步</b></font></p><h3 id="根据名字异步加载"><a href="#根据名字异步加载" class="headerlink" title="根据名字异步加载"></a>根据名字异步加载</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LoadResAsync</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> abName,<span class="hljs-built_in">string</span> resName,UnityAction&lt;Object&gt; callBack</span>)</span><br>    &#123;<br>        StartCoroutine(ReallyLoadResAsync(abName, resName, callBack));<br>    &#125;  <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> IEnumerator <span class="hljs-title">ReallyLoadResAsync</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> abName, <span class="hljs-built_in">string</span> resName, UnityAction&lt;Object&gt; callBack</span>)</span><br>    &#123;<br>        <span class="hljs-comment">//加载AB包</span><br>        LoadAB(abName);<br><br>        <span class="hljs-comment">//为了外面方便 在加载资源时 判断一下 资源是不是GameObject</span><br>        <span class="hljs-comment">//如果是 直接实例化 再返回给外部</span><br>        AssetBundleRequest abr = abDic[abName].LoadAssetAsync(resName);<br>        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> abr;<br>        <span class="hljs-comment">//异步加载结束后 通过委托 传递给外部 外部来使用</span><br>        <span class="hljs-keyword">if</span> (abr.asset <span class="hljs-keyword">is</span> GameObject)<br>            callBack(Instantiate(abr.asset));<br>        <span class="hljs-keyword">else</span><br>            callBack(abr.asset);<br>        <br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="根据Type异步加载"><a href="#根据Type异步加载" class="headerlink" title="根据Type异步加载"></a>根据Type异步加载</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//根据Type异步加载</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LoadResAsync</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> abName, <span class="hljs-built_in">string</span> resName,System.Type type, UnityAction&lt;Object&gt; callBack</span>)</span><br>    &#123;<br>        StartCoroutine(ReallyLoadResAsync(abName, resName, callBack));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> IEnumerator <span class="hljs-title">ReallyLoadResAsync</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> abName, <span class="hljs-built_in">string</span> resName,System.Type type, UnityAction&lt;Object&gt; callBack</span>)</span><br>    &#123;<br>        <span class="hljs-comment">//加载AB包</span><br>        LoadAB(abName);<br><br>        <span class="hljs-comment">//为了外面方便 在加载资源时 判断一下 资源是不是GameObject</span><br>        <span class="hljs-comment">//如果是 直接实例化 再返回给外部</span><br>        AssetBundleRequest abr = abDic[abName].LoadAssetAsync(resName,type);<br>        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> abr;<br>        <span class="hljs-comment">//异步加载结束后 通过委托 传递给外部 外部来使用</span><br>        <span class="hljs-keyword">if</span> (abr.asset <span class="hljs-keyword">is</span> GameObject)<br>            callBack(Instantiate(abr.asset));<br>        <span class="hljs-keyword">else</span><br>            callBack(abr.asset);<br><br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="根据泛型异步加载"><a href="#根据泛型异步加载" class="headerlink" title="根据泛型异步加载"></a>根据泛型异步加载</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LoadResAsync</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-built_in">string</span> abName, <span class="hljs-built_in">string</span> resName, UnityAction&lt;T&gt; callBack</span>) <span class="hljs-keyword">where</span> T:Object</span><br>    &#123;<br>        StartCoroutine(ReallyLoadResAsync(abName, resName, callBack));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> IEnumerator <span class="hljs-title">ReallyLoadResAsync</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-built_in">string</span> abName, <span class="hljs-built_in">string</span> resName, UnityAction&lt;T&gt; callBack</span>) <span class="hljs-keyword">where</span> T : Object</span><br>    &#123;<br>        <span class="hljs-comment">//加载AB包</span><br>        LoadAB(abName);<br><br>        <span class="hljs-comment">//为了外面方便 在加载资源时 判断一下 资源是不是GameObject</span><br>        <span class="hljs-comment">//如果是 直接实例化 再返回给外部</span><br>        AssetBundleRequest abr = abDic[abName].LoadAssetAsync&lt;T&gt;(resName);<br>        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> abr;<br>        <span class="hljs-comment">//异步加载结束后 通过委托 传递给外部 外部来使用</span><br>        <span class="hljs-keyword">if</span> (abr.asset <span class="hljs-keyword">is</span> GameObject)<br>            callBack(Instantiate(abr.asset) <span class="hljs-keyword">as</span> T);<br>        <span class="hljs-keyword">else</span><br>            callBack(abr.asset <span class="hljs-keyword">as</span> T);<br><br>    &#125;<br></code></pre></td></tr></table></figure><hr><h2 id="包卸载"><a href="#包卸载" class="headerlink" title="包卸载"></a>包卸载</h2><h3 id="单个包卸载"><a href="#单个包卸载" class="headerlink" title="单个包卸载"></a>单个包卸载</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">UnLoad</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> abName</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(abDic.ContainsKey(abName))<br>        &#123;<br>            abDic[abName].Unload(<span class="hljs-literal">false</span>);<br>            abDic.Remove(abName);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="所有包卸载"><a href="#所有包卸载" class="headerlink" title="所有包卸载"></a>所有包卸载</h3><pre><code class="C#">public void ClearAB()    &#123;        AssetBundle.UnloadAllAssetBundles(false);        abDic.Clear();        mainAB = null;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>热更新</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AssetBundle</tag>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C# 设计模式</title>
    <link href="/2022/06/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/06/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="C-设计模式"><a href="#C-设计模式" class="headerlink" title="C#设计模式"></a>C#设计模式</h1><h2 id="设计模式概述"><a href="#设计模式概述" class="headerlink" title="设计模式概述"></a>设计模式概述</h2><p>设计模式共<strong>23</strong>种。主要分为三部分：创建型模式、机构型模式、行为型模式。</p><p><strong>创建型模式：</strong>所有的模式都涉及到创建对象实例的方式。</p><p><strong>结构型模式：</strong>如何组合类和对象以获得更大的结构。</p><p><strong>行为型模式：</strong>通常和对象之间的通信有关。</p><p><strong>创建型模式：简单工厂模式、工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式</strong></p><p>工厂方法：提供了一个简单的决策类，它根据提供的数据返回一个抽象基类的多个子类中的一个。</p><p>抽象工厂：提供了一个创建并返回一些列相关对象的接口。</p><p>单例：某个类只能有一个实例。它提供了一个访问该实例的全局访问点。</p><p>建造者：将一个复杂的构建与它的表示分开，这样就能根据程序的需要创建不同的表现形式。</p><p>原型：先实例化一个类，然后拷贝或克隆该类来创建新的实例，可以用公有方法进一步修改这些实例。</p><p><strong>结构型模式：适配器模式、桥接模式、组合模式、装饰模式、外观模式、享元模式、代理模式</strong></p><p>适配器：将一个类的接口传换成另一个类的接口。</p><p>桥接：可以将一个类的接口与它的实现分离，这样可以不用修改客户端代码就能改变或替换实现过程。</p><p>组合：是一个对象的集合，其中的任何一个对象既可以是一个组合，也可以只是一个叶子对象。</p><p>装饰：用一个类包装给定的类，并为它添加新的功能，将所有未改动的方法传递给下面的类。</p><p>外观：将一系列复杂的对象放在一起，并提供一个新的、更简单的访问这些数据的接口。</p><p>享元：把一部分的类数据移到类外部，在执行方法时将数据传递进来，通过这种方式限制那些又小又相似的实例的增加数量。</p><p>代理：为一个比较复杂的对象提供一个简单的占位对象，实例化该复杂对象，在某种程度上比较浪费时间或代价较高。</p><p><strong>行为型模式：职责链、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、模板方法模式、访问者模式</strong></p><p>职责链：把请求从链中的一个对象传递到下一个对象，直到请求被响应为止。通过这种方式在对象之间去除耦合。</p><p>命令：用简单的对象表示软件命令的执行，支持登陆和取消操作。</p><p>解释器：提供一个如何把语言元素包含在程序中的定义。</p><p>迭代器：提供了一种顺序访问一个类中的一系列数据的方式。</p><p>中介者：定义了如何用一个对象简化对象之间的通信，是对象之间不必相互了解。</p><p>备忘录：定义了如何保存一个类实例的内容以便以后能恢复它。</p><p>观察者：定义了一种把改动通知给多个对象的方式。</p><p>状态：允许一个对象在其内部状态改变时修改它的行为。</p><p>策略：将算法封装到类里。</p><p>模板方法：提供了算法的抽象定义。</p><p>访问者：在不改变类的前提下，为一个类添加多种操作。</p><hr><h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/UML%E4%BD%BF%E7%94%A8.png"></p><p><strong>注意:</strong></p><p>“+”表示public，”-“表示private，”#”表示protected</p><p>空心三角形+实线表示实现<strong>继承</strong></p><p>空心三角形+虚线表示实现<strong>接口</strong></p><p><strong>关联关系</strong>用实线箭头</p><p><strong>聚合关系</strong>用空心菱形+实线箭头</p><p><strong>依赖关系</strong>用虚线箭头</p><hr><h2 id="面向对象六大原则"><a href="#面向对象六大原则" class="headerlink" title="面向对象六大原则"></a>面向对象六大原则</h2><h4 id="①-单一职责原则"><a href="#①-单一职责原则" class="headerlink" title="① 单一职责原则"></a>① 单一职责原则</h4><p><strong>定义：</strong></p><blockquote><p>单一职责原则，就一个类而言，应该仅有一个引起它变化的原因。</p></blockquote><ol><li><p><strong>如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。</strong></p></li><li><p><strong>软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离。</strong></p></li><li><p><strong>如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责。</strong></p></li></ol><p><strong>好处</strong>:</p><ul><li>类的复杂性降低，实现什么职责都有清晰明确的定义</li><li>可读性提高，复杂性降低，那当然可读性提高了</li><li>可维护性提高，可读性提高，那当然更容易维护了</li><li>变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助</li></ul><hr><h4 id="②-开放-封闭原则"><a href="#②-开放-封闭原则" class="headerlink" title="② 开放-封闭原则"></a>② 开放-封闭原则</h4><p><strong>定义：</strong></p><blockquote><p>开放-封闭原则，是说软件实体（类、模块、函数等等)应该可以扩展，但是不可修改。对于扩展是开放的（Open for extension)，对于更改是封闭的（Closed for modification)</p></blockquote><ol><li><p><strong>无论模块是多么的‘封闭’，都会存在一些无法对之封闭的变化。既然不可能完全封闭，设计人员必须对于他设计的模块应该对哪种变化封闭做出选择。他必须先猜测出最有可能发生的变化种类，然后构造抽象来隔离那些变化。</strong></p></li><li><p><strong>等到变化发生时立即采取行动。</strong></p></li><li><p><strong>在我们最初编写代码时，假设变化不会发生。当变化发生时，我们就创建抽象来隔离以后发生的同类变化。</strong></p></li><li><p><strong>面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码。</strong></p></li><li><p><strong>我们希望的是在开发工作展开不久就知道可能发生的变化。查明可能发生的变化所等待的时间越长，要创建正确的抽象就越困难。</strong></p></li><li><p><strong>开放-封闭原则是面向对象设计的核心所在。遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是可维护、可扩展、可复用、灵活性好。开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象，然而，对于应用程序中的每个部分都刻意地进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要</strong></p></li></ol><p><strong>好处</strong>：</p><ul><li>通过扩展已有的软件系统，可以提供新的行为,以满足对软件的新需求，是变化中的软件有一定的适应性和灵活性。</li><li>已有的软件模块，特别是最重要的抽象模块不能再修改，这就使变化中的软件系统有一定的稳定性和延续性</li></ul><hr><h4 id="③-依赖倒转原则"><a href="#③-依赖倒转原则" class="headerlink" title="③ 依赖倒转原则"></a>③ 依赖倒转原则</h4><p><strong>定义：</strong></p><blockquote><p>A．高层模块不应该依赖低层模块。两个都应该依赖抽象。</p><p>B．抽象不应该依赖细节。细节应该依赖抽象。</p><p>C.   要针对接口编程、不要对实现编程</p></blockquote><p><strong>好处：</strong></p><p>​<strong>依赖倒置原则可以提高程序的可扩展性，也可有效的降低程序耦合；依赖倒置原则避免了修改负责复杂逻辑的高层模块，大大提高了程序的稳定性。</strong></p><hr><h4 id="④-里氏转换原则"><a href="#④-里氏转换原则" class="headerlink" title="④ 里氏转换原则"></a>④ 里氏转换原则</h4><p><strong>定义：</strong></p><blockquote><p>里氏代换原则（LSP):子类型必须能够替换掉它们的父类型。</p></blockquote><ol><li><strong>一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。也就是说，在软件里面，把父类都替换成它的子类，程序的行为没有变化，简单地说，子类型必须能够替换掉它们的父类型。</strong></li><li><strong>只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。</strong></li><li><strong>由于子类型的可替换性才使得使用父类类型的模块在无需修改的情况下就可以扩展。</strong></li></ol><p><strong>好处：</strong></p><ul><li><p>约束继承泛滥，它也是开闭原则的一种很好的体现。</p></li><li><p>提高了代码的重用性。</p></li><li><p>降低了系统的出错率。类的扩展不会给原类造成影响，降低了代码出错的范围和系统出错的概率。</p></li><li><p>加强程序的健壮性，同时变更时可以做到非常好的兼容性，提高程序的维护性、可扩展性，降低需求变更时引入的风险。</p></li></ul><hr><h4 id="⑤-迪米特法则"><a href="#⑤-迪米特法则" class="headerlink" title="⑤ 迪米特法则"></a>⑤ 迪米特法则</h4><p><strong>定义：</strong></p><blockquote><p>迪米特法则(LoD)，如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。</p></blockquote><ol><li><strong>在类的结构设计上，每一个类都应当尽量降低成员的访问权限</strong></li><li><strong>迪米特法则其根本思想，是强调了类之间的松耦合。</strong></li><li><strong>类之间的耦合越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。</strong></li></ol><p><strong>好处：</strong></p><ul><li><p>降低了类之间耦合度，提高了模块的相对独立性。</p></li><li><p>亲和度降低，提高了类的可复用率和系统的扩展性。</p></li></ul><hr><h4 id="⑥-接口隔离原则"><a href="#⑥-接口隔离原则" class="headerlink" title="⑥ 接口隔离原则"></a>⑥ 接口隔离原则</h4><p><strong>定义：</strong></p><blockquote><p>接口隔离原则(Interface Segregation Principle, ISP)：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。</p></blockquote><ol><li><strong>每一个接口应该承担一种相对独立的角色，不干不该干的事情，干该干的事请</strong>。</li><li><strong>接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的接口，而不要提供大的总接口</strong></li><li><strong>在使用接口隔离原则时我们要控制接口的颗粒度，颗粒度不能太大，也不能太小。如果太小就会造成接口泛滥，不利于维护；接口入如果太大就会违背接口隔离原则，灵活性较差，使用起来不方便</strong>。</li></ol><p><strong>好处：</strong></p><ul><li><p>接口隔离原则是为了约束接口降低类对接口的依赖性</p></li><li><p>接口隔离提高了系统的内聚性,减少了对外交互,降低了系统的耦合性</p></li><li><p>能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法,当实现这个接口的时候,被迫设计冗余的代码。</p></li></ul><hr><h2 id="一、创建型设计模式"><a href="#一、创建型设计模式" class="headerlink" title="一、创建型设计模式"></a>一、创建型设计模式</h2><h3 id="1、简单工厂模式"><a href="#1、简单工厂模式" class="headerlink" title="1、简单工厂模式"></a>1、简单工厂模式</h3><h4 id="①-引言"><a href="#①-引言" class="headerlink" title="① 引言"></a>① 引言</h4><p>　　这个系列也是自己对设计模式的一些学习笔记,希望对一些初学设计模式的人有所帮助的,在上一个专题中介绍了单例模式,在这个专题中继续为大家介绍一个比较容易理解的模式——简单工厂模式。</p><h4 id="②-简单工厂模式的介绍"><a href="#②-简单工厂模式的介绍" class="headerlink" title="② 简单工厂模式的介绍"></a>② 简单工厂模式的介绍</h4><p>　　说到简单工厂，自然的第一个疑问当然就是什么是简单工厂模式了？ 在现实生活中工厂是负责生产产品的,同样在设计模式中,简单工厂模式我们也可以理解为负责<strong>生产对象的一个类</strong>, 我们平常编程中，当使用”new”关键字创建一个对象时，此时该类就依赖与这个对象，也就是他们之间的耦合度高，当需求变化时，我们就不得不去修改此类的源码，此时我们可以运用面向对象（OO）的很重要的原则去解决这一的问题，该原则就是——<font color="#FF0000">封装改变，既然要封装改变，自然也就要找到改变的代码，然后把改变的代码用类来封装</font>，这样的一种思路也就是我们简单工厂模式的实现方式了。下面通过一个现实生活中的例子来引出简单工厂模式。</p><h4 id="③-实现"><a href="#③-实现" class="headerlink" title="③ 实现"></a>③ 实现</h4><p><strong>简单工厂类：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c#"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">OperationFactory</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Operation <span class="hljs-title">createOperate</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> operate</span>)</span><br>    &#123;<br>     Operation oper=<span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">switch</span>(operate)<br>        &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span>:<br>                oper = <span class="hljs-keyword">new</span> OperationAdd();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span>:<br>                oper = <span class="hljs-keyword">new</span> OpeationSub();<br>            <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*&quot;</span>:<br>                oper = <span class="hljs-keyword">new</span> OperationMul();<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/&quot;</span>:<br>                oper = <span class="hljs-keyword">new</span> OperationDiv();<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> oper;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82UML.png"></p><h4 id="④-优点与缺点"><a href="#④-优点与缺点" class="headerlink" title="④ 优点与缺点"></a>④ 优点与缺点</h4><p>​<strong>1.主要优点</strong></p><p>​    简单工厂模式的主要优点如下：</p><p>​    (1) 工厂类包含必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的职责，而仅仅“消费”产品，简单工厂模式实现了对象创建和使用的分离。</p><p>​    (2) 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以在一定程度减少使用者的记忆量。</p><p>​    (3) 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。</p><p>​     <strong>2. 主要缺点</strong></p><p>​    简单工厂模式的主要缺点如下：</p><p>​    (1) 由于工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响。</p><p>​    (2) 使用简单工厂模式势必会增加系统中类的个数（引入了新的工厂类），增加了系统的复杂度和理解难度。</p><p>​    (3) 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。</p><p>​    (4) 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。</p><hr><h3 id="2、工厂方法模式"><a href="#2、工厂方法模式" class="headerlink" title="2、工厂方法模式"></a>2、工厂方法模式</h3><h4 id="①-引言-1"><a href="#①-引言-1" class="headerlink" title="① 引言"></a>① 引言</h4><p>　　<strong>工厂方法模式(Factory Method Pattern)：</strong>定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。工厂方法模式又简称为工厂模式(Factory Pattern)，又可称作虚拟构造器模式(Virtual Constructor Pattern)或多态工厂模式(Polymorphic Factory Pattern)。工厂方法模式是一种类创建型模式。</p><h4 id="②-工厂方法模式的介绍"><a href="#②-工厂方法模式的介绍" class="headerlink" title="② 工厂方法模式的介绍"></a>② 工厂方法模式的介绍</h4><p>　　工厂方法模式之所以可以解决简单工厂的模式，是因为它的实现把具体产品的创建推迟到子类中，此时工厂类不再负责所有产品的创建，而只是给出具体工厂必须实现的接口，这样工厂方法模式就可以允许系统不修改工厂类逻辑的情况下来添加新产品，这样也就克服了简单工厂模式中缺点。</p><h4 id="③-实现-1"><a href="#③-实现-1" class="headerlink" title="③ 实现"></a>③ 实现</h4><div align="center"><b>工厂方法UML</b></div><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95UML.png"></p><blockquote><p>&#x2F;&#x2F;工厂接口</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">interface</span> <span class="hljs-title">IFactory</span><br>&#123;<br>    <span class="hljs-function">Operation <span class="hljs-title">CreateOperation</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>加减乘除各间一个具体工厂去实现这个接口</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">AddFactory</span>:<span class="hljs-title">IFactory</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Operation <span class="hljs-title">CreateOperation</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> OperationAdd();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">SubFactory</span>:<span class="hljs-title">IFactory</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Operation <span class="hljs-title">CreateOperation</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> OperationSub();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">MulFactory</span>:<span class="hljs-title">IFactory</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Operation <span class="hljs-title">CreateOperation</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> OperationMul();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">DivFactory</span>:<span class="hljs-title">IFactory</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Operation <span class="hljs-title">CreateOperation</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> OperationDiv();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>客户端实现</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C#">IFactory operFactory=<span class="hljs-keyword">new</span> AddFactory();<br>Operation oper=operFactory.CreatOperation();<br>oper.NumberA=<span class="hljs-number">1</span>;<br>oper.NumberB=<span class="hljs-number">2</span>;<br><span class="hljs-built_in">double</span> result=oper.GetResult;<br></code></pre></td></tr></table></figure><div align="center"><b>工厂方法结构图</b></div><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><h4 id="④-优点与缺点-1"><a href="#④-优点与缺点-1" class="headerlink" title="④ 优点与缺点"></a>④ 优点与缺点</h4><p>​<strong>1.主要优点</strong></p><p>​    工厂方法模式的主要优点如下：</p><p>​    (1) 在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。</p><p>​    (2) 基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够让工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，就正是因为所有的具体工厂类都具有同一抽象父类。</p><p>​    (3) 使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改<strong>抽象工厂</strong>和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了，这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。</p><p>​<strong>2.主要缺点</strong></p><p>   工厂方法模式的主要缺点如下：</p><p>   (1) 在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。</p><p>   (2) 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。</p><h4 id="⑤-总结"><a href="#⑤-总结" class="headerlink" title="⑤ 总结"></a>⑤ 总结</h4><p><strong>工厂方法模式(Factory Method)</strong>,定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。</p><hr><h3 id="3、抽象工厂模式"><a href="#3、抽象工厂模式" class="headerlink" title="3、抽象工厂模式"></a>3、抽象工厂模式</h3><h4 id="①-引言-2"><a href="#①-引言-2" class="headerlink" title="① 引言"></a>① 引言</h4><p>​工厂方法模式是为了克服简单工厂模式的缺点而设计出来的,简单工厂模式的工厂类随着产品类的增加需要增加额外的代码），而工厂方法模式每个具体工厂类只完成单个实例的创建,所以它具有很好的可扩展性。但是在现实生活中，一个工厂只创建单个产品这样的例子很少，因为现在的工厂都多元化了，一个工厂创建一系列的产品，如果我们要设计这样的系统时，工厂方法模式显然在这里不适用，然后抽象工厂模式却可以很好地解决一系列产品创建的问题</p><h4 id="②-抽象工厂模式的介绍"><a href="#②-抽象工厂模式的介绍" class="headerlink" title="② 抽象工厂模式的介绍"></a>② 抽象工厂模式的介绍</h4><p>​抽象工厂模式：<strong>提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，它是一种对象创建型模式。</strong></p><h4 id="③-实现-2"><a href="#③-实现-2" class="headerlink" title="③ 实现"></a>③ 实现</h4><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82Uml.png"></p><blockquote><p>IDepartment接口，用于客户端访问，解除与具体数据库访问的耦合</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">interface</span> <span class="hljs-title">IDepartment</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span>(<span class="hljs-params">Department department</span>)</span>;<br>    <br>    <span class="hljs-function">Department <span class="hljs-title">GetDepartment</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> id</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>SqlseverDepartment类，用于访问SQL sever的Department</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlserverDepartment</span> : <span class="hljs-title">Ideparment</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span>(<span class="hljs-params">Department department</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;在Sql server中给Department 表增加一条记录&quot;</span>)<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Department <span class="hljs-title">GetDepartment</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> id</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;在Sql sever中根据Id得到Department 表一条记录&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>AccessDeapartment类，用于访问Acces的Department.</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">AccessDepartment</span> :<span class="hljs-title">IDepartment</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span>(<span class="hljs-params">Department department</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;在Acess中给Department 表增加一条记录&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Department <span class="hljs-title">GetDepartment</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> id</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;在Acess中根据Id得到Department 表一条记录&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>IFactory接口，定义一个创建访问User表对象的抽象的工厂接口</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">interface</span> <span class="hljs-title">IFactory</span><br>&#123;<br>    <span class="hljs-function">IUser <span class="hljs-title">CreateUser</span>()</span>;<br>    <span class="hljs-function">IDepartment <span class="hljs-title">CreateDepartment</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>SqlSeverFactory类，实现IFactory接口，实现SqlseverUser和SqlserverDepartment</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlseverFactory</span>:<span class="hljs-title">IFactory</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IUser <span class="hljs-title">CreateUser</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SqlseverUser();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IDepartment <span class="hljs-title">CreateDepartment</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SqlseverDepartment();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>AccessFactory类，实现IFactory接口，实现AccessrUser和AccessDepartment</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">AccessFactory</span>:<span class="hljs-title">IFactory</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IUser <span class="hljs-title">CreateUser</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AccessrUser();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IDepartment <span class="hljs-title">CreateDepartment</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AccessDepartment();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>客户端代码</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&#123;<br>    User user = <span class="hljs-keyword">new</span> User();<br>    Department dept=<span class="hljs-keyword">new</span> Department();<br>    <span class="hljs-comment">//IFactory factory= new SqlseverFactory();</span><br>    IFactory factory= <span class="hljs-keyword">new</span> AccessFactory();<br>    <br>    IUser iu=factory.CreateUser();<br>    <br>    iu.Insert(user);<br>    iu.GetUser(dept);<br>    id.GetDepartment(<span class="hljs-number">1</span>);<br>    <br>    Console.Read();<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><h4 id="④-优点与缺点-2"><a href="#④-优点与缺点-2" class="headerlink" title="④ 优点与缺点"></a>④ 优点与缺点</h4><p>​<strong>1.主要优点</strong></p><p>​    抽象工厂模式的主要优点如下：</p><p>​    (1) 抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易，所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。</p><p>​    (2) 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。</p><p>​    (3) 增加新的产品族很方便，无须修改已有系统，符合“开闭原则”。</p><p>​    <strong>2. 主要缺点</strong></p><p>​    抽象工厂模式的主要缺点如下：</p><p>​    增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了“开闭原则”。</p><h4 id="⑤-总结-1"><a href="#⑤-总结-1" class="headerlink" title="⑤ 总结"></a>⑤ 总结</h4><p><strong>抽象工厂模式</strong>，提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。</p><hr><h3 id="4、单例模式"><a href="#4、单例模式" class="headerlink" title="4、单例模式"></a>4、单例模式</h3><h4 id="①-引言-3"><a href="#①-引言-3" class="headerlink" title="① 引言"></a>① 引言</h4><p>​单例”字面意思上理解为——一个类只有一个实例，所以单例模式也就是<font color="FF0000"><strong>保证一个类只有一个实例的一种实现方法</strong></font>，单例模式的一个官方定义：<strong>确保一个类只有一个实例,并提供一个全局访问点。</strong></p><h4 id="②-单例设计模式介绍"><a href="#②-单例设计模式介绍" class="headerlink" title="② 单例设计模式介绍"></a>② 单例设计模式介绍</h4><p>​<strong>单例模式（Singleton）</strong>，保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p>​“通常我们可以让一个全局变量是的一个对象被访问，但它不能防止你实例化多个对象。一个最好办法就是，让类自身负责保存它的唯一实例。这个类可以保证有没有其他实例可以被创建，并且它可以提供一个访问该实例的方法。</p><p>​<strong>单例模式因为Singleton类封装它的唯一实例，这样它可以严格控制客户怎样访问它以及何时访问它。简单地说就是对唯一实例的受控访问。</strong></p><h4 id="③-实现-3"><a href="#③-实现-3" class="headerlink" title="③ 实现"></a>③ 实现</h4><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><blockquote><p>Singleton类，定义一个GetInstance操作，允许客户访问它的唯一实例。GetInstance 是一个静态方法，主要负责创建自己的唯一实例。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span>()</span><br>    &#123;<br>        <span class="hljs-comment">//构造方法让其private,这就毒死了外界利用new创建此类实例的可能</span><br>    &#125;<br>    <br>    <span class="hljs-comment">//此方法是获得本类实例的唯一全局访问点</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">GetInstance</span>()</span><br>    &#123;<br>        <span class="hljs-comment">//若实例不存在，则new一个新实例，否则返回已有的实例</span><br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)<br>        &#123;<br>            instance = <span class="hljs-keyword">new</span> Sington();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instacne;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>客户端代码</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&#123;<br>    Singleton s1 = Singleton.GetInstance();<br>    Singleton s2 = Singleton.GetInstance();<br>    <br>    <span class="hljs-keyword">if</span>(s1==s2)<br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;两个对象是相同的实例&quot;</span>);<br>    &#125;<br>    Console.Read();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="④-多线程使用单例模式所引发的问题"><a href="#④-多线程使用单例模式所引发的问题" class="headerlink" title="④ 多线程使用单例模式所引发的问题"></a>④ 多线程使用单例模式所引发的问题</h4><p>上面的单例模式的实现在单线程下确实是完美的,然而在多线程的情况下会得到多个Singleton实例,因为在两个线程同时运行GetInstance方法时，此时两个线程判断(uniqueInstance &#x3D;&#x3D;null)这个条件时都返回真，此时两个线程就都会创建Singleton的实例，这样就违背了我们单例模式初衷了，既然上面的实现会运行多个线程执行，那<strong>我们对于多线程的解决方案自然就是使GetInstance方法在同一时间只运行一个线程运行就好了</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span><br>    &#123;<br>        <span class="hljs-comment">// 定义一个静态变量来保存类的实例</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;<br><br>        <span class="hljs-comment">// 定义一个标识确保线程同步</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">object</span> locker = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>();<br><br>        <span class="hljs-comment">// 定义私有构造函数，使外界不能创建该类实例</span><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span>()</span><br>        &#123;<br>        &#125;<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 定义公有方法提供一个全局访问点,同时你也可以定义公有属性来提供全局访问点</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>       <br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">GetInstance</span>()</span><br>        &#123;<br>            <span class="hljs-comment">// 当第一个线程运行到这里时，此时会对locker对象 &quot;加锁&quot;，</span><br>            <span class="hljs-comment">// 当第二个线程运行该方法时，首先检测到locker对象为&quot;加锁&quot;状态，该线程就会挂起等待第一个线程解锁</span><br>            <span class="hljs-comment">// lock语句运行完之后（即线程运行完之后）会对该对象&quot;解锁&quot;</span><br>            <span class="hljs-keyword">lock</span> (locker)<br>            &#123;<br>                <span class="hljs-comment">// 如果类的实例不存在则创建，否则直接返回</span><br>                <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>)<br>                &#123;<br>                    uniqueInstance = <span class="hljs-keyword">new</span> Singleton();<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> uniqueInstance;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>上面这种解决方案确实可以解决多线程的问题,但是**上面代码对于每个线程都会对线程辅助对象locker加锁之后再判断实例是否存在，对于这个操作完全没有必要的，因为当第一个线程创建了该类的实例之后，后面的线程此时只需要直接判断（uniqueInstance&#x3D;&#x3D;null）为假，此时完全没必要对线程辅助对象加锁之后再去判断，所以上面的实现方式增加了额外的开销，损失了性能，为了改进上面实现方式的缺陷，我们只需要在lock语句前面加一句（uniqueInstance&#x3D;&#x3D;null）的判断就可以避免锁所增加的额外开销，这种实现方式我们就叫它 **<font color="FF0000"><b>“双重锁定”</b></font>，下面具体看看实现代码的：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span><br>   &#123;<br>       <span class="hljs-comment">// 定义一个静态变量来保存类的实例</span><br>       <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;<br><br>       <span class="hljs-comment">// 定义一个标识确保线程同步</span><br>       <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">object</span> locker = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>();<br><br>       <span class="hljs-comment">// 定义私有构造函数，使外界不能创建该类实例</span><br>       <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span>()</span><br>       &#123;<br>       &#125;<br><br>       <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>       <span class="hljs-comment"><span class="hljs-doctag">///</span> 定义公有方法提供一个全局访问点,同时你也可以定义公有属性来提供全局访问点</span><br>       <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">GetInstance</span>()</span><br>       &#123;<br>           <span class="hljs-comment">// 当第一个线程运行到这里时，此时会对locker对象 &quot;加锁&quot;，</span><br>           <span class="hljs-comment">// 当第二个线程运行该方法时，首先检测到locker对象为&quot;加锁&quot;状态，该线程就会挂起等待第一个线程解锁</span><br>           <span class="hljs-comment">// lock语句运行完之后（即线程运行完之后）会对该对象&quot;解锁&quot;</span><br>           <span class="hljs-comment">// 双重锁定只需要一句判断就可以了</span><br>           <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>)<br>           &#123;<br>               <span class="hljs-keyword">lock</span> (locker)<br>               &#123;<br>                   <span class="hljs-comment">// 如果类的实例不存在则创建，否则直接返回</span><br>                   <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>)<br>                   &#123;<br>                       uniqueInstance = <span class="hljs-keyword">new</span> Singleton();<br>                   &#125;<br>               &#125;<br>           &#125;<br>           <span class="hljs-keyword">return</span> uniqueInstance;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><h4 id="⑤-C-中实现了单例模式的类"><a href="#⑤-C-中实现了单例模式的类" class="headerlink" title="⑤ C#中实现了单例模式的类"></a>⑤ C#中实现了单例模式的类</h4><p>经过查看，.NET类库中确实存在单例模式的实现类，不过该类不是公开的，下面就具体看看该类的一个实现的(该类具体存在于System.dll程序集，命名空间为System,可以用反射工具Reflector去查看源码的)</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SR</span><br>    &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SR loader;<br>        <span class="hljs-function"><span class="hljs-keyword">internal</span> <span class="hljs-title">SR</span>()</span><br>        &#123;<br>        &#125;<br>        <span class="hljs-comment">// 主要是因为该类不是公有，所以这个全部访问点也定义为私有的了</span><br>        <span class="hljs-comment">// 但是思想还是用到了单例模式的思想的</span><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SR <span class="hljs-title">GetLoader</span>()</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (loader == <span class="hljs-literal">null</span>)<br>            &#123;<br>                SR sr = <span class="hljs-keyword">new</span> SR();<br>                Interlocked.CompareExchange&lt;SR&gt;(<span class="hljs-keyword">ref</span> loader, sr, <span class="hljs-literal">null</span>);<br>            &#125;<br>            <span class="hljs-keyword">return</span> loader;<br>        &#125;<br><br>        <span class="hljs-comment">// 这个公有方法中调用了GetLoader方法的</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">object</span> <span class="hljs-title">GetObject</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span><br>        &#123;<br>            SR loader = GetLoader();<br>            <span class="hljs-keyword">if</span> (loader == <span class="hljs-literal">null</span>)<br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> loader.resources.GetObject(name, Culture);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="⑥-总结"><a href="#⑥-总结" class="headerlink" title="⑥ 总结"></a>⑥ 总结</h4><p><strong>单例模式（Singleton）</strong>，保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><hr><h3 id="5、原型模式"><a href="#5、原型模式" class="headerlink" title="5、原型模式"></a>5、原型模式</h3><h4 id="①-引言-4"><a href="#①-引言-4" class="headerlink" title="① 引言"></a>① 引言</h4><p>​在软件系统中，当创建一个类的实例的过程很昂贵或很复杂，并且我们需要创建多个这样类的实例时，如果我们用new操作符去创建这样的类实例，这未免会增加创建类的复杂度和耗费更多的内存空间，因为这样在内存中分配了多个一样的类实例对象，然后如果采用工厂模式来创建这样的系统的话，随着产品类的不断增加，导致子类的数量不断增多，反而增加了系统复杂程度，所以在这里使用工厂模式来封装类创建过程并不合适，然而原型模式可以很好地解决这个问题，因为每个类实例都是相同的，当我们需要多个相同的类实例时，没必要每次都使用new运算符去创建相同的类实例对象，此时我们一般思路就是想——只创建一个类实例对象，如果后面需要更多这样的实例，可以通过对原来对象拷贝一份来完成创建，这样在内存中不需要创建多个相同的类实例，从而减少内存的消耗和达到类实例的复用。然而这个思路正是<strong>原型模式</strong>的实现方式。</p><h4 id="②-原型设计模式介绍"><a href="#②-原型设计模式介绍" class="headerlink" title="② 原型设计模式介绍"></a>② 原型设计模式介绍</h4><p><strong>原型模式（prototype）</strong>，用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象</p><p>在现实生活中，也有很多原型设计模式的例子，例如，细胞分裂的过程，一个细胞的有丝分裂产生两个相同的细胞；还有西游记中孙悟空变出后孙的本领和火影忍者中鸣人的隐分身忍术，写多份简历等。</p><h4 id="③-实现-4"><a href="#③-实现-4" class="headerlink" title="③ 实现"></a>③ 实现</h4><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><blockquote><p>原型类</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Prototype</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> id;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Prototype</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> id</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.id=id;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Id<br>    &#123;<br>        <span class="hljs-keyword">get</span>&#123;<span class="hljs-keyword">return</span> id;&#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">//抽象类的关键就是有这样一个Clone方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Prototype <span class="hljs-title">Clone</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>具体原型类</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcretePrototype</span> : <span class="hljs-title">Prototype</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcretePrototype</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> id</span>):<span class="hljs-title">base</span>(<span class="hljs-params">id</span>)</span><br>    &#123;<br>        <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> Prototype <span class="hljs-title">clone</span>()</span><br>    &#123;<br>        <span class="hljs-comment">//创建当前对象的浅表副本。方法时创建一个新对象，然后将当前对象的非静态字段复制到该新对象。如果字段时值类型的，则对该字段执行逐位复制。如果字段是引用类型，则复制引用但不复制引用的对象；因此，原始对象及其副本引用同一对象</span><br>        <span class="hljs-keyword">return</span> (Prototype)<span class="hljs-keyword">this</span>.MemberWiseClone();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>客户端代码</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&#123;<br>    ConcretePrototype p1= <span class="hljs-keyword">new</span> ConcretePrototype(<span class="hljs-string">&quot;I&quot;</span>);<br>    <span class="hljs-comment">//克隆类ConcretePrototype的对象p1就能得到新得实例c1</span><br>    ConcretePrototype c1= <span class="hljs-keyword">new</span> (ConcretePrototype)p1.Clone();<br>    Console.WriteLine(<span class="hljs-string">&quot;Clonded:&#123;0&#125;&quot;</span>,c1.Id);<br>    Console.Read();<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="④-浅拷贝和深拷贝"><a href="#④-浅拷贝和深拷贝" class="headerlink" title="④ 浅拷贝和深拷贝"></a>④ 浅拷贝和深拷贝</h4><p><strong>MemberwiseClone</strong>方法创建一个<strong>浅表副本</strong>，方法是创建一个新对象，然后将当前对象的非静态字段复制到该新对象。如果字段是<strong>值类型的，则对该字段执行逐位复制</strong>。如果字段是<strong>引用类型，则复制引用单不复制引用的对象</strong>；因此原始对象及其副本引用同一对象。</p><p>例如，考虑引用对象A和B的被称为X的对象。对象B依次引用对象C。X的浅表副本创建一个新对象X2，该对象也引用对象A和B。相比而言，X的深层副本创建一个新对象X2，该对象引用新对象A2和B2（人别为A和B的副本）。B2有引用新对象C2，C2是C的副本。该实例阐释了千层和深层复制操作之间的区别。</p><p>有很多方法可以实现深层复制操作，前提是浅表赋值操作有MemberwiseClone方法执行但不符合您的要求。这些要求包括：</p><ul><li>调用要复制的对象的构造函数以创建含有从第一个对象中提出的属性值的第二个对象。这假定对象的值完全由类构造函数定义。</li><li>调用MemberwiseClone方法创建的对象的浅表副本，然后将指定新的对象，其值均相同，院士对象的任何属性或字段的值是引用类型。该实例中的DeepCopy方法阐释了这种方法。</li><li>序列化要深层复制的对象，然后将序列化的数据还原到另一个对象变量。</li><li>使用带递归的反射执行的深层复制操作。</li></ul><p>下面的实力掩饰MemberwiseClone方法。它定义了ShallowCopy方法，该方法通过调用MemberwiseClone方法来在Person对象上执行浅表复制操作。他还定义了在Person对象上执行深层复制操作的DeepCopy方法。</p><p><strong>深拷贝</strong>把引用对象的变量指向复制过的新对象，而不是原有的被引用的对象。</p><div align="center"><b>简历的深拷贝复制实现</b></div><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%B7%B1%E6%8B%B7%E8%B4%9D.png"></p><blockquote><p>工作经历类</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//让工作经历实现ICloneable接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">WorkExperinece</span>:<span class="hljs-title">ICloneable</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> workDate;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> WorkDate<br>    &#123;<br>        <span class="hljs-keyword">get</span>;<br>        <span class="hljs-keyword">set</span>;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> company;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Company<br>    &#123;<br>        <span class="hljs-keyword">get</span>;<br>        <span class="hljs-keyword">set</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">Clone</span>()</span><br>    &#123;<br>        <span class="hljs-comment">//&quot;工作经历&quot;类实现克隆方法</span><br>        <span class="hljs-keyword">return</span> (Object)<span class="hljs-keyword">this</span>.MemberwiseColne();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>简历类</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">Resume</span> : <span class="hljs-title">Icloneable</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> sex;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> age;<br>    <span class="hljs-keyword">private</span> Workexperience work;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Resume</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.name=name;<br>        work=<span class="hljs-keyword">new</span> WorkExperience();<br>    &#125;<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Resume</span>(<span class="hljs-params">WorkExperience work</span>)</span><br>    &#123;<br>        <span class="hljs-comment">//提供Clone方法调用的私有构造函数，以便克隆&quot;工作经历&quot;的数据</span><br>        <span class="hljs-keyword">this</span>.work=(WorkExperience)work.Clone();<br>    &#125;<br>    <span class="hljs-comment">//设置个人信息</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetPersonalInfo</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> sex,<span class="hljs-built_in">string</span> age</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.sex=sex;<br>        <span class="hljs-keyword">this</span>.age=age;<br>    &#125;<br>    <span class="hljs-comment">//设置工作经历</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetWorkExperience</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> workDate,<span class="hljs-built_in">string</span> company</span>)</span><br>    &#123;<br>        work.WorkDate=workDate;<br>        work.Company=company<br>    &#125;<br>    <span class="hljs-comment">//显示</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Display</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;&#123;0&#125;&#123;1&#125;&#123;2&#125;&quot;</span>,name,sex,gae);<br>        Console.WriteLine(<span class="hljs-string">&quot;工作经历：&#123;0&#125;&#123;1&#125;&quot;</span>,work.WorkDate,work.Company);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//调用私有的构造方法，让“工作经历”克隆完成，然后再给这个“简历”对象的相关字段赋值，最终返回一个深拷贝的简历对象</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">Clone</span>()</span><br>&#123;<br>    Resume obj=<span class="hljs-keyword">new</span> Resume(<span class="hljs-keyword">this</span>.work);<br>    obj.name=<span class="hljs-keyword">this</span>.name;<br>    obj.sex=<span class="hljs-keyword">this</span>.sex;<br>    obj.age=<span class="hljs-keyword">this</span>.age;<br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="⑤-优点和缺点"><a href="#⑤-优点和缺点" class="headerlink" title="⑤ 优点和缺点"></a>⑤ 优点和缺点</h4><p><strong>原型模式的优点有：</strong></p><ol><li>原型模式向客户隐藏了创建新实例的复杂性</li><li>原型模式允许动态增加或较少产品类。</li><li>原型模式简化了实例的创建结构，工厂方法模式需要有一个与产品类等级结构相同的等级结构，而原型模式不需要这样。</li><li>产品类不需要事先确定产品的等级结构，因为原型模式适用于任何的等级结构</li></ol><p><strong>原型模式的缺点有：</strong></p><ol><li>每个类必须配备一个克隆方法</li><li>配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。</li></ol><h4 id="⑥-总结-1"><a href="#⑥-总结-1" class="headerlink" title="⑥ 总结"></a>⑥ 总结</h4><p><strong>原型模式（prototype）</strong>，用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象</p><hr><h3 id="6、建造者模式"><a href="#6、建造者模式" class="headerlink" title="6、建造者模式"></a>6、建造者模式</h3><h4 id="①-引言-5"><a href="#①-引言-5" class="headerlink" title="① 引言"></a>① 引言</h4><p>​在软件系统中，有时需要创建一个复杂对象，并且这个复杂对象由其各部分子对象通过一定的步骤组合而成。例如一个采购系统中，如果需要采购员去采购一批电脑时，在这个实际需求中，电脑就是一个复杂的对象，它是由CPU、主板、硬盘、显卡、机箱等组装而成的，如果此时让采购员一台一台电脑去组装的话真是要累死采购员了，这里就可以采用建造者模式来解决这个问题，我们可以把电脑的各个组件的组装过程封装到一个建造者类对象里，建造者只要负责返还给客户端全部组件都建造完毕的产品对象就可以了。然而现实生活中也是如此的，如果公司要采购一批电脑，此时采购员不可能自己去买各个组件并把它们组织起来，此时采购员只需要像电脑城的老板说自己要采购什么样的电脑就可以了，电脑城老板自然会把组装好的电脑送到公司。</p><h4 id="②-建造者设计模式介绍"><a href="#②-建造者设计模式介绍" class="headerlink" title="② 建造者设计模式介绍"></a>② 建造者设计模式介绍</h4><p>​如果需要<strong>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</strong>的意图的时候，我们需要应用于一个设计模式，‘<strong>建造者（Builder）模式</strong>’，又称叫生成器模式叫生成器模式。建造者模式可以将一个产品的内部表象与产品的生成过程分割开来，从而可以使一个建造过程生成具有不同的内部表象的产品对象。<strong>如果我们用了建造者模式，那么用户就只需指定需要建造的类型就可以得到它们，而具体建造的过程和细节就不需知道了</strong>。</p><p>​<strong>建造者模式是在当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方法时适用的模式</strong></p><h4 id="③-实现-5"><a href="#③-实现-5" class="headerlink" title="③ 实现"></a>③ 实现</h4><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><blockquote><p>Product类——产品类，由多个部件组成</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">Product</span><br>&#123;<br>    IList&lt;<span class="hljs-built_in">string</span>&gt; parts=<span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">string</span>&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> part</span>)</span><br>    &#123;<br>    parts.Add(part);    <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Show</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;\n 产品 创建 ——&quot;</span>);<br>        <span class="hljs-keyword">foreach</span>(<span class="hljs-built_in">string</span> part <span class="hljs-keyword">in</span> parts)<br>        &#123;<br>            Console.WriteLine(part);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Bulider类——抽象建造者类，确定产品由两个部件PartA和PartB组成，并声明一个得到产品建造后结果的方法GetResult</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPartA</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BulidPartB</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Product <span class="hljs-title">GetResult</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ConcreteBuilder类——具体建造者类</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteBuilder</span> :<span class="hljs-title">Builder</span><br>&#123;<br>    <span class="hljs-keyword">private</span> Product porduct =<span class="hljs-keyword">new</span> Product();<br>    <br>    <span class="hljs-comment">//建造具体的两个部件A和B</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPartA</span>()</span><br>    &#123;<br>        product.Add(<span class="hljs-string">&quot;部件A&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPartB</span>()</span><br>    &#123;<br>        product.Add(<span class="hljs-string">&quot;部件B&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> Product <span class="hljs-title">GetResult</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> product;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ConcreteBuilder2类——具体建造者类</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteBuilder2</span> :<span class="hljs-title">Builder</span><br>&#123;<br>    <span class="hljs-keyword">private</span> Product porduct =<span class="hljs-keyword">new</span> Product();<br>    <br>    <span class="hljs-comment">//建造具体的两个部件A和B</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPartA</span>()</span><br>    &#123;<br>        product.Add(<span class="hljs-string">&quot;部件X&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPartB</span>()</span><br>    &#123;<br>        product.Add(<span class="hljs-string">&quot;部件Y&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> Product <span class="hljs-title">GetResult</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> product;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Director类——指挥者类</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">Director</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Coonstruct</span>(<span class="hljs-params">Builder builder</span>)</span><br>    &#123;<br>        <span class="hljs-comment">//用来指挥建造过程</span><br>        builder.BuildPartA();<br>        builder.BuildPartB();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>客户端代码，客户不需知道具体的建造过程</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&#123;<br>    Director dircetor =<span class="hljs-keyword">new</span> Dircetor();<br>    Builder b1 = <span class="hljs-keyword">new</span> ConcreteBuilder1();<br>    Builder b2 = <span class="hljs-keyword">new</span> ConcreteBuilder2();<br>    <br>    <span class="hljs-comment">//指挥者用ConcreteBuilder1和ConcreteBuilder2的方法来建造产品</span><br>    director.Construct(b1);<br>    Product p1 = b1.GetResult();<br>    p1.Show();<br>    <br>    director.Construct(b2);<br>    Product p2 = b2.GetResult();<br>    p2.Show();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="④-总结"><a href="#④-总结" class="headerlink" title="④ 总结"></a>④ 总结</h4><p><strong>建造者（Builder）模式</strong>，将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</p><hr><h2 id="二、结构型设计模式"><a href="#二、结构型设计模式" class="headerlink" title="二、结构型设计模式"></a>二、结构型设计模式</h2><h3 id="1、适配器模式"><a href="#1、适配器模式" class="headerlink" title="1、适配器模式"></a>1、适配器模式</h3><h4 id="①-引言-6"><a href="#①-引言-6" class="headerlink" title="① 引言"></a>① 引言</h4><p>​在实际的开发过程中，由于应用环境的变化（例如使用语言的变化），我们需要的实现在新的环境中没有现存对象可以满足，但是其他环境却存在这样现存的对象。那么如果将“将现存的对象”在新的环境中进行调用呢？解决这个问题的办法就是我们本文要介绍的适配器模式——<strong>使得新环境中不需要去重复实现已经存在了的实现而很好地把现有对象（指原来环境中的现有对象）加入到新环境来使用</strong>。</p><h4 id="②-适配器设计模式介绍"><a href="#②-适配器设计模式介绍" class="headerlink" title="② 适配器设计模式介绍"></a>② 适配器设计模式介绍</h4><p>​适配器模式——把一个类的接口变换成客户端所期待的另一种接口，从而使原本接口不匹配而无法一起工作的两个类能够在一起工作。</p><p>​当系统的数据和行为都正确，但接口不符合时，我们应该考虑用适配器，目的时使控制范围之外的一个原有对象与某个接口匹配。适配器模式主要应用与希望复用一些现存的类，但是接口又与复用环境要求不一致的情况。<strong>适配器模式有类的适配器模式和对象的适配器模式两种形式。</strong>但由于类适配器模式通过多重继承对一个接口与另一个接口进行匹配，<strong>而C#不支持多重继承，所以主要是对象适配器</strong>。</p><h4 id="③-实现-6"><a href="#③-实现-6" class="headerlink" title="③ 实现"></a>③ 实现</h4><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><blockquote><p>Target (这是客户所期待的接口。目标可以是具体的或抽象的的类，也可以是接口)</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">Target</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Request</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;普通请求！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Adpatee(需要适配的类)代码如下：</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">Adaptee</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SpecificRequest</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;特殊请求！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Adapter(通过在内部包装一个Adaptee对象，把源接口转换成目标接口)</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span>:<span class="hljs-title">Target</span><br>&#123;<br>    <span class="hljs-comment">//建立一个私有的Adaptee对象</span><br>    <span class="hljs-keyword">private</span> Adaptee adaptee=<span class="hljs-keyword">new</span> Adaptee();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Request</span>()</span><br>    &#123;<br>        <span class="hljs-comment">//这样就可以把表面上调用Request()方法编程实际调用SpecificRequest()</span><br>        adaptee.SpecificRequest();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>客户端代码</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&#123;<br>    Target target=<span class="hljs-keyword">new</span> Adapter();<br>    <span class="hljs-comment">//对客户端来说，调用的就是Target的Request()</span><br>    target.Requset();<br>    Console.Read();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="④-适配器模式的-NET应用"><a href="#④-适配器模式的-NET应用" class="headerlink" title="④ 适配器模式的.NET应用"></a>④ 适配器模式的.NET应用</h4><p>​在.NET中有一个类库已经实现了适配器，那就是<strong>DataAdapter</strong>。<strong>DataAdapter用作DataSet和数据源之间的适配器以便检索和保存数据。DataAdapter通过映射Fill（者更改了DataSet中数据以便与数据源中的数据相匹配）和Updata（这更改了数据源中的数据以便于DataSet中的数据相匹配）来提供这一适配器</strong></p><h4 id="⑤-优点和缺点-1"><a href="#⑤-优点和缺点-1" class="headerlink" title="⑤ 优点和缺点"></a>⑤ 优点和缺点</h4><p><strong>类的适配器模式：</strong></p><p><strong>优点：</strong></p><ul><li>可以在不修改原有代码的基础上来复用现有类，很好地符合 “开闭原则”</li><li>可以重新定义Adaptee(被适配的类)的部分行为，因为在类适配器模式中，Adapter是Adaptee的子类</li><li>仅仅引入一个对象，并不需要额外的字段来引用Adaptee实例（这个即是优点也是缺点）。</li></ul><p><strong>缺点：</strong></p><ul><li>用一个具体的Adapter类对Adaptee和Target进行匹配，当如果想要匹配一个类以及所有它的子类时，类的适配器模式就不能胜任了。因为类的适配器模式中没有引入Adaptee的实例，光调用this.SpecificRequest方法并不能去调用它对应子类的SpecificRequest方法。</li><li>采用了 “多继承”的实现方式，带来了不良的高耦合。</li></ul><p><strong>对象的适配器模式</strong></p><p><strong>优点：</strong></p><ul><li>可以在不修改原有代码的基础上来复用现有类，很好地符合 “开闭原则”（这点是两种实现方式都具有的）</li><li>采用 “对象组合”的方式，更符合松耦合。</li></ul><p>缺点：</p><ul><li>使得重定义Adaptee的行为较困难，这就需要生成Adaptee的子类并且使得Adapter引用这个子类而不是引用Adaptee本身。</li></ul><h4 id="6、总结"><a href="#6、总结" class="headerlink" title="6、总结"></a>6、总结</h4><p><strong>适配器模式（Adapter）</strong>，将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不能兼容而不能一起工作的那些类可以一起工作</p><hr><h3 id="2、桥接模式"><a href="#2、桥接模式" class="headerlink" title="2、桥接模式"></a>2、桥接模式</h3><h4 id="①-桥接设计模式介绍"><a href="#①-桥接设计模式介绍" class="headerlink" title="① 桥接设计模式介绍"></a>① 桥接设计模式介绍</h4><p>​桥接模式即将抽象部分与实现部分脱耦，使它们可以独立变化。桥接模式的目的就是使两者分离，根据面向对象的封装变化的原则，我们可以把实现部分的变化封装到另外一个类中，这样的一个思路也就是桥接模式的实现，我们可以对照桥接模式的实现代码来解决我们的分析思路。</p><h4 id="②-合成-x2F-聚合复用原则"><a href="#②-合成-x2F-聚合复用原则" class="headerlink" title="② 合成&#x2F;聚合复用原则"></a>② 合成&#x2F;聚合复用原则</h4><p>​<strong>合成&#x2F;聚合复用原则（CARP）</strong>尽量使用合成&#x2F;聚合，尽量不要使用类继承。</p><p>​<strong>聚合</strong>表示一种<strong>弱’拥有‘</strong>关系，<strong>体现的是A对象可以包含B对象，但B对象不是A对象的一部分</strong>；<strong>合成</strong>则是一种<strong>强的’拥有‘</strong>关系，<strong>体现了严格部分和整体关系，部分和整体的生命周期一样</strong>。</p><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%90%88%E6%88%90%E8%81%9A%E5%90%88.png"></p><p>​<font color="FF000"><b>好处：</b></font>font优先使用对象的合成&#x2F;聚合将有助于保持每个类被封装，并被集中在单个任务上。这样类和类继承层次回保持较小规模，并且不太可能增长为不可控制的庞然大物。</p><h4 id="③-实现-7"><a href="#③-实现-7" class="headerlink" title="③ 实现"></a>③ 实现</h4><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><blockquote><p>Implementor实现者类 </p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Implementor</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ConcreteImplementorA和ConcreteImplementorB等派生</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteImplementorA</span> : <span class="hljs-title">Implementor</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;具体实现A地方法执行&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteImplementorB</span> : <span class="hljs-title">Implementor</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;具体实现B地方法执行&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Abstraction类</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">Abstraction</span><br>&#123;<br>    <span class="hljs-keyword">protected</span> Implementor implementor;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetImplementor</span>(<span class="hljs-params">Implementor implementor</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.implementor=implementor<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation</span>()</span><br>    &#123;<br>        implementor.Operation();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>RefinedAbstraction类</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">RefinedAbstraction</span> : <span class="hljs-title">Abstraction</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation</span>()</span><br>    &#123;<br>        implementor.Operation();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>客户端实现</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&#123;<br>    Abstraction ab = <span class="hljs-keyword">new</span> RefinedAbstraction();<br>    <br>    ab.SetImplementor(<span class="hljs-keyword">new</span> ConcreteImplementorA());<br>    ab.Operation();<br>    <br>    ab.SetImplementor(<span class="hljs-keyword">new</span> ConcreteImplementorB());<br>    ab.Operation();<br>    <br>    Console.Read();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="④-优点和缺点"><a href="#④-优点和缺点" class="headerlink" title="④ 优点和缺点"></a>④ 优点和缺点</h4><p><strong>优点：</strong></p><p>把抽象接口与其实现解耦。</p><p>抽象和实现可以独立扩展，不会影响到对方。</p><p>实现细节对客户透明，对用于隐藏了具体实现细节。</p><p><strong>缺点：</strong> 增加了系统的复杂度</p><h4 id="⑤-总结-2"><a href="#⑤-总结-2" class="headerlink" title="⑤ 总结"></a>⑤ 总结</h4><p><strong>桥接模式（Bridge）</strong>，将抽象部分与它的实现部分分离，使它们都可以独立地变化。</p><hr><h3 id="3、装饰者模式"><a href="#3、装饰者模式" class="headerlink" title="3、装饰者模式"></a>3、装饰者模式</h3><h4 id="①-引言-7"><a href="#①-引言-7" class="headerlink" title="① 引言"></a>① 引言</h4><p>​在软件开发中，我们经常想要对一类对象添加不同的功能，例如要给手机添加贴膜，手机挂件，手机外壳等，如果此时利用继承来实现的话，就需要定义无数的类，如StickerPhone（贴膜是手机类）、AccessoriesPhone（挂件手机类）等，这样就会导致 ”子类爆炸“问题，为了解决这个问题，我们可以使用<strong>装饰者模式来动态地给一个对象添加额外的职责</strong>。</p><h4 id="②-装饰者设计模式介绍"><a href="#②-装饰者设计模式介绍" class="headerlink" title="② 装饰者设计模式介绍"></a>② 装饰者设计模式介绍</h4><p>​装饰者模式以对客户透明的方式动态地给一个对象附加上更多的责任，装饰者模式相比生成子类可以更灵活地增加功能。每个装饰的对象的实现就和如何使用这个对象分离开了，每个装饰对象只关心自己的功能，不需要关心如何被添加到对象链当中。</p><h4 id="③-实现-8"><a href="#③-实现-8" class="headerlink" title="③ 实现"></a>③ 实现</h4><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E8%80%85%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><blockquote><p>Component类</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Component</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ConcreteComponent类</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteComponent</span> : <span class="hljs-title">Component</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;具体对象的操作&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Decorator类</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Decorator</span> : <span class="hljs-title">Component</span><br>&#123;<br>    <span class="hljs-keyword">protected</span> Component component;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetComponent</span>(<span class="hljs-params">Component component</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.component=component<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(component != <span class="hljs-literal">null</span>)<br>        &#123;<br>            component.Operation();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ConcreteDecoratorA类</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteDecoratorA</span> :<span class="hljs-title">Decorator</span><br>&#123;<br>    <span class="hljs-comment">//本类独有的功能，以区别于ConcreteDecoratorB</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> addedState;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation</span>()</span><br>    &#123;<br>        <span class="hljs-comment">//首先运行原Component 的 Operation（），再执行本类的功能，如addedState，相当于对原Component进行了装饰</span><br>        <span class="hljs-keyword">base</span>.Operation();<br>        addedState=<span class="hljs-string">&quot;New State&quot;</span>;<br>        Console.WriteLine(<span class="hljs-string">&quot;具体装饰对象A的操作&quot;</span>)；<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteDecoratorB</span> :<span class="hljs-title">Decorator</span><br>&#123;<br>    <span class="hljs-comment">//本类独有的功能，以区别于ConcreteDecoratorB</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddedBehavior</span>()</span><br>    &#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation</span>()</span><br>    &#123;<br>        <span class="hljs-comment">//首先运行原Component 的 Operation（），再执行本类的功能，如AddedBehavior，相当于对原Component进行了装饰</span><br>        <span class="hljs-keyword">base</span>.Operation();<br>        AddedBehavior();<br>        Console.WriteLine(<span class="hljs-string">&quot;具体装饰对象B的操作&quot;</span>)；<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>客户端代码</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&#123;<br>    ConcreteComponent c = <span class="hljs-keyword">new</span> ConcreteComponent();<br>    ConcreteDecoratorA d1 = <span class="hljs-keyword">new</span> ConcreteDecoratorA();<br>    ConcreteDecoratorB d2 = <span class="hljs-keyword">new</span> ConcreteDecoratorB();<br>    <br>    d1.SetComponent(c);<br>    d2.SetComponent(d1);<br>    d2.Operation();<br>    <br>    Console.Read();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="④-优点和缺点-1"><a href="#④-优点和缺点-1" class="headerlink" title="④ 优点和缺点"></a>④ 优点和缺点</h4><p><strong>优点</strong>：</p><ol><li>装饰这模式和继承的目的都是扩展对象的功能，但装饰者模式比继承更灵活</li><li>通过使用不同的具体装饰类以及这些类的排列组合，设计师可以创造出很多不同行为的组合</li><li>装饰者模式有很好地可扩展性</li></ol><p><strong>缺点</strong>：装饰者模式会导致设计中出现许多小对象，如果过度使用，会让程序变的更复杂。并且更多的对象会是的差错变得困难，特别是这些对象看上去都很像。</p><h4 id="⑤-总结-3"><a href="#⑤-总结-3" class="headerlink" title="⑤ 总结"></a>⑤ 总结</h4><p><strong>装饰模式（Decorator）</strong>，动态地给一个对象添加一些额外地职责，就增加功能来说，装饰者模式比生成子类更加灵活。</p><hr><h3 id="4、组合模式"><a href="#4、组合模式" class="headerlink" title="4、组合模式"></a>4、组合模式</h3><h4 id="①-引言-8"><a href="#①-引言-8" class="headerlink" title="① 引言"></a>① 引言</h4><p>​在软件开发过程中，我们经常会遇到处理简单对象和复合对象的情况，例如对操作系统中目录的处理就是这样的一个例子，因为目录可以包括单独的文件，也可以包括文件夹，文件夹又是由文件组成的，由于简单对象和复合对象在功能上区别，导致在操作过程中必须区分简单对象和复合对象，这样就会导致客户调用带来不必要的麻烦，然而作为客户，它们希望能够始终一致地对待简单对象和复合对象。然而组合模式就是解决这样的问题。</p><h4 id="②-组合设计模式介绍"><a href="#②-组合设计模式介绍" class="headerlink" title="② 组合设计模式介绍"></a>② 组合设计模式介绍</h4><p>​组合模式允许你将对象组合成树形结构来表现”部分-整体“的层次结构，使得客户以一致的方式处理单个对象以及对象的组合。</p><p>​当发现<strong>需求中体现部分与整体层次的结构</strong>时，以及你<strong>希望用户可以忽略组合对象与单个对象的不同，统一地使用组合结构中地所有对象时，就应该考虑组合模式</strong>。</p><h4 id="③-实现-9"><a href="#③-实现-9" class="headerlink" title="③ 实现"></a>③ 实现</h4><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><blockquote><p>Component为组合中的对象声明接口，再适当情况下，实现所有类共有接口的默认行为。声明一个接口用于访问和管理Component的子部件</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Component</span><br>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-built_in">string</span> name;<br>    <br>    publicComponent(<span class="hljs-built_in">string</span> name)<br>    &#123;<br>        <span class="hljs-keyword">this</span>.name=name;<br>    &#125;<br>    <span class="hljs-comment">//通常都用Add和Remove方法来提高增加或溢出树叶或树枝的功能</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Add</span>(<span class="hljs-params">Component c</span>)</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Remove</span>(<span class="hljs-params">Componnent c</span>)</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Display</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> depth</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Leaf再组合中表示叶结点对象，叶节点没有子结点</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">Leaf</span> : <span class="hljs-title">Componnent</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Leaf</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>):<span class="hljs-title">base</span>(<span class="hljs-params">name</span>)</span>&#123;&#125;<br>    <br>    <span class="hljs-comment">//由于叶子没有再增加分支和树叶，所以Add和Remove方法实现它没有意义，但这样做可以消除叶节点和枝结点对象再抽象层次的区别，它们具备完全一致的接口</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Add</span>(<span class="hljs-params">Component c</span>)</span><br>    &#123;<br>        Console.writeLine(<span class="hljs-string">&quot;Cannot add to a leaf&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Remove</span>(<span class="hljs-params">Componnent c</span>)</span><br>    &#123;<br>        Console.writeLine(<span class="hljs-string">&quot;Cannot remove to a leaf&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//叶节点的具体方法，此处是显示其名称和级别</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Display</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> depth</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-keyword">new</span> String(<span class="hljs-string">&#x27;-&#x27;</span>,depth)+name);<br>    &#125;<br><br>    <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Composite 定义又枝节点行为，用来存储子部件，再Component接口中实现于子部件有关的操作，比如增加Add和删除Remove。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">Composite</span>:<span class="hljs-title">Component</span><br>&#123;<br>    <span class="hljs-comment">//一个子对象集合用来存储其下属的枝节点和叶节点</span><br>    <span class="hljs-keyword">private</span> List&lt;Component&gt;children = <span class="hljs-keyword">new</span> Lsit&lt;Component&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Composite</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>):<span class="hljs-title">base</span>(<span class="hljs-params">name</span>)</span><br>    &#123;<br>        <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Add</span>(<span class="hljs-params">Component c</span>)</span><br>    &#123;<br>        children.Add(c);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Remove</span>(<span class="hljs-params">Component c</span>)</span><br>    &#123;<br>        children.<span class="hljs-keyword">remove</span>(c);<br>    &#125;<br>    <br>    <span class="hljs-comment">//显示其枝节点名称，并对其下级进行遍历</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Display</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> depth</span>)</span><br>    &#123;<br>        Console.writeLine(<span class="hljs-keyword">new</span> String(<span class="hljs-string">&#x27;-&#x27;</span>,depth)+name);<br>        <span class="hljs-keyword">foreach</span>(Component component <span class="hljs-keyword">in</span> children )<br>        &#123;<br>            component.Display(depth+<span class="hljs-number">2</span>);<br>        &#125;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>客户端代码</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&#123;<br>    <span class="hljs-comment">//生成树根root，根上长出两叶LeafA和LeafB</span><br>    Composite root = <span class="hljs-keyword">new</span> Composite(<span class="hljs-string">&quot;root&quot;</span>);<br>    root.Add(<span class="hljs-keyword">new</span> Leaf(<span class="hljs-string">&quot;Leaf A&quot;</span>));<br>    root.Add(<span class="hljs-keyword">new</span> Leaf(<span class="hljs-string">&quot;Leaf B&quot;</span>));<br>    <br>    <span class="hljs-comment">//根上长出分值Composite X，分支上也有两叶LeafXA和LeafXB</span><br>    Composite comp = <span class="hljs-keyword">new</span> Composite(<span class="hljs-string">&quot;Composite X&quot;</span>);<br>    comp.Add(<span class="hljs-keyword">new</span> Leaf(<span class="hljs-string">&quot;Leaf XA&quot;</span>));<br>    comp.Add(<span class="hljs-keyword">new</span> Leaf(<span class="hljs-string">&quot;Leaf XB&quot;</span>));<br>    <br>    root.Add(comp);<br>    <br>    <span class="hljs-comment">//在Composite X上再长出分枝CompositeXY，分枝上也有两叶LeafXYA和LeafXYB</span><br>    Composite comp2=<span class="hljs-keyword">new</span> Composite(<span class="hljs-string">&quot;Composite XY&quot;</span>);<br>    comp2.Add(<span class="hljs-keyword">new</span> Leaf(<span class="hljs-string">&quot;Leaf XYA&quot;</span>));<br>    comp2.Add(<span class="hljs-keyword">new</span> Leaf(<span class="hljs-string">&quot;Leaf XYB&quot;</span>));<br>    <br>    comp.Add(comp2);<br>    <span class="hljs-comment">//根部又掌出两叶 C和D，可惜D没长牢，被风吹走了</span><br>    root.Add(<span class="hljs-keyword">new</span> Leaf(<span class="hljs-string">&quot;Leaf C&quot;</span>));<br>    <br>    Leaf leaf=newLeaf(<span class="hljs-string">&quot;Leaf D&quot;</span>);<br>    root.Add(leaf);<br>    root.Remove(leaf);<br>    <br>    <span class="hljs-comment">//显示大树的样子</span><br>    root.Display(<span class="hljs-number">1</span>);<br>    <br>    Console.Read();            <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="④-优点和缺点-2"><a href="#④-优点和缺点-2" class="headerlink" title="④ 优点和缺点"></a>④ 优点和缺点</h4><p><strong>优点：</strong></p><ol><li>组合模式使得客户端代码可以一致地处理对象和对象容器，无需关系处理的单个对象，还是组合的对象容器。</li><li>将”客户代码与复杂的对象容器结构“解耦。</li><li>可以更容易地往组合对象中加入新的构件。</li></ol><p><strong>缺点：</strong>使得设计更加复杂。客户端需要花更多时间理清类之间的层次关系。（这个是几乎所有设计模式所面临的问题）。</p><h4 id="⑤-总结-4"><a href="#⑤-总结-4" class="headerlink" title="⑤ 总结"></a>⑤ 总结</h4><p><strong>组合模式（Composite）</strong>，将对象组合成树形结构以表示‘部分-整体’的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p><hr><h3 id="5、外观模式"><a href="#5、外观模式" class="headerlink" title="5、外观模式"></a>5、外观模式</h3><h4 id="①-引言-9"><a href="#①-引言-9" class="headerlink" title="① 引言"></a>① 引言</h4><p>​在软件开发过程中，客户端程序经常会与复杂系统的内部子系统进行耦合，从而导致客户端程序随着子系统的变化而变化，然而为了将复杂系统的内部子系统与客户端之间的依赖解耦，从而就有了外观模式，也称作 ”门面“模式。</p><h4 id="②-外观设计模式介绍"><a href="#②-外观设计模式介绍" class="headerlink" title="② 外观设计模式介绍"></a>② 外观设计模式介绍</h4><p>​外观模式提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。使用外观模式时，我们创建了一个统一的类，用来包装子系统中一个或多个复杂的类，客户端可以直接通过外观类来调用内部子系统中方法，从而外观模式让客户和子系统之间避免了紧耦合。</p><h4 id="③-实现-10"><a href="#③-实现-10" class="headerlink" title="③ 实现"></a>③ 实现</h4><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><blockquote><p>四个子系统的类</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">SubSystemOne</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodOne</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;子系统方法一&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">SubsystemTwo</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MethodTwo</span>()</span><br>    &#123;<br>        Console,WriteLine(<span class="hljs-string">&quot;子系统方法二&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">SubsystemThree</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MethodThree</span>()</span><br>    &#123;<br>        Console,WriteLine(<span class="hljs-string">&quot;子系统方法三&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">SubsystemFour</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MethodFour</span>()</span><br>    &#123;<br>        Console,WriteLine(<span class="hljs-string">&quot;子系统方法四&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>外观类</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C#">SubsystemOne one;<br>SubsystemTwo two;<br>SubsystemThree three;<br>SubsystemFour four;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Facade</span>()</span><br>&#123;<br>    one = <span class="hljs-keyword">new</span> SubsystemOne();<br>tow = SubsystemTwo();<br>three = SubsystemThree();<br>four = SubsystemFour();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MethodA</span>()</span><br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;\n方法组A（）----&quot;</span>);<br>    one.MethodOne();<br>tow.MethodTwo();<br>four.MethodFour();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MethodB</span>()</span><br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;\n方法组B（）----&quot;</span>);<br>tow.MethodTwo();<br>three.MethodThree();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>客户端调用</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&#123;<br>    Facade facade=<span class="hljs-keyword">new</span> Facade();<br>    facade.MethodA();<br>    facade.MethodB();<br>    <br>    Console.Read();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="④-优点和缺点-3"><a href="#④-优点和缺点-3" class="headerlink" title="④ 优点和缺点"></a>④ 优点和缺点</h4><p><strong>优点：</strong></p><ol><li>外观模式对客户屏蔽了子系统组件，从而简化了接口，减少了客户处理的对象数目并使子系统的使用更加简单。</li><li>外观模式实现了子系统与客户之间的松耦合关系，而子系统内部的功能组件是紧耦合的。松耦合使得子系统的组件变化不会影响到它的客户。</li></ol><p><strong>缺点：</strong></p><ol><li>如果增加新的子系统可能需要修改外观类或客户端的源代码，这样就违背了”开——闭原则“（不过这点也是不可避免）。</li></ol><h4 id="⑤-总结-5"><a href="#⑤-总结-5" class="headerlink" title="⑤ 总结"></a>⑤ 总结</h4><p><strong>外观模式（Facade）</strong>，为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用</p><hr><h3 id="6、享元模式"><a href="#6、享元模式" class="headerlink" title="6、享元模式"></a>6、享元模式</h3><h4 id="①-引言-10"><a href="#①-引言-10" class="headerlink" title="① 引言"></a>① 引言</h4><p>​在软件开发过程，如果我们需要重复使用某个对象的时候，如果我们重复地使用new创建这个对象的话，这样我们在内存就需要多次地去申请内存空间了，这样可能会出现内存使用越来越多的情况，这样的问题是非常严重，然而享元模式可以解决这个问题。</p><h4 id="②-享元设计模式介绍"><a href="#②-享元设计模式介绍" class="headerlink" title="② 享元设计模式介绍"></a>② 享元设计模式介绍</h4><p>​享元模式——运用共享技术有效地支持大量细粒度的对象。享元模式可以避免大量相似类的开销，在软件开发中如果需要生成大量细粒度的类实例来表示数据，如果这些实例除了几个参数外基本上都是相同的，这时候就可以使用享元模式来大幅度减少需要实例化类的数量。如果能把这些参数（指的这些类实例不同的参数）移动类实例外面，在方法调用时将他们传递进来，这样就可以通过共享大幅度地减少单个实例的数目。（这个也是享元模式的实现要领）,然而我们把类实例外面的参数称为享元对象的外部状态，把在享元对象内部定义称为内部状态。具体享元对象的内部状态与外部状态的定义为：</p><p>​<strong>内部状态：</strong>在享元对象的内部并且不会随着环境的改变而改变的共享部分</p><p>​<strong>外部状态：</strong>随环境改变而改变的，不可以共享的状态。</p><p>​如果一个应用程序使用了大量的对象，而大量的这些对象造成了很大的存储开销时就应该考虑使用；还有就是对象的大多数状态可以外部状态，如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象，此时可以考虑使用享元模式。</p><h4 id="③-实现-11"><a href="#③-实现-11" class="headerlink" title="③ 实现"></a>③ 实现</h4><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><blockquote><p>Flyweight类，他是所有具体享元类的超类或接口，通过这个接口，Flyweight可以接受并作用于外部状态</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Flyweight</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> extrinsicstate</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ConcreteFlyweight 时继承 Flyweight 超类或实现Flyweight接口，并为内部状态增加存储空间。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteFlyweight</span> : <span class="hljs-title">Flyweight</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> extrinsicstate</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;具体Flyweight：&quot;</span>+extrinsicstate);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>UnsharedConcreteFlyweight 是指那些不需要共享的Flyweight子类。因为Flyweight接口共享成为可能，但它并不强制共享</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">UnsharedConcreteFlyweight</span> : <span class="hljs-title">Flyweight</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> extrinsicstate</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;不共享的具体Flyweight：&quot;</span>+extrinsicstate);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>FlyweightFactory,是一个享元工厂，用来创建并管理Flyweight对象。它主要是用来确保合理地共享Flyweight，当用户请求一个Flyweight时，FlyweightFactory对象提供一个已创建的实例或者创建一个（如果不存在的话）。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">FlyweightFactory</span><br>&#123;<br>    <span class="hljs-keyword">private</span> Hashtable flyweight = <span class="hljs-keyword">new</span> Hashtable();<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FlyweightFactory</span>()</span><br>    &#123;<br>        flyweights.Add(<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-keyword">new</span> ConcreteFlyweight());<br>        flyweights.Add(<span class="hljs-string">&quot;Y&quot;</span>,<span class="hljs-keyword">new</span> ConcreteFlyweight());<br>        flyweights.Add(<span class="hljs-string">&quot;Z&quot;</span>,<span class="hljs-keyword">new</span> ConcreteFlyweight());<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Flyweight <span class="hljs-title">GetFlyweight</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> key</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> ((Flyweight)flyweights[Key]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>客户端代码</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&#123;<br>    <span class="hljs-built_in">int</span> extrinsicstate=<span class="hljs-number">22</span>;<br>    <br>    FlyweightFactory f =<span class="hljs-keyword">new</span> FlyweightFactory();<br>    <br>    Flyweight fx=f.GetFlyweight(<span class="hljs-string">&quot;X&quot;</span>);<br>    fx.Operation(--extrinsicstate);<br>    <br>    Flyweight fy=f.GetFlyweight(<span class="hljs-string">&quot;Y&quot;</span>);<br>    fy.Operation(--extrinsicstate);<br>    <br>    Flyweight fz=f.GetFlyweight(<span class="hljs-string">&quot;Y&quot;</span>);<br>    fz.Operation(--extrinsicstate);<br>    <br>    UnsharedConcreteFlyweight uf=<span class="hljs-keyword">new</span> UnsharedConcreteFlyweight();<br>    <br>    uf.Operation(--extrinsicstate);<br>    <br>    Console.Read();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="④-优点和缺点-4"><a href="#④-优点和缺点-4" class="headerlink" title="④ 优点和缺点"></a>④ 优点和缺点</h4><p><strong>优点：</strong></p><ol><li>降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力。</li></ol><p><strong>缺点：</strong></p><ol><li>为了使对象可以共享，需要将一些状态外部化，这使得程序的逻辑更复杂，使系统复杂化。</li><li>享元模式将享元对象的状态外部化，而读取外部状态使得运行时间稍微变长。</li></ol><h4 id="⑤-总结-6"><a href="#⑤-总结-6" class="headerlink" title="⑤ 总结"></a>⑤ 总结</h4><p><strong>享元模式（Flyweight）</strong>运用共享技术有效地支持大量细粒度的对象。</p><hr><h3 id="7、代理模式"><a href="#7、代理模式" class="headerlink" title="7、代理模式"></a>7、代理模式</h3><h4 id="①-引言-11"><a href="#①-引言-11" class="headerlink" title="① 引言"></a>① 引言</h4><p>​在软件开发过程中，有些对象有时候会由于网络或其他的障碍，以至于不能够或者不能直接访问到这些对象，如果直接访问对象给系统带来不必要的复杂性，这时候可以在客户端和目标对象之间增加一层中间层，让代理对象代替目标对象，然后客户端只需要访问代理对象，由代理对象去帮我们去请求目标对象并返回结果给客户端，这样的一个解决思路就是代理模式。</p><h4 id="②-代理设计模式介绍"><a href="#②-代理设计模式介绍" class="headerlink" title="② 代理设计模式介绍"></a>② 代理设计模式介绍</h4><p>代理模式按照使用目的可以分为以下几种：</p><ul><li><strong>远程（Remote）代理：</strong>为一个位于不同的地址空间的对象提供一个局域代表对象。这个不同的地址空间可以是本电脑中，也可以在另一台电脑中。最典型的例子就是——客户端调用Web服务或WCF服务。</li><li><strong>虚拟（Virtual）代理：</strong>根据需要创建一个资源消耗较大的对象，使得对象只在需要时才会被真正创建。</li><li><strong>Copy-on-Write代理：</strong>虚拟代理的一种，把复制（或者叫克隆）拖延到只有在客户端需要时，才真正采取行动。</li><li><strong>保护（Protect or Access）代理：</strong>控制一个对象的访问，可以给不同的用户提供不同级别的使用权限。</li><li><strong>防火墙（Firewall）代理：</strong>保护目标不让恶意用户接近。</li><li><strong>智能引用（Smart Reference）代理：</strong>当一个对象被引用时，提供一些额外的操作，比如将对此对象调用的次数记录下来等。</li><li><strong>Cache代理：</strong>为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以这些结果。</li></ul><p>在上面所有种类的代理模式中，虚拟代理、远程代理、智能引用代理和保护代理较为常见的代理模式。</p><p>​代理模式——就是给某一个对象提供一个代理，并由代理对象控制对原对象的引用。在一些情况下，一个客户不想或者不能直接引用一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。</p><h4 id="③-实现-12"><a href="#③-实现-12" class="headerlink" title="③ 实现"></a>③ 实现</h4><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><blockquote><p>Subject 类，定义了RealSubject 和Proxy的共用接口，这样就在任何使用RealSubject的地方都可以使用Proxy</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Subject</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Request</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>RealSubject类，定义Proxy所代表的真实实体</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">RealSubject</span>:<span class="hljs-title">Subject</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Request</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;真实的请求&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Proxy类，保存一个引用使得代理可以访问实体，并提供一个与Subject的接口相同的接口，这样代理就可以替代实体</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">Proxy</span>:<span class="hljs-title">Subject</span><br>&#123;<br>    RealSubject realSubject;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Request</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(realSubject==<span class="hljs-literal">null</span>)<br>        &#123;<br>            realSubject=<span class="hljs-keyword">new</span> Realsubject();<br>        &#125;<br>        realSubject.Request();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>客户端代码</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&#123;<br>    Proxy proxy=<span class="hljs-keyword">new</span> proxy();<br>    proxy.Request();<br>    <br>    Conosle.Read();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="④-优点和缺点-5"><a href="#④-优点和缺点-5" class="headerlink" title="④ 优点和缺点"></a>④ 优点和缺点</h4><p><strong>优点：</strong></p><ol><li>代理模式能够将调用用于真正被调用的对象隔离，在一定程度上降低了系统的耦合度；</li><li>代理对象在客户端和目标对象之间起到一个中介的作用，这样可以起到对目标对象的保护。代理对象可以在对目标对象发出请求之前进行一个额外的操作，例如权限检查等。</li></ol><p><strong>缺点：</strong></p><ol><li>由于在客户端和真实主题之间增加了一个代理对象，所以会造成请求的处理速度变慢</li><li>实现代理类也需要额外的工作，从而增加了系统的实现复杂度。</li></ol><h4 id="⑤-总结-7"><a href="#⑤-总结-7" class="headerlink" title="⑤ 总结"></a>⑤ 总结</h4><p><strong>代理模式（Proxy）</strong>，为其他对象提供一种代理以控制这个对象的访问。</p><hr><h2 id="三、行为型设计模式"><a href="#三、行为型设计模式" class="headerlink" title="三、行为型设计模式"></a>三、行为型设计模式</h2><h3 id="1、模板方法模式"><a href="#1、模板方法模式" class="headerlink" title="1、模板方法模式"></a>1、模板方法模式</h3><h4 id="①-引言-12"><a href="#①-引言-12" class="headerlink" title="① 引言"></a>① 引言</h4><p>​提到模板，肯定不免想到生活中的“简历模板”、“论文模板”、“Word中模版文件”等，在现实生活中，模板的概念就是——有一个规定的格式，然后每个人都可以根据自己的需求或情况去更新它，例如简历模板，下载下来的简历模板的格式都是相同的，然而我们下载下来简历模板之后我们可以根据自己的情况填充不同的内容要完成属于自己的简历。在设计模式中，模板方法模式中模板和生活中模板概念非常类似.</p><h4 id="②-模板方法设计模式介绍"><a href="#②-模板方法设计模式介绍" class="headerlink" title="② 模板方法设计模式介绍"></a>② 模板方法设计模式介绍</h4><p>​模板方法模式——在一个抽象类中定义一个操作中的算法骨架（对应于生活中的大家下载的模板），而将一些步骤延迟到子类中去实现（对应于我们根据自己的情况向模板填充内容）。模板方法使得子类可以不改变一个算法的结构前提下，重新定义算法的某些特定步骤，模板方法模式把不变行为搬到超类中，从而去除了子类中的重复代码。</p><h4 id="③-实现-13"><a href="#③-实现-13" class="headerlink" title="③ 实现"></a>③ 实现</h4><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><blockquote><p>AbstractClass是抽象类，其实也就是一抽象模板，定义并实现了一个模板方法。这个模板方法一般是一个具体方方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤再相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AbstractClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrimitiveOperation1</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrimitiveOperation2</span>()</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TemplateMethod</span>()</span><br>    &#123;<br>        PrimitiveOperation1();<br>        PrimitiveOperation2();<br>        Console.WriteLine(<span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ConcreteClass,实现父类所定义的一个或多个抽象方法。每一个AbstractClass 都可以由任意多个ConcreteClass 与之对应，而每一个ConcreteClass都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteClassA</span> :<span class="hljs-title">AbstractClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrimitiveOperation1</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;具体类A的方法1实现&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrimitiveOperation2</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;具体类A的方法2实现&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteClassB</span> : <span class="hljs-title">AbstractClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrimitiveOperation1</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;具体类B的方法1实现&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrimitiveOperation2</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;具体类B的方法2实现&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>客户端调用</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&#123;<br>    AbstractClass c;<br>    <br>    c=<span class="hljs-keyword">new</span> ConcreteClassA();<br>    c.TemplateMethod();<br>    <br>    c=<span class="hljs-keyword">new</span> ConcreteClassB();<br>    c.TemplateMethod();<br>    <br>    Console.Read();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="④-优点和缺点-6"><a href="#④-优点和缺点-6" class="headerlink" title="④ 优点和缺点"></a>④ 优点和缺点</h4><p><strong>优点：</strong></p><ol><li>实现了代码复用</li><li>能够灵活应对子步骤的变化，符合开放-封闭原则</li></ol><p><strong>缺点</strong>：因为引入了一个抽象类，如果具体实现过多的话，需要用户或开发人员需要花更多的时间去理清类之间的关系。</p><p> 附：在.NET中模板方法的应用也很多，例如我们在开发自定义的Web控件或WinForm控件时，我们只需要重写某个控件的部分方法。</p><h4 id="⑤-总结-8"><a href="#⑤-总结-8" class="headerlink" title="⑤ 总结"></a>⑤ 总结</h4><p><strong>模板方法模式（TemplateMethod）</strong>，定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><hr><h3 id="2、命令模式"><a href="#2、命令模式" class="headerlink" title="2、命令模式"></a>2、命令模式</h3><h4 id="①-命令设计模式介绍"><a href="#①-命令设计模式介绍" class="headerlink" title="① 命令设计模式介绍"></a>① 命令设计模式介绍</h4><p>​命令模式属于对象的行为型模式。命令模式是把一个操作或者行为抽象为一个对象中，通过对命令的抽象化来使得发出命令的责任和执行命令的责任分隔开。命令模式的实现可以提供命令的撤销和恢复功能。</p><h4 id="②-实现"><a href="#②-实现" class="headerlink" title="② 实现"></a>② 实现</h4><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><blockquote><p>Command类，用来声明执行操作的接口</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Command</span><br>&#123;<br>    <span class="hljs-keyword">protected</span> Receiver receiver;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Command</span>(<span class="hljs-params">Receiver receive</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.receive=receive<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ConcreteCommand类，将一个接收者对象绑定于一个动作，调用接收者相应的操作，以实现Execute。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteCommand</span> : <span class="hljs-title">Command</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcreteCommand</span>(<span class="hljs-params">Reciver reciver</span>):<span class="hljs-title">base</span>(<span class="hljs-params">receiver</span>)</span><br>    &#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Execute</span>()</span><br>    &#123;<br>        receiver.Action();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Invoker类，要求该命令执行这个请求</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">Invoker</span><br>&#123;<br>    <span class="hljs-keyword">private</span> Command command;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetCommand</span>(<span class="hljs-params">Command command</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.command=command;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ExecuteCommand</span>()</span><br>    &#123;<br>        command.Execute();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Receiver类，知道如何实施与执行一个与请求相关的操作，任何类都可能作为一个接收者。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">Receiver</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Action</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;执行请求！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>客户端代码，创建一个具体命令对象并设定它的接收者。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&#123;<br>    Receiver r=<span class="hljs-keyword">new</span> Receiver();<br>    Command c=<span class="hljs-keyword">new</span> ConcreteCommand(r);<br>    Invoker i=<span class="hljs-keyword">new</span> Invoker();<br>    <br>    i.SetCommand(c);<br>    i.ExecuteCommand();<br>    <br>    Console.Read();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="③-优点和缺点"><a href="#③-优点和缺点" class="headerlink" title="③ 优点和缺点"></a>③ 优点和缺点</h4><p>命令模式使得命令发出的一个和接收的一方实现低耦合。</p><p><strong>优点：</strong></p><ul><li>命令模式使得新的命令很容易被加入到系统里。</li><li>可以设计一个命令队列来实现对请求的Undo和Redo操作。</li><li>可以较容易地将命令写入日志。</li><li>可以把命令对象聚合在一起，合成为合成命令。合成命令式合成模式的应用。</li></ul><p><strong>缺点：</strong></p><ul><li>使用命令模式可能会导致系统有过多的具体命令类。这会使得命令模式在这样的系统里变得不实际。</li></ul><h4 id="④-总结-1"><a href="#④-总结-1" class="headerlink" title="④ 总结"></a>④ 总结</h4><p><strong>命令模式（Command）</strong>将一个请求封装为一个对象，从而使你可用不同的请求队客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。</p><hr><h3 id="3、迭代器模式"><a href="#3、迭代器模式" class="headerlink" title="3、迭代器模式"></a>3、迭代器模式</h3><h4 id="①-引言-13"><a href="#①-引言-13" class="headerlink" title="① 引言"></a>① 引言</h4><p>​迭代器是针对集合对象而生的，对于集合对象而言，必然涉及到集合元素的添加删除操作，同时也肯定支持遍历集合元素的操作，我们此时可以把遍历操作也放在集合对象中，但这样的话，集合对象就承担太多的责任了，面向对象设计原则中有一条是单一职责原则，所以我们要尽可能地分离这些职责，用不同的类去承担不同的职责。迭代器模式就是用迭代器类来承担遍历集合元素的职责。</p><h4 id="②-迭代器设计模式介绍"><a href="#②-迭代器设计模式介绍" class="headerlink" title="② 迭代器设计模式介绍"></a>② 迭代器设计模式介绍</h4><p>​迭代器模式提供了一种方法顺序访问一个聚合对象（理解为集合对象）中各个元素，而又无需暴露该对象的内部表示，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。</p><h4 id="③-实现-14"><a href="#③-实现-14" class="headerlink" title="③ 实现"></a>③ 实现</h4><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><blockquote><p>Iterator迭代器抽象类</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Iterator</span><br>&#123;<br>    <span class="hljs-comment">//用于定义得到开始对象、得到下一个对象、判断是否到结尾、当前对象等抽象方法、统一接口</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-built_in">object</span> <span class="hljs-title">First</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-built_in">object</span> <span class="hljs-title">Next</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">IsDone</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-built_in">object</span> <span class="hljs-title">CurrentItem</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Aggregate 聚集抽象类</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Aggregate</span><br>&#123;<br>    <span class="hljs-comment">//创建迭代器</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Iterator <span class="hljs-title">CreateIterator</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ConcreteIterator具体迭代器类，继承Iterator</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteIterator</span>:<span class="hljs-title">Iterator</span><br>&#123;<br>    <span class="hljs-comment">//定义了一个具体聚集对象</span><br>    <span class="hljs-keyword">private</span> ConcreteAggregate aggregate;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> current = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">//初始化时具体的聚集对象传入</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcreteIterator</span>(<span class="hljs-params">ConcreteAggregate aggregate</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.aggregate=aggregate;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">object</span> <span class="hljs-title">First</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> aggregate[<span class="hljs-number">0</span>]<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">object</span> <span class="hljs-title">Next</span>()</span><br>    &#123;<br>        <span class="hljs-built_in">object</span> ret =<span class="hljs-literal">null</span>;<br>        current++;<br>        <span class="hljs-keyword">if</span>(current&lt;aggregate.Count)<br>        &#123;<br>            ret=aggregate[current];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">IsDone</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> current &gt;= aggregate.Count?<span class="hljs-literal">true</span>:<span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">object</span> <span class="hljs-title">CurrentItem</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> aggregate[current];<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ConcreteAggregate具体聚集类 继承 Aggregate</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteAggregate</span> : <span class="hljs-title">Aggregate</span><br>&#123;<br>    <span class="hljs-keyword">private</span> IList&lt;<span class="hljs-built_in">object</span>&gt; items=<span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">object</span>&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> Iterator <span class="hljs-title">CreateIterator</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConcreteIterator(<span class="hljs-keyword">this</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Count<br>    &#123;<br>        <span class="hljs-keyword">get</span>&#123;<span class="hljs-keyword">return</span> items.Count;&#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">object</span> <span class="hljs-keyword">this</span>[<span class="hljs-built_in">int</span> index]<br>    &#123;<br>        <span class="hljs-keyword">get</span>&#123;<span class="hljs-keyword">return</span> items[index];&#125;<br>        <span class="hljs-keyword">set</span>&#123;items.Insert(index,<span class="hljs-keyword">value</span>);&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>客户端代码</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C#">ConcreteAggregate a=<span class="hljs-keyword">new</span> ConcreteAggregate();<br><br>a[<span class="hljs-number">0</span>]=<span class="hljs-string">&quot;0&quot;</span>;<br>a[<span class="hljs-number">1</span>]=<span class="hljs-string">&quot;1&quot;</span>;<br>a[<span class="hljs-number">2</span>]=<span class="hljs-string">&quot;2&quot;</span>;<br>a[<span class="hljs-number">3</span>]=<span class="hljs-string">&quot;3&quot;</span>;<br>a[<span class="hljs-number">4</span>]=<span class="hljs-string">&quot;4&quot;</span>;<br>a[<span class="hljs-number">5</span>]=<span class="hljs-string">&quot;5&quot;</span>;<br><br>Iterator i=<span class="hljs-keyword">new</span> ConcreteIterator(a);<br><span class="hljs-built_in">object</span> item=i.First();<br><span class="hljs-keyword">while</span>(!i.IsDone())<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;&#123;0&#125; 请买车票&quot;</span>,i.CuurentItem());<br>    <br>    Console.Read();<br>        <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="④-Net的迭代器实现"><a href="#④-Net的迭代器实现" class="headerlink" title="④ .Net的迭代器实现"></a>④ .Net的迭代器实现</h4><blockquote><p>IEumerator 支持对非泛型集合的简单迭代器接口</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IEumerator</span><br>&#123;<br>    <span class="hljs-built_in">object</span> Current<br>    &#123;<br>        <span class="hljs-keyword">get</span>;<br>    &#125;<br>    <span class="hljs-comment">//将枚举数推进到集合的下一个元素。</span><br>    <span class="hljs-comment">//true表示成功</span><br>    <span class="hljs-comment">//false表示位于集合末尾</span><br>    <span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">MoveNext</span>()</span>;<br>   <br>    <span class="hljs-comment">//恢复初始化指向的位置，该位置位于集合中第一个元素之前</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Reset</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>IEumerable 公开枚举数，该枚举数支持在非泛型集合上进行简单迭代</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IEnumerable</span><br>&#123;<br>    <span class="hljs-comment">//返回一个循环访问集合的枚举数</span><br>    <span class="hljs-function">IEumerator <span class="hljs-title">GetEnumerator</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>foreach应用</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C#">IList&lt;<span class="hljs-built_in">string</span>&gt; a=<span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">string</span>&gt;();<br><span class="hljs-keyword">foreach</span>(<span class="hljs-built_in">string</span> item <span class="hljs-keyword">in</span> a)<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>编译器里foreach实际上运用</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C#">IEnumerator&lt;<span class="hljs-built_in">string</span>&gt; e=a.GetEnumerator();<br><br><span class="hljs-keyword">while</span>(e.MoveNext())<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="⑤-优点和缺点-2"><a href="#⑤-优点和缺点-2" class="headerlink" title="⑤ 优点和缺点"></a>⑤ 优点和缺点</h4><p>​<strong>优点：</strong></p><ul><li>迭代器模式使得访问一个聚合对象的内容而无需暴露它的内部表示，即迭代抽象。</li><li>迭代器模式为遍历不同的集合结构提供了一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作</li></ul><p>　<strong>缺点：</strong></p><ul><li>迭代器模式在遍历的同时更改迭代器所在的集合结构会导致出现异常。所以使用foreach语句只能在对集合进行遍历，不能在遍历的同时更改集合中的元素。</li></ul><h4 id="⑥-总结-2"><a href="#⑥-总结-2" class="headerlink" title="⑥ 总结"></a>⑥ 总结</h4><p><strong>迭代器模式(Iterator)</strong>,提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。</p><hr><h3 id="4、观察者模式"><a href="#4、观察者模式" class="headerlink" title="4、观察者模式"></a>4、观察者模式</h3><h4 id="①-引言-14"><a href="#①-引言-14" class="headerlink" title="① 引言"></a>① 引言</h4><p>​在现实生活中，处处可见观察者模式，例如，微信中的订阅号，订阅博客和QQ微博中关注好友，这些都属于观察者模式的应用。</p><h4 id="②-观察者设计模式介绍"><a href="#②-观察者设计模式介绍" class="headerlink" title="② 观察者设计模式介绍"></a>② 观察者设计模式介绍</h4><p>​从生活中的例子可以看出，只要对订阅号进行关注的客户端，如果订阅号有什么更新，就会直接推送给订阅了的用户。从中，我们就可以得出观察者模式的定义。</p><p>　　观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象，这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己的行为。</p><h4 id="③-实现-15"><a href="#③-实现-15" class="headerlink" title="③ 实现"></a>③ 实现</h4><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E7%BB%93%E6%9E%84%E5%9B%BE.jpg"></p><blockquote><p>Subject类，可以翻译为主题或者抽象通知者，一般用一个抽象类或者一个接口实现。它把所有对观察者对象的引用保存在一个聚集里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Subject</span><br>&#123;<br>    <span class="hljs-keyword">private</span> IList&lt;Observer&gt; observers=<span class="hljs-keyword">new</span> List&lt;Observer&gt;();<br>    <span class="hljs-comment">//增加观察者</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Attach</span>(<span class="hljs-params">Observer observer</span>)</span><br>    &#123;<br>        observer.Add(observer);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Detach</span>(<span class="hljs-params">Observer observer</span>)</span><br>    &#123;<br>        observer.Remove(observer);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Notify</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">foreach</span>(Observer o <span class="hljs-keyword">in</span> observer)<br>        &#123;<br>            o.Update();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>Observer类，抽象观察者，为所有的具体观察者定义一个接口，在得到主题的通知时更新自己。这个接口叫做更新接口。抽象观察者一般用一个抽象类或者一个接口实现。更新接口通常包含一个Update（）方法，这个方法叫做更新方法。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Observer</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ConvreteSubject类，叫做具体主题或者具体通知者，将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色通常用一个具体子类实现。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteSubject</span> :　<span class="hljs-title">Subject</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> subjectState;<br>    <span class="hljs-comment">//具体观察者状态</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> SubjectState<br>    &#123;<br>        <span class="hljs-keyword">get</span>;<br>        <span class="hljs-keyword">set</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ConvreteObserver类，具体观察者，实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。具体观察者角色可以保存一个指向具体主题对象的引用。具体观察者角色通常用一给具体子类实现</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">ConvreteObserver</span> : <span class="hljs-title">Observer</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> observerState;<br>    <span class="hljs-keyword">private</span> ConcreteSubject subject;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcreteObsercer</span>(<span class="hljs-params">ConvreteSubject subject,<span class="hljs-built_in">string</span> name</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.subject=subject;<br>        <span class="hljs-keyword">this</span>.name=name;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span><br>    &#123;<br>        obseverState=subject.SubjectState;<br>        Console.WriteLine(<span class="hljs-string">&quot;观察者&#123;0&#125;的新状态&#123;1&#125;&quot;</span>,name,observerState);<br>    &#125;<br>    <span class="hljs-keyword">public</span> ConcreteSubject Subject<br>    &#123;<br>        <span class="hljs-keyword">get</span>;<br>        <span class="hljs-keyword">set</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>客户端代码</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&#123;<br>    ConcreteSubject s= <span class="hljs-keyword">new</span> ConcreteSubject();<br>    <br>    s.Attach(<span class="hljs-keyword">new</span> ConcreteObserver(s,<span class="hljs-string">&quot;X&quot;</span>));<br>    s.Attach(<span class="hljs-keyword">new</span> ConcreteObserver(s,<span class="hljs-string">&quot;Y&quot;</span>));<br>    s.Attach(<span class="hljs-keyword">new</span> ConcreteObserver(s,<span class="hljs-string">&quot;Z&quot;</span>));<br>    <br>    s.SubjectState=<span class="hljs-string">&quot;ABC&quot;</span>;<br>    s.Notify();<br>    <br>    Console.Read();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="④-优点和缺点-7"><a href="#④-优点和缺点-7" class="headerlink" title="④ 优点和缺点"></a>④ 优点和缺点</h4><p>​<strong>优点：</strong></p><ul><li>观察者模式实现了表示层和数据逻辑层的分离，并定义了稳定的更新消息传递机制，并抽象了更新接口，使得可以有各种各样不同的表示层，即观察者。</li><li>观察者模式在被观察者和观察者之间建立了一个抽象的耦合，被观察者并不知道任何一个具体的观察者，只是保存着抽象观察者的列表，每个具体观察者都符合一个抽象观察者的接口。</li><li>观察者模式支持广播通信。被观察者会向所有的注册过的观察者发出通知。</li></ul><p>　　<strong>缺点：</strong></p><ul><li>如果一个被观察者有很多直接和间接的观察者时，将所有的观察者都通知到会花费很多时间。</li><li>虽然观察者模式可以随时使观察者知道所观察的对象发送了变化，但是观察者模式没有相应的机制使观察者知道所观察的对象是怎样发生变化的。</li><li>如果在被观察者之间有循环依赖的话，被观察者会触发它们之间进行循环调用，导致系统崩溃，在使用观察者模式应特别注意这点。</li></ul><h4 id="⑤-总结-9"><a href="#⑤-总结-9" class="headerlink" title="⑤ 总结"></a>⑤ 总结</h4><p><strong>观察者模式（Observer）</strong>定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。</p><hr><h3 id="5、中介者模式"><a href="#5、中介者模式" class="headerlink" title="5、中介者模式"></a>5、中介者模式</h3><h4 id="①-引言-15"><a href="#①-引言-15" class="headerlink" title="① 引言"></a>① 引言</h4><p>​从生活中的例子可以看出，不论是QQ游戏还是QQ群，它们都是充当一个中间平台，QQ用户可以登录这个中间平台与其他QQ用户进行交流，如果没有这些中间平台，我们如果想与朋友进行聊天的话，可能就需要当面才可以了。电话、短信也同样是一个中间平台，有了这个中间平台，每个用户都不要直接依赖与其他用户，只需要依赖这个中间平台就可以了，一切操作都由中间平台去分发。</p><h4 id="②-中介者设计模式介绍"><a href="#②-中介者设计模式介绍" class="headerlink" title="② 中介者设计模式介绍"></a>② 中介者设计模式介绍</h4><p>​中介者模式，定义了一个中介对象来封装一系列对象之间的交互关系。中介者使各个对象之间不需要显式地相互引用，从而使耦合性降低，而且可以独立地改变它们之间的交互行为。</p><h4 id="③-实现-16"><a href="#③-实现-16" class="headerlink" title="③ 实现"></a>③ 实现</h4><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><blockquote><p>Mediator类抽象中介者类</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Mediator</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Send</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message,Colleague colleague</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Colleague类抽象同事类</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Colleague</span><br>&#123;<br>    <span class="hljs-keyword">protected</span> Mediator mediator;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Colleague</span>(<span class="hljs-params">Mediator mediator</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.mediator=mediator;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ConcreteMediator类具体中介者类</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteMediator</span> : <span class="hljs-title">Mediator</span><br>&#123;<br>    <span class="hljs-keyword">private</span> ConcreteColleague1 colleague1;<br>    <span class="hljs-keyword">private</span> ConcreteColleague2 colleague2;<br>    <br>    <span class="hljs-keyword">public</span>  ConcreteColleague1 colleague1<br>    &#123;<br>        <span class="hljs-keyword">set</span>&#123;colleague1=<span class="hljs-keyword">value</span>;&#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> ConcreteColleague2 colleague2<br>    &#123;<br>        <span class="hljs-keyword">set</span>&#123;colleague2=<span class="hljs-keyword">value</span>;&#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Send</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message,Colleague colleague</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(colleague==colleague1)<br>        &#123;<br>            colleague2.Notify(message);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            colleague1.Notify(message);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ConcreteColleague1和 ConcreteColleague2等各种同事对象</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteColleague1</span> :<span class="hljs-title">Colleague</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcreteColleague1</span>(<span class="hljs-params">Mediator mediator</span>):<span class="hljs-title">base</span>(<span class="hljs-params">mediator</span>)</span><br>    &#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Send</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        mediator.Send(message,<span class="hljs-keyword">this</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Notify</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;同事1得到信息：&quot;</span>+message);<br>    &#125;<br>    <br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteColleague2</span> :<span class="hljs-title">Colleague</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcreteColleague2</span>(<span class="hljs-params">Mediator mediator</span>):<span class="hljs-title">base</span>(<span class="hljs-params">mediator</span>)</span><br>    &#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Send</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        mediator.Send(message,<span class="hljs-keyword">this</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Notify</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;同事2得到信息：&quot;</span>+message);<br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p>客户端调用</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&#123;<br>    ConcreteMediator m = <span class="hljs-keyword">new</span> ConcreteMediator();<br>    <br>    ConcreteColleague1 c1 = <span class="hljs-keyword">new</span> concreteColleague1(m);<br>    ConcreteColleague2 c2 = <span class="hljs-keyword">new</span> concreteColleague2(m);<br>    <br>    m.Colleague1 = c1;<br>    m.Colleague2 = c2;<br>    <br>    c1.Send(<span class="hljs-string">&quot;吃过饭了吗?&quot;</span>);<br>    c2.Send(<span class="hljs-string">&quot;没有呢，你打算请客？&quot;</span>);<br>    <br>    Console.Read(); <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="④-优点和缺点-8"><a href="#④-优点和缺点-8" class="headerlink" title="④ 优点和缺点"></a>④ 优点和缺点</h4><p>​<strong>优点：</strong></p><ul><li>简化了对象之间的关系，将系统的各个对象之间的相互关系进行封装，将各个同事类解耦，使得系统变为松耦合。</li><li>提供系统的灵活性，使得各个同事对象独立而易于复用。</li></ul><p>　　<strong>缺点：</strong></p><ul><li>中介者模式中，中介者角色承担了较多的责任，所以一旦这个中介者对象出现了问题，整个系统将会受到重大的影响。例如，QQ游戏中计算欢乐豆的程序出错了，这样会造成重大的影响。</li><li>新增加一个同事类时，不得不去修改抽象中介者类和具体中介者类，此时可以使用观察者模式和状态模式来解决这个问题。</li></ul><h4 id="⑤-总结-10"><a href="#⑤-总结-10" class="headerlink" title="⑤ 总结"></a>⑤ 总结</h4><p><strong>中介者模式（Mediator）</strong>，用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显示地交互引用，从而使其耦合松散，而且可以独立地改变使它们之间地交互。</p><hr><h3 id="6、状态者模式"><a href="#6、状态者模式" class="headerlink" title="6、状态者模式"></a>6、状态者模式</h3><h4 id="①-引言-16"><a href="#①-引言-16" class="headerlink" title="① 引言"></a>① 引言</h4><p>​每个对象都有其对应的状态，而每个状态又对应一些相应的行为，如果某个对象有多个状态时，那么就会对应很多的行为。那么对这些状态的判断和根据状态完成的行为，就会导致多重条件语句，并且如果添加一种新的状态时，需要更改之前现有的代码。这样的设计显然违背了开闭原则。状态模式正是用来解决这样的问题的。状态模式将每种状态对应的行为抽象出来成为单独新的对象，这样状态的变化不再依赖于对象内部的行为。</p><h4 id="②-状态者设计模式介绍"><a href="#②-状态者设计模式介绍" class="headerlink" title="② 状态者设计模式介绍"></a>② 状态者设计模式介绍</h4><p>​状态模式——允许一个对象在其内部状态改变时自动改变其行为，对象看起来就像是改变了它的类。</p><h4 id="③-实现-17"><a href="#③-实现-17" class="headerlink" title="③ 实现"></a>③ 实现</h4><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E8%80%85%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><blockquote><p>State类，抽象状态类，定义一个接口以封装与Context的一个特定状态相关的行为。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">State</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Handle</span>(<span class="hljs-params">Context context</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ConcreteState类，具体状态，每一个子类实现一个与Context 的一个状态相关的行为。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteStateA</span> : <span class="hljs-title">state</span><br>&#123;<br>    <span class="hljs-comment">//设置 ConcreteStateA 的下一状态是ConcreteStateB</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Handle</span>(<span class="hljs-params">Context context</span>)</span><br>    &#123;<br>        context.State= <span class="hljs-keyword">new</span> ConcreteStateB();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteStateB</span> : <span class="hljs-title">state</span><br>&#123;<br>    <span class="hljs-comment">//设置 ConcreteStateB 的下一状态是ConcreteStateA</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Handle</span>(<span class="hljs-params">Context context</span>)</span><br>    &#123;<br>        context.State= <span class="hljs-keyword">new</span> ConcreteStateA();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Context类，维护一个ConcreteState子类的实例，这个实例定义当前的状态。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">Context</span><br>&#123;<br>    <span class="hljs-keyword">private</span> State state;<br>    <span class="hljs-comment">//定义Context的初始状态</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Context</span>(<span class="hljs-params">State state</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.state=state;<br>    &#125;<br>    <br>     <span class="hljs-comment">//可读写的状态属性，用于读取当前状态和设置新状态</span><br>     <span class="hljs-keyword">public</span> State state<br>     &#123;<br>     <span class="hljs-keyword">get</span>&#123;<span class="hljs-keyword">return</span> state;&#125;<br>        <span class="hljs-keyword">set</span><br>        &#123;<br>        state=<span class="hljs-keyword">value</span>;<br>            Console.WriteLine(<span class="hljs-string">&quot;当前状态：&quot;</span>+state.GetType().Name);<br>        &#125;<br>     &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Request</span>()</span><br>    &#123;<br>        <span class="hljs-comment">//对请求做处理，并设置下以状态</span><br>        state.Handle(<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>客户端代码</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&#123;<br>    <span class="hljs-comment">//设置Context的初始状态为ConcreteStateA</span><br>    Context c = <span class="hljs-keyword">new</span> Context(<span class="hljs-keyword">new</span> ConcreteStateA());<br>    <br>    <span class="hljs-comment">//不断请求，同时更改状态</span><br>    c.Request();<br>    c.Request();<br>    c.Request();<br>    c.Request();<br>    <br>    Console.Read();<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="④-优点和缺点-9"><a href="#④-优点和缺点-9" class="headerlink" title="④ 优点和缺点"></a>④ 优点和缺点</h4><p>​<strong>优点：</strong></p><ul><li>将状态判断逻辑每个状态类里面，可以简化判断的逻辑。</li><li>当有新的状态出现时，可以通过添加新的状态类来进行扩展，扩展性好。</li></ul><p>​<strong>缺点：</strong></p><ul><li>如果状态过多的话，会导致有非常多的状态类，加大了开销。</li></ul><h4 id="⑤-总结-11"><a href="#⑤-总结-11" class="headerlink" title="⑤ 总结"></a>⑤ 总结</h4><p><strong>状态模式（State）</strong>，当一个对象地内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。</p><hr><h3 id="7、策略者模式"><a href="#7、策略者模式" class="headerlink" title="7、策略者模式"></a>7、策略者模式</h3><h4 id="①-引言-17"><a href="#①-引言-17" class="headerlink" title="① 引言"></a>① 引言</h4><p>​在现实生活中，策略模式的例子也非常常见，例如，中国的所得税，分为企业所得税、外商投资企业或外商企业所得税和个人所得税，针对于这3种所得税，针对每种，所计算的方式不同，个人所得税有个人所得税的计算方式，而企业所得税有其对应计算方式。如果不采用策略模式来实现这样一个需求的话，可能我们会定义一个所得税类，该类有一个属性来标识所得税的类型，并且有一个计算税收的CalculateTax()方法，在该方法体内需要对税收类型进行判断，通过if-else语句来针对不同的税收类型来计算其所得税。这样的实现确实可以解决这个场景吗，但是这样的设计不利于扩展，如果系统后期需要增加一种所得税时，此时不得不回去修改CalculateTax方法来多添加一个判断语句，这样明白违背了“开放——封闭”原则。此时，我们可以考虑使用策略模式来解决这个问题，既然税收方法是这个场景中的变化部分，此时自然可以想到对税收方法进行抽象。</p><h4 id="②-策略者设计模式介绍"><a href="#②-策略者设计模式介绍" class="headerlink" title="② 策略者设计模式介绍"></a>② 策略者设计模式介绍</h4><p>​策略模式是对算法的包装，是把使用算法的责任和算法本身分割开，委派给不同的对象负责。策略模式通常把一系列的算法包装到一系列的策略类里面。用一句话慨括策略模式就是——“将每个算法封装到不同的策略类中，使得它们可以互换”</p><h4 id="③-实现-18"><a href="#③-实现-18" class="headerlink" title="③ 实现"></a>③ 实现</h4><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><blockquote><p>Strategy类,定义所有支持的算法的公共接口</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Starategy</span><br>&#123;<br>    <span class="hljs-comment">//算法方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AlgorithmInterface</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ConcreteStrategy，封装了具体的算法或行为，继承于Strategy</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteStrategyA</span> : <span class="hljs-title">Strategy</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AlgorithmInterface</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;算法A实现&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteStrategyB</span> : <span class="hljs-title">Strategy</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AlgorithmInterface</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;算法B实现&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteStrategyC</span> : <span class="hljs-title">Strategy</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AlgorithmInterface</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;算法C实现&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Context，用一个 ConcreteStrategy来配置，维护一个对Strategy对象引用</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">Context</span><br>&#123;<br>    Strategy strategy;<br>    <span class="hljs-comment">//初始化时，传入具体的策略对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Context</span>(<span class="hljs-params">Strategy strategy</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.strategy=strategy;<br>    &#125;<br>    <span class="hljs-comment">//上下文接口</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ContextInterface</span>()</span><br>    &#123;<br>        <span class="hljs-comment">//根据具体的策略对象，调用其算法的方法</span><br>        strategy.AlgorithmInterface();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>客户端代码</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&#123;<br>    Context context;<br>    <br>    <span class="hljs-comment">//由于实例化不同的策略，所以最终在调用context.ContextInterface();时，所获得的结果就不尽相同</span><br>    context=<span class="hljs-keyword">new</span> Context(<span class="hljs-keyword">new</span> ConcreteStrategyA());<br>    context.ContextInerface();<br>    <br>    context=<span class="hljs-keyword">new</span> Context(<span class="hljs-keyword">new</span> ConcreteStrategyB());<br>    context.ContextInerface();<br>    <br>    context=<span class="hljs-keyword">new</span> Context(<span class="hljs-keyword">new</span> ConcreteStrategyC());<br>    context.ContextInerface();<br>    <br>    Console.Read();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="④-优点和缺点-10"><a href="#④-优点和缺点-10" class="headerlink" title="④ 优点和缺点"></a>④ 优点和缺点</h4><p>​<strong>优点：</strong></p><ul><li>策略类之间可以自由切换。由于策略类都实现同一个接口，所以使它们之间可以自由切换。</li><li>易于扩展。增加一个新的策略只需要添加一个具体的策略类即可，基本不需要改变原有的代码。</li><li>避免使用多重条件选择语句，充分体现面向对象设计思想。</li></ul><p>　　<strong>缺点：</strong></p><ul><li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这点可以考虑使用IOC容器和依赖注入的方式来解决，关于IOC容器和依赖注入（Dependency Inject）的文章可以参考：<a href="http://www.cnblogs.com/lusd/articles/3175062.html">IoC 容器和Dependency Injection 模式</a>。</li><li>策略模式会造成很多的策略类。</li></ul><h4 id="⑤-总结-12"><a href="#⑤-总结-12" class="headerlink" title="⑤ 总结"></a>⑤ 总结</h4><p><strong>策略模式（Strategy）</strong>：它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。</p><hr><h3 id="8、责任链模式"><a href="#8、责任链模式" class="headerlink" title="8、责任链模式"></a>8、责任链模式</h3><h4 id="①-引言-18"><a href="#①-引言-18" class="headerlink" title="① 引言"></a>① 引言</h4><p>​在现实生活中，有很多请求并不是一个人说了就算的，例如面试时的工资，低于1万的薪水可能技术经理就可以决定了，但是1万~1万5的薪水可能技术经理就没这个权利批准，可能就需要请求技术总监的批准，所以在面试的完后，经常会有面试官说，你这个薪水我这边觉得你这技术可以拿这个薪水的，但是还需要技术总监的批准等的话。这个例子也就诠释了本文要介绍的内容。生活中的这个例子真是应用了责任链模式。</p><h4 id="②-责任链设计模式介绍"><a href="#②-责任链设计模式介绍" class="headerlink" title="② 责任链设计模式介绍"></a>② 责任链设计模式介绍</h4><p>​责任链模式指的是——某个请求需要多个对象进行处理，从而避免请求的发送者和接收之间的耦合关系。将这些对象连成一条链子，并沿着这条链子传递该请求，直到有对象处理它为止。</p><h4 id="③-实现-19"><a href="#③-实现-19" class="headerlink" title="③ 实现"></a>③ 实现</h4><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%B4%A3%E4%BB%BB%E9%93%BE%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><blockquote><p>Handler类，定义一个处理请示的接口。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Handler</span><br>&#123;<br>    <span class="hljs-keyword">protected</span> Handler successor;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SetSuccessor</span>(<span class="hljs-params">Handler successor</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.successor=successor;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HandleRequest</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> request</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ConcreteHandler类，具体处理者类，处理它所负责的请求，可访问它的后继者，如果可处理该请求,就处理之，否则就将该请求转发给它的后继者。</p><p>ConcreteHandler1，当请求数在0到10之间则有权处理，否则转到下一位。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteHandler1</span> :　<span class="hljs-title">Handler</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HandleRequest</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> request</span>)</span><br>    &#123;<br>        <span class="hljs-comment">//0到10，处理此请求</span><br>        <span class="hljs-keyword">if</span>(request&gt;=<span class="hljs-number">0</span> &amp;&amp; request&lt;<span class="hljs-number">10</span>)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;&#123;0&#125;处理请求&#123;1&#125;&quot;</span>,<span class="hljs-keyword">this</span>.GetType().Name,request);<br>            <br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(successor!=<span class="hljs-literal">null</span>)<br>        &#123;<br>            <span class="hljs-comment">//转移到下一位</span><br>            successor.HandleRequest(request);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ConcreteHandler2，当请求数在10到20之间则有权处理，否则转到下一位。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteHandler2</span> :　<span class="hljs-title">Handler</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HandleRequest</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> request</span>)</span><br>    &#123;<br>        <span class="hljs-comment">//10到20，处理此请求</span><br>        <span class="hljs-keyword">if</span>(request&gt;=<span class="hljs-number">10</span> &amp;&amp; request&lt;<span class="hljs-number">20</span>)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;&#123;0&#125;处理请求&#123;1&#125;&quot;</span>,<span class="hljs-keyword">this</span>.GetType().Name,request);<br>            <br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(successor!=<span class="hljs-literal">null</span>)<br>        &#123;<br>            <span class="hljs-comment">//转移到下一位</span><br>            successor.HandleRequest(request);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ConcreteHandler3，当请求数在20到30之间则有权处理，否则转到下一位。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteHandler3</span> :　<span class="hljs-title">Handler</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HandleRequest</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> request</span>)</span><br>    &#123;<br>        <span class="hljs-comment">//20到30，处理此请求</span><br>        <span class="hljs-keyword">if</span>(request&gt;=<span class="hljs-number">20</span> &amp;&amp; request&lt;<span class="hljs-number">30</span>)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;&#123;0&#125;处理请求&#123;1&#125;&quot;</span>,<span class="hljs-keyword">this</span>.GetType().Name,request);<br>            <br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(successor!=<span class="hljs-literal">null</span>)<br>        &#123;<br>            <span class="hljs-comment">//转移到下一位</span><br>            successor.HandleRequest(request);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p> 客户端代码，向链上的具体处理者对象提交请求</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&#123;<br>    Handlder h1 = <span class="hljs-keyword">new</span> COncreteHandler1();<br>    Handlder h2 = <span class="hljs-keyword">new</span> COncreteHandler2();<br>    Handlder h3 = <span class="hljs-keyword">new</span> COncreteHandler3();<br>    <span class="hljs-comment">//设置职责链上家与下家</span><br>    h1.SetSuccessor(h2);<br>    h2.SetSuccessor(h3);<br>    <br>    <span class="hljs-built_in">int</span>[] requests=&#123;<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">14</span>,<span class="hljs-number">22</span>,<span class="hljs-number">18</span>,<span class="hljs-number">3</span>,<span class="hljs-number">27</span>,<span class="hljs-number">20</span>&#125;;<br>    <span class="hljs-comment">//循环给最小处理者提交请求，不同的数额,由不同权限处理者处理</span><br>    <span class="hljs-keyword">foreach</span>(<span class="hljs-built_in">int</span> request <span class="hljs-keyword">in</span> requests)<br>    &#123;<br>        h1.HandleRequest(request);<br>    &#125;<br>    <br>    Console.Read();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="④-优点和缺点-11"><a href="#④-优点和缺点-11" class="headerlink" title="④ 优点和缺点"></a>④ 优点和缺点</h4><p>​<strong>优点：</strong></p><ul><li>降低了请求的发送者和接收者之间的耦合。</li><li>把多个条件判定分散到各个处理类中，使得代码更加清晰，责任更加明确。</li></ul><p>​<strong>缺点：</strong></p><ul><li>在找到正确的处理对象之前，所有的条件判定都要执行一遍，当责任链过长时，可能会引起性能的问题</li><li>可能导致某个请求不被处理。</li></ul><h4 id="⑤-总结-13"><a href="#⑤-总结-13" class="headerlink" title="⑤ 总结"></a>⑤ 总结</h4><p><strong>责任链模式（Chain of Responsibility）</strong>，使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，知道有一个对象处理它为止。</p><hr><h3 id="9、访问者模式"><a href="#9、访问者模式" class="headerlink" title="9、访问者模式"></a>9、访问者模式</h3><h4 id="①-引言-19"><a href="#①-引言-19" class="headerlink" title="① 引言"></a>① 引言</h4><p>​访问者模式是封装一些施加于某种数据结构之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构则可以保存不变。访问者模式适用于数据结构相对稳定的系统， 它把数据结构和作用于数据结构之上的操作之间的耦合度降低，使得操作集合可以相对自由地改变。</p><h4 id="②-访问者设计模式介绍"><a href="#②-访问者设计模式介绍" class="headerlink" title="② 访问者设计模式介绍"></a>② 访问者设计模式介绍</h4><p>​数据结构的每一个节点都可以接受一个访问者的调用，此节点向访问者对象传入节点对象，而访问者对象则反过来执行节点对象的操作。这样的过程叫做“双重分派”。节点调用访问者，将它自己传入，访问者则将某算法针对此节点执行。</p><h4 id="③-实现-20"><a href="#③-实现-20" class="headerlink" title="③ 实现"></a>③ 实现</h4><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BF%E9%97%AE%E8%80%85%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><blockquote><p>Visitor类，为该对象结构中 ConcreteElement的每一个类声明一个 Visit操作。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">visitor</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">VisitConcreteElementA</span>(<span class="hljs-params">ConcreteElementA concreteElementA</span>)</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">VisitConcreteElementB</span>(<span class="hljs-params">ConcreteElementB concreteElementB</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ConcreteVisitor1和 ConcreteVisitor2类，具体访问者，实现每个由Visitor声明的操作。每个操作实现算法的一部分，而该算法片断乃是对应于结构中对象的类。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">Concretevisitor1</span> : <span class="hljs-title">Visitor</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">VisitConcreteElementA</span>(<span class="hljs-params">ConcreteElementA concreteElementA</span>)</span><br>    &#123;<br>        Console.writeLine(<span class="hljs-string">&quot; &#123;0&#125;被&#123;1&#125;访问&quot;</span>，concreteElementA.GetType().Name, <span class="hljs-keyword">this</span>. GetType ().Name);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">VisitConcreteElementB</span>(<span class="hljs-params">ConcreteElementB concreteElementB</span>)</span><br>    &#123;<br>        Console.WriteLine ( <span class="hljs-string">&quot; &#123;0&#125;被&#123;1&#125;访问&quot;</span>，concreteElementB.GetType().Name, <span class="hljs-keyword">this</span>.GetType ( ).Name);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteVisitor2</span> : <span class="hljs-title">Visitor</span><br>&#123;<br>    <span class="hljs-comment">//代码上类类似，省略。</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Element类，定义一个Accept 操作，它以一个访问者为参数。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Element</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Accept</span> (<span class="hljs-params">Visitor visitor</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ConcreteElementA 和 ConcreteElementB类，具体元素，实现Accept操作。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteElementA</span>: <span class="hljs-title">Element</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Accept</span> (<span class="hljs-params">Visitor visitor</span>)</span><br>    &#123;<br>        <span class="hljs-comment">//充分利用双分派技术，实现处理与数据结构的分离</span><br>        visitor.VisitConcreteElementA (<span class="hljs-keyword">this</span>);<br>    &#125;<br>    <span class="hljs-comment">//其他相关方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OperationA</span>()</span>&#123;&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteElementB</span>: <span class="hljs-title">Element</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Accept</span> (<span class="hljs-params">Visitor visitor</span>)</span><br>    &#123;<br>        <span class="hljs-comment">//充分利用双分派技术，实现处理与数据结构的分离</span><br>        visitor.VisitConcreteElementB (<span class="hljs-keyword">this</span>);<br>    &#125;<br>    <span class="hljs-comment">//其他相关方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OperationB</span>()</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ObjectStructure类，能枚举它的元素，可以提供一个高层的接口以允许访问者访问它的元素。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> 0<span class="hljs-title">bjectStructure</span><br>&#123;<br>    <span class="hljs-keyword">private</span> IList&lt;Element&gt; elements = <span class="hljs-keyword">new</span> List&lt;Element&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Attach</span> (<span class="hljs-params">Element element</span>)</span><br>    &#123;<br>        elements.Add(element);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Detach</span> (<span class="hljs-params">Element element</span>)</span><br>    &#123;<br>        elements.Remove(element);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Accept</span> (<span class="hljs-params">visitor visitor</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">foreach</span> (Element e <span class="hljs-keyword">in</span> elements)<br>        &#123;<br>            e.Accept (visitor);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>客户端代码</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span> (<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&#123;<br>    objectstructure o = <span class="hljs-keyword">new</span> ObjectStructure();<br>    o.Attach (<span class="hljs-keyword">new</span> ConcreteElementA());<br>    o.Attach (<span class="hljs-keyword">new</span> ConcreteElementB());<br>    <br>    Concretevisitor1 v1 =<span class="hljs-keyword">new</span> Concretevisitor1();<br>    Concretevisitor2 v2 =<span class="hljs-keyword">new</span> Concretevisitor2();<br>    <br>    o.Accept(v1);<br>    o.Accept(v2);<br>    <br>    Console.Read();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="④-优点和缺点-12"><a href="#④-优点和缺点-12" class="headerlink" title="④ 优点和缺点"></a>④ 优点和缺点</h4><p>​<strong>优点：</strong></p><ul><li>访问者模式使得添加新的操作变得容易。如果一些操作依赖于一个复杂的结构对象的话，那么一般而言，添加新的操作会变得很复杂。而使用访问者模式，增加新的操作就意味着添加一个新的访问者类。因此，使得添加新的操作变得容易。</li><li>访问者模式使得有关的行为操作集中到一个访问者对象中，而不是分散到一个个的元素类中。这点类似与”中介者模式”。</li><li>访问者模式可以访问属于不同的等级结构的成员对象，而迭代只能访问属于同一个等级结构的成员对象。</li></ul><p>​<strong>缺点：</strong></p><ul><li>增加新的元素类变得困难。每增加一个新的元素意味着要在抽象访问者角色中增加一个新的抽象操作，并在每一个具体访问者类中添加相应的具体操作。</li></ul><h4 id="⑤-总结-14"><a href="#⑤-总结-14" class="headerlink" title="⑤ 总结"></a>⑤ 总结</h4><p><strong>访问者模式（Visitor）</strong>，表示一个作用于某个结构中的各元素的操作。它使你可以在不改变各元素类的前提下定义作用于这些元素的新操作</p><hr><h3 id="10、备忘录模式"><a href="#10、备忘录模式" class="headerlink" title="10、备忘录模式"></a>10、备忘录模式</h3><h4 id="①-引言-20"><a href="#①-引言-20" class="headerlink" title="① 引言"></a>① 引言</h4><p>​备忘者模式与命令模式有点相似，不同的是，命令模式保存的是发起人的具体命令（命令对应的是行为），而备忘录模式保存的是发起人的状态（而状态对应的数据结构，如属性）。</p><h4 id="②-备忘录设计模式介绍"><a href="#②-备忘录设计模式介绍" class="headerlink" title="② 备忘录设计模式介绍"></a>② 备忘录设计模式介绍</h4><p>​从字面意思就可以明白，备忘录模式就是对某个类的状态进行保存下来，等到需要恢复的时候，可以从备忘录中进行恢复。生活中这样的例子经常看到，如备忘电话通讯录，备份操作操作系统，备份数据库等。</p><p>　　备忘录模式的具体定义是：<strong>在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可以把该对象恢复到原先的状态。</strong></p><h4 id="③-实现-21"><a href="#③-实现-21" class="headerlink" title="③ 实现"></a>③ 实现</h4><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%87%E5%BF%98%E5%BD%95%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><blockquote><p>发起人(Originator）类</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">Originator</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> state;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> State<br>    &#123;<br>        <span class="hljs-comment">//需要保存的属性，可能有多个</span><br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> state; &#125;<br>        <span class="hljs-keyword">set</span> &#123;state = <span class="hljs-keyword">value</span>; &#125;<br>    &#125;<br>    <span class="hljs-comment">//创建备忘录，将当前需要保存的信息导入并</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Memento <span class="hljs-title">CreateMemento</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">new</span> Memento(state));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetMemento</span>(<span class="hljs-params">Memento memento</span>)</span><br>    &#123;<br>        <span class="hljs-comment">//恢复备忘录，将 Memento导入并将相关数据恢复</span><br>        state = memento.State;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Show</span>()</span><br>    &#123;<br>        <span class="hljs-comment">//显示数据</span><br>        Console.writeLine (<span class="hljs-string">&quot;State=&quot;</span> + state); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>备忘录（Memento）类</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">Memento</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> state;<br>    <span class="hljs-comment">//构造方法,将相关数据导入</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Memento</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> state</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.state = state;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> State<br>    &#123;<br>        <span class="hljs-comment">//需要保存的数据属性,可以是多个</span><br>        <span class="hljs-keyword">get</span>&#123; <span class="hljs-keyword">return</span> state;&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>管理者（Caretaker）类</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">Caretaker</span><br>&#123;<br>    <span class="hljs-keyword">private</span> Memento memento;<br>    <span class="hljs-keyword">public</span> Memento Memento<br>    &#123;<br>        <span class="hljs-comment">//得到或设置备忘录</span><br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> memento; &#125;<br>        <span class="hljs-keyword">set</span> &#123; memento = <span class="hljs-keyword">value</span>; &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>客户端代码</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> [] args</span>)</span><br>&#123;<br>    <span class="hljs-comment">//Originator初始状态属性为“On”</span><br>    Originator o =<span class="hljs-keyword">new</span> Originator();<br>    o.State = <span class="hljs-string">&quot;On&quot;</span> ;<br>    o.Show();<br>    <br>    <span class="hljs-comment">//保存状态时，由于有了很好的封装，可以隐藏Originator的实现细节</span><br>    Caretaker c = <span class="hljs-keyword">new</span> Caretaker();<br>    c.Memento = o.CreateMemento();<br>    <br>    <span class="hljs-comment">//Originator改变了状态属性为“Off&quot;</span><br>    o.State = <span class="hljs-string">&quot;Off&quot;</span>;<br>    <span class="hljs-comment">//Console.Read();</span><br>    o.Show();<br>    <br>    Console.Read();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="④-优点和缺点-13"><a href="#④-优点和缺点-13" class="headerlink" title="④ 优点和缺点"></a>④ 优点和缺点</h4><p>​<strong>优点：</strong></p><ul><li>如果某个操作错误地破坏了数据的完整性，此时可以使用备忘录模式将数据恢复成原来正确的数据。</li><li>备份的状态数据保存在发起人角色之外，这样发起人就不需要对各个备份的状态进行管理。而是由备忘录角色进行管理，而备忘录角色又是由管理者角色管理，符合单一职责原则。</li></ul><p>​<strong>缺点：</strong></p><ul><li>在实际的系统中，可能需要维护多个备份，需要额外的资源，这样对资源的消耗比较严重。</li></ul><h4 id="⑤-总结-15"><a href="#⑤-总结-15" class="headerlink" title="⑤ 总结"></a>⑤ 总结</h4><p><strong>备忘录（Memento）</strong>：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。</p><hr><h3 id="11、解释器模式"><a href="#11、解释器模式" class="headerlink" title="11、解释器模式"></a>11、解释器模式</h3><h4 id="①-解释器设计模式介绍"><a href="#①-解释器设计模式介绍" class="headerlink" title="① 解释器设计模式介绍"></a>① 解释器设计模式介绍</h4><p>​使用解释器模式的实例不是很多，但对于满足以上特点，且对运行效率要求不是很高的应用实例，如果用解释器模式来实现，其效果是非常好的。解释器模式是给定一种语言，定义它文法的一种表示，并定义一种解释器，这个解释器使用该表示来解释器语言中的句子。</p><h4 id="②-实现-1"><a href="#②-实现-1" class="headerlink" title="② 实现"></a>② 实现</h4><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><blockquote><p>AbstractExpression(抽象表达式)，声明一个抽象的解释操作，这个接口为抽象语法树中所有的节点所共享。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AbstractExpression</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Interpret</span> (<span class="hljs-params">Context context</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>TerminalExpression(终结符表达式)，实现与文法中的终结符相关联的解释操作。实现抽象表达式中所要求的接口，主要是一个interpret()方法。文法中每一个终结符都有一个具体终结表达式与之相对应。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">TerminalExpression</span> : <span class="hljs-title">AbstractExpression</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Interpret</span> (<span class="hljs-params">Context context</span>)</span><br>    &#123;<br>        Console.writeLine( <span class="hljs-string">&quot;终端解释器&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>NonterminalExpression（非终结符表达式)，为文法中的非终结符实现解释操作。对文法中每一条规则R1、R2……Rn都需要一个具体的非终结符表达式类。通过实现抽象表达式的 interpret()方法实现解释操作。解释操作以递归方式调用上面所提到的代表R1、R2……Rn中各个符号的实例变量。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">NonterminalExpression</span> : <span class="hljs-title">AbstractExpression</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Interpret</span> (<span class="hljs-params">Context context</span>)</span><br>    &#123;<br>        Console.writeLine (<span class="hljs-string">&quot;非终端解释器&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Context，包含解释器之外的一些全局信息。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">Context</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> input;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Input<br>    &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> input; &#125;<br>        <span class="hljs-keyword">set</span> &#123; input = <span class="hljs-keyword">value</span>;&#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> output;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Output<br>    &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> output; &#125;<br>        <span class="hljs-keyword">set</span> &#123; output = <span class="hljs-keyword">value</span>;&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>客户端代码，构建表示该文法定义的语言中一个特定的句子的抽象语法树。调用解释操作。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[]args</span>)</span><br>&#123;<br>    Context context =<span class="hljs-keyword">new</span> Context();<br>    IList&lt;AbstractExpression&gt; list = <span class="hljs-keyword">new</span> List&lt;AbstractExpression&gt;();<br>    list.Add(<span class="hljs-keyword">new</span> TerminalExpression());<br>    list.Add(<span class="hljs-keyword">new</span> NonterminalExpression());<br>    list.Add(<span class="hljs-keyword">new</span> TerminalExpression());<br>    list.Add(<span class="hljs-keyword">new</span> TerminalExpression());<br>    <br>    <span class="hljs-keyword">foreach</span> (AbstractExpression exp <span class="hljs-keyword">in</span> list)<br>    &#123;<br>        exp.Interpret (context);<br>    &#125;<br>    <br>    Console.Read();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="③-优点和缺点-1"><a href="#③-优点和缺点-1" class="headerlink" title="③ 优点和缺点"></a>③ 优点和缺点</h4><p>​<strong>优点：</strong></p><ol><li>扩展性好。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。</li><li>容易实现。在语法树中的每个表达式节点类都是相似的，所以实现其文法较为容易。</li></ol><p>​<strong>缺点：</strong></p><ol><li>执行效率较低。解释器模式中通常使用大量的循环和递归调用，当要解释的句子较复杂时，其运行速度很慢，且代码的调试过程也比较麻烦。</li><li>会引起类膨胀。解释器模式中的每条规则至少需要定义一个类，当包含的文法规则很多时，类的个数将急剧增加，导致系统难以管理与维护。</li><li>可应用的场景比较少。在软件开发中，需要定义语言文法的应用实例非常少，所以这种模式很少被使用到。</li></ol><h4 id="④-总结-2"><a href="#④-总结-2" class="headerlink" title="④ 总结"></a>④ 总结</h4><p><strong>解释器模式（interpreter）</strong>，给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C Sharp</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity 生命周期</title>
    <link href="/2022/06/05/Unity%E8%84%9A%E6%9C%AC%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2022/06/05/Unity%E8%84%9A%E6%9C%AC%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="Unity生命周期"><a href="#Unity生命周期" class="headerlink" title="Unity生命周期"></a>Unity生命周期</h1><h3 id="Unity生命周期图"><a href="#Unity生命周期图" class="headerlink" title="Unity生命周期图"></a>Unity生命周期图</h3><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/06-05/Unity%E8%84%9A%E6%9C%AC%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png"></p><h3 id="Reset"><a href="#Reset" class="headerlink" title="Reset"></a>Reset</h3><p><strong>Reset</strong> 是当Scripts第一次绑定到物体上或者点击Reset按钮的时候会触发，且只在Editor的模式下触发，游戏打包的时候并不会触发。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Reset</span>()</span><br>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Awake"><a href="#Awake" class="headerlink" title="Awake"></a>Awake</h3><p><strong>Awake</strong> 是当脚本实例在游戏运行被载入的时候运行，一般为了初始化游戏变量和游戏状态，注意，无论函数是否被激活，Awake 都会执行。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span><br>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="OnEable"><a href="#OnEable" class="headerlink" title="OnEable"></a>OnEable</h3><p><strong>OnEable</strong> 是在游戏对象是可激活状态的时候会调用</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnEable</span>()</span><br>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h3><p><strong>Start</strong> 也是为了初始化变量的方法但是和 <strong>Awake</strong> 有些许的不同</p><p>首先，<strong>Awake</strong> 是在项目初始化的时候被调用的，但是 <strong>Start</strong> 可能在初始之后调用，所有如果把一些状态放在 <strong>Start</strong> 中进行初始化，会很不安全，因为可能会有别的函数在 <strong>Start</strong> 之前就被执行，造成一些空引用的问题。</p><p>其次，如果对象不是处于激活状态，<strong>Start</strong> 是不会被调用的，而 <strong>Awake</strong> 无论是不是激活都会被引用。</p><p><strong>所以，建议把所有初始化都放在Awake上</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="FixedUpdate"><a href="#FixedUpdate" class="headerlink" title="FixedUpdate"></a>FixedUpdate</h3><p>Unity 建议，把所有的物理行为的每帧更新的逻辑都应当放在 <strong>FixedUpdate</strong> 里，原因因为这个是固定间隔的帧执行的，而普通的 <strong>Update</strong> 每一帧之间的间隔是不固定的，不一样的，所以一般都希望物体上的力是均匀的，否则会出现卡顿的现象。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FixedUpdate</span>()</span><br>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="OnTrigger、OnCollison、OnMouse"><a href="#OnTrigger、OnCollison、OnMouse" class="headerlink" title="OnTrigger、OnCollison、OnMouse"></a>OnTrigger、OnCollison、OnMouse</h3><p>先处理 <strong>OnTrigger</strong> 触发器行为，再处理 <strong>OnCollison</strong> 碰撞体行为，在此处理 <strong>OnMouse</strong> 的点击鼠标，点击输入的行为.</p><p>这三个行为是完全连续的行为。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnTrigger</span>()</span><br>&#123;<br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnCollison</span>()</span><br>&#123;<br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnMouse</span>()</span><br>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h3><p><strong>Update</strong> 是每一帧进行调用，是我们实现大部分游戏逻辑的方法.</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span><br>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="LateUpdate"><a href="#LateUpdate" class="headerlink" title="LateUpdate"></a>LateUpdate</h3><p><strong>LateUpdate</strong> 再所有 Update 方法执行之后执行，一般用于摄像机的跟随移动。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LateUpdate</span>()</span><br>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="OnGUI"><a href="#OnGUI" class="headerlink" title="OnGUI"></a>OnGUI</h3><p><strong>OnGUI</strong> 处理GUI数据，也是每一帧执行一次</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnGUI</span>()</span><br>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="OnDisable"><a href="#OnDisable" class="headerlink" title="OnDisable"></a>OnDisable</h3><p><strong>OnDisable</strong> 在对象被取消活跃状态的时候响应，和 <strong>OnEnable</strong> 相对应，但与此同时对象再次被激活的时候，<strong>OnEnable</strong> 也会再次响应。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnDisable</span>()</span><br>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="OnDestory"><a href="#OnDestory" class="headerlink" title="OnDestory"></a>OnDestory</h3><p><strong>OnDestory</strong> 在对象被销毁的时候被调用，但是如果一开始对象就处于不激活状态然后被销毁了，就不会调用这个函数。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnDisable</span>()</span><br>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>游戏编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>生命周期</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity 游戏AI之行为树</title>
    <link href="/2022/06/05/Unity%20AI%E4%B9%8B%E8%A1%8C%E4%B8%BA%E6%A0%91/"/>
    <url>/2022/06/05/Unity%20AI%E4%B9%8B%E8%A1%8C%E4%B8%BA%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="Unity-游戏AI之行为树"><a href="#Unity-游戏AI之行为树" class="headerlink" title="Unity 游戏AI之行为树"></a>Unity 游戏AI之行为树</h1><h2 id="游戏AI-行为树Part1：简介"><a href="#游戏AI-行为树Part1：简介" class="headerlink" title="游戏AI - 行为树Part1：简介"></a><strong>游戏AI - 行为树Part1：简介</strong></h2><p>游戏中的AI，大多数都是按照规则设定好的，没有太多花哨的技术。原因有几个：</p><p>一是出于风险成本的考虑，用一个新技术，需要程序员开发相应的算法和框架，游戏设计师重新上手设计方法和摸索算法的适用范围，小团队承受不起这样的开销，大团队又怕做坏名声；</p><p>二是“高级”的AI算法并不直观，难以设计。举一个例子，怎么利用神经网络来训练一个士兵AI？我见过的一个例子是设计师用几个按键来操作士兵移动攻击，然后程序自动记录敌我双方的数据和设计师的操作，最后利用这些信息作为input构建一个行为树。这个方法的问题有三个，一是效率奇慢，因为如果数据不够，行为树就可能覆盖不了所有情况，但多少才是“够”，又没有定论；二是错误的操作也会被记录下来，当然可以开发一个功能来删除设计师的某个动作；三是行为树的结果是无法解释的，相当于一个黑箱。</p><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/6-1-1-1.jpg"></p><p>由于上述的原因，一般的公司都会使用比较传统的有限状态机。</p><p>虽然第一次听的话可能会拗口，其实有限状态机的意思其实很简单，它包含了有限个的状态和状态间的转换条件。最直白的说法就是几个**if…else…**语句。为了弄明白这个概念，我们讲一个英雄的故事：</p><p>从前有一个胆小如鼠的英雄，</p><ol><li>他看到哥布林就会跑过去打它；</li><li>他看到半兽人就会逃跑；</li><li>他看不到哥布林也看不到半兽人就会休息；</li><li>他看到哥布林也看到半兽人也会跑。</li></ol><p>我们可以从中抽象出这样的一个有限状态机：</p><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/6-1-1-2.png"></p><p>有限状态机很符合我们的认知，但它有一个致命的缺点——它随着状态和转换条件的增多而急速地变得错综复杂，以至于很难对它做出改动（想象一下，多加一个状态，则需要增加几条转换线，越多状态，需要增加的转换线越多）。</p><p>也由于这个原因，比较多的开发者投入了行为树的怀抱。</p><h2 id="行为树"><a href="#行为树" class="headerlink" title="行为树"></a><strong>行为树</strong></h2><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>行为树的概念会比状态机要复杂些——行为树是一个包含逻辑节点和行为节点的树结构，每次需要找出一个行为的时候，会从树的根节点出发，遍历各个节点，找出第一个和当前数据相符合的行为。</p><p>很拗口对吧，下面来一个生动点的解释，继续上面的英雄的故事，但是是用行为树表达出来：</p><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/6-1-1-3.png"></p><p>这个行为树是等价于之前的有限状态机的。其中</p><p><strong>Root</strong>是根节点，每次需要寻找行为的时候都必须从这里开始。</p><p><strong>Priority Selector</strong>是一个逻辑节点，它的意思是让从左到右遍历自己的子节点，如果子节点的准入条件符合信息的话，就执行该子节点。如果英雄只看到哥布林，那么Orc in sight这个准入条件不符合，Escape不执行；Globlin in sight符合，于是执行Fight；因为Fight在Idle的左边，所以Fight的优先程度更高，于是Idle不执行。在我们的例子中，Idle可以看作是default behavior。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>从简单的行为树和有限状态机的对比，我们就可以看出，行为树由于引入了逻辑节点，它的转换条件更加少（线更少，更清晰），让<strong>拓展AI变得更加容易</strong>。</p><p>行为树还有另外一个优点：行为的<strong>重用</strong>（reuse)。</p><p>例如，Escape有一个跑的行为，而Fight则有跑的行为，和砍怪的行为。请看图：</p><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/6-1-1-4.png"></p><p><strong>Sequence</strong>同样是一个逻辑节点，它的意思是从左到右按顺序执行子节点，并且仅仅在一个子节点执行完成后才执行下一个子节点。在例子中，Do Run需要有一个自己判断到达目的地的方法，当该方法返回end的时候，才会执行Do Slash。</p><p>Escape和Fight的Do Run行为节点是一样的，只是Fight多了一个Do Slash行为节点而已。所以Do Run是一个可以重用的节点。</p><p>在行为树中，我们能够编写好Do Run，Do Slash这些基础的行为节点，和设定一些准入条件，就可以<strong>组成千变万化的AI</strong>了！</p><p>我们希望英雄在逃跑的时候群众发出嘘声，而在攻击的时候出现欢呼声：</p><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/6-1-1-5.png"></p><p>省略了其他部分，只画Escape部分。</p><p>Parallel是一个逻辑节点，它的意思是让所有子节点同时运行，那它什么时候结束呢，可以使当所有子节点都完成的时候结束，也可以让任一子节点完成时结束，视乎需要来做出选择。</p><p>那么在攻击当中会是怎么样实现的呢？大家可以尝试画出来，习惯一下行为树的思维方式。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ol><li><p>行为树拥有3种节点：</p></li><li><ol><li><p>根节点 Root</p></li><li><p>逻辑节点（可拓展）：</p></li><li><ol><li>Priority Selector</li><li>Sequence</li><li>Parallel</li></ol></li><li><p>行为节点</p></li></ol></li><li><p>行为树在复杂的情况比有限状态机更清晰，更可拓展</p></li><li><p>行为树有利于逻辑的重用</p></li><li><p>设计得好的行为树可以千变万化！</p></li></ol><p>之后，我会展示在游戏开发中怎么利用行为树作为框架来使用。</p><hr><h2 id="游戏AI-行为树Part2：框架"><a href="#游戏AI-行为树Part2：框架" class="headerlink" title="游戏AI - 行为树Part2：框架"></a><strong>游戏AI - 行为树Part2：框架</strong></h2><h2 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a><strong>关键词</strong></h2><p>在展开之前，我们先定义几个关键词（基本都以BT作为前缀…是Behavior Tree之意，别误会了…），会在下面的框架用到。</p><p><strong>BTNode</strong>：所有节点的base class。定义了一些节点的基本功能，并提供一些可继承的函数。</p><p><strong>BTAction</strong>：行为节点，继承于BTNode。具体的游戏逻辑应该放在这个节点里面。</p><p><strong>BTPrecondition</strong>：节点的准入条件，每一个BTNode都会有一个。具体的游戏逻辑判断可以继承于它。</p><p><strong>BTPrioritySelector</strong>：Priority Selector逻辑节点，继承于BTNode。每次执行，先有序地遍历子节点，然后执行符合准入条件的<strong>第一个</strong>子结点。可以看作是根据条件来选择一个子结点的<strong>选择器</strong>。</p><p><strong>BTSequence</strong>：Sequence逻辑节点，继承于BTNode。每次执行，有序地执行各个子结点，当一个子结点结束后才执行下一个。严格按照节点A、B、C的顺序执行，当最后的行为C结束后，BTSequence结束。</p><p><strong>BTParallel</strong>：Parallel逻辑节点，继承于BTNode。<strong>同时</strong>执行各个子结点。每当<strong>任一</strong>子结点的准入条件失败，它就不会执行。</p><p><strong>BTParallelFlexible</strong>：Parallel的一个变异，继承于BTNode。<strong>同时</strong>执行各个子节点。当<strong>所有</strong>子结点的准入条件都失败，它就不会执行。</p><p><strong>BTTree</strong>：将所有节点组合起来的地方。</p><p><strong>Database</strong>：<a href="https://link.zhihu.com/?target=http://en.wikipedia.org/wiki/Blackboard_system">黑板</a>，一个存放<strong>共享</strong>数据的地方，可以看成是一个Key－Value的字典。为什么需要黑板呢？因为设计良好的行为逻辑，应该是独立的，可以在行为树的任何位置部署的。也就是说行为A和行为B并没有直接的沟通方法。黑板的作用就是作为一个行为树的“数据库”，让各个行为节点都可以储存数据进去，供感兴趣的行为节点利用。（同时，在Unity3d的语境下，Database继承MonoBehavior，可以提供各种Component给节点使用。）</p><p>UML类图：</p><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/6-1-1-6.png"></p><h2 id="代码资源"><a href="#代码资源" class="headerlink" title="代码资源"></a><strong>代码资源</strong></h2><p>我们使用的框架的代码放在了Github：<a href="https://link.zhihu.com/?target=https://github.com/f15gdsy/BT-Framework">BT Framework</a>。它是用 C# 写的，但概念可以转换到任何语言。</p><p>我们的Demo例子是<a href="http://zhuanlan.zhihu.com/indiegamepixel/19890016">Part1</a>里提到的“贪生怕死的英雄”，Demo的代码可以在<a href="https://link.zhihu.com/?target=https://github.com/f15gdsy/BT-Test">这里</a>下载。Demo是用Unity3d写的。</p><h2 id="行为树的构建"><a href="#行为树的构建" class="headerlink" title="行为树的构建"></a><strong>行为树的构建</strong></h2><p>下面，我们会先从BT行为树框架的<strong>使用</strong>开始，然后再解释框架的实现。</p><p>BT行为树框架与外界的入口在BTTree，下面我们来看看BTTree的子类MoveAttackAI，我们在这里构建了一个行为树：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// MoveAttackAI.cs</span><br><span class="hljs-comment">// 一个继承于BT Tree的一个类</span><br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Init</span> ()</span> &#123;<br>   <span class="hljs-comment">// 初始化base class</span><br>   <span class="hljs-keyword">base</span>.Init();<br><br>   <span class="hljs-comment">// 创建根节点，根节点</span><br>   _root = <span class="hljs-keyword">new</span> BTPrioritySelector();<br>   <br>   <span class="hljs-comment">// ... 创建准入条件，如checkOrcInSight</span><br>   <span class="hljs-comment">// ... 创建行为／逻辑节点，如findDestination，run</span><br><br>   <span class="hljs-comment">// 搭建行为树</span><br>   <span class="hljs-comment">// Escape 节点</span><br>   BTParallel escape = <span class="hljs-keyword">new</span> BTParallel(BTParallel.ParallelFunction.Or, checkOrcInSight);<br>   &#123;<br>      escape.AddChild(findDestination);<br>      escape.AddChild(run);<br>   &#125;<br>   _root.AddChild(escape);<br><br>   <span class="hljs-comment">//... Fight 节点</span><br>   _root.AddChild(fight);<br><br>   <span class="hljs-comment">//... Idle 节点</span><br>   _root.AddChild(idle);<br>&#125;<br></code></pre></td></tr></table></figure><p>上图就是我们的行为树了！它基本对应了<a href="http://zhuanlan.zhihu.com/indiegamepixel/19890016">Part1</a>里面的图，不过有所修改。</p><p>\1. 在上面，我们创建Root节点，创建准入条件，和行为／逻辑节点，然后通过AddChild来搭建行为树。</p><p>\2. escape节点是一个Parallel逻辑节点，因为每次执行escape的时候我们都需要先找到逃跑的目的地，然后再跑。这时候可能有朋友会问，为什么不用Sequence呢？因为Sequence每次执行，都是按照行为A、行为B、行为C这样的顺序执行的，执行完行为C之后就结束。所以如果用Sequence，我们的目的地在跑到当前目的地之前就不能更新了。</p><p>\3. findDestination，和run这些行为都是继承于BTAction 。但是为什么我们要将选择目的地和跑这个动作分开呢？是为了更好地分离逻辑——Escape的跑和Fight的跑是一样的，但目的地选择不一样，Escape的目的地是半兽人的相反方向，Fight的目的地是哥布林的位置。</p><p>\4. 另外，在Part1的评论里面，</p><p><a href="https://www.zhihu.com/people/a44d48aa6a124b610a621bef6c16568f">@余冬冬</a></p><p>老师提到</p><blockquote><p>“为什么要有ROOT呢？ 直接prority selector不可以么。”</p></blockquote><p>在我们的例子里，Root的确就是一个Priority Selector！不过由于在base class——BTTree里面会对Root特别对待，所以在Part1里就特别提到它。</p><p>搭建一个行为树，最核心的就是上面的几行代码了，不难吧 :)</p><p>要在Unity3d里面的使用这一个行为树也很简单，在GameObject里面加入MoveAttackAI这个component就好（BTTree继承于MonoBehavior）。</p><p>如果在其他引擎当中使用，如Cocos2d-x，BTTree则应该拥有Update函数和自定义的初始化函数。</p><p>下面我们看看BT框架的实现。</p><h2 id="框架的实现"><a href="#框架的实现" class="headerlink" title="框架的实现"></a><strong>框架的实现</strong></h2><h2 id="BTNode和逻辑节点"><a href="#BTNode和逻辑节点" class="headerlink" title="BTNode和逻辑节点"></a>BTNode和逻辑节点</h2><p>BTNode提供了节点的最重要的接口：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// BTNode.cs</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BTNode</span> &#123;<br>   <span class="hljs-comment">//...</span><br><br>   <span class="hljs-comment">// 节点的准入条件</span><br>   <span class="hljs-keyword">public</span> BTPrecondition precondition;<br><br>   <span class="hljs-comment">// 黑板 </span><br>   <span class="hljs-keyword">public</span> Database database;<br><br>   <span class="hljs-comment">// 冷却功能</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> interval = <span class="hljs-number">0</span>;<br><br>   <span class="hljs-comment">// 当false的时候，节点不会执行</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> activated;<br>   <br><br>   <span class="hljs-comment">// 节点初始化的接口，Database可提供Unity3d中的Component给节点使用</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Activate</span> (<span class="hljs-params">Database database</span>)</span> &#123;<br>      <span class="hljs-comment">//...</span><br>   &#125;<br>   <br>   <span class="hljs-comment">// 检查节点能否执行，包括是否activated，是否冷却完成，是否通过准入条件，和个性化检查 (DoEvaluate)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">Evaluate</span> ()</span> &#123;<br>      <span class="hljs-built_in">bool</span> coolDownOK = CheckTimer();<br>      <span class="hljs-keyword">return</span> activated &amp;&amp; coolDownOK &amp;&amp; (precondition == <span class="hljs-literal">null</span> || precondition.Check()) &amp;&amp; DoEvaluate();<br>   &#125;<br><br>   <span class="hljs-comment">// 给子类提供个性化检查的接口</span><br>   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">DoEvaluate</span> ()</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<br><br>   <span class="hljs-comment">// 节点执行的接口，需要返回BTResult.Running，或者BTResult.Ended</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> BTResult <span class="hljs-title">Tick</span> ()</span> &#123;<span class="hljs-keyword">return</span> BTResult.Ended;&#125;<br><br>   <span class="hljs-comment">// 节点清零的接口</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Clear</span> ()</span> &#123;&#125;<br><br>   <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>BTNode提供给子类的接口中最重要的两个是DoEvaluate()和Tick()。</p><p><strong>DoEvaludate</strong>给子类提供个性化检查的接口（注意和<strong>Evaluate</strong>的不同），例如Sequence的检查和Priority Selector的检查是不一样的。例如Sequence和Priority Selector里都有节点A，B，C。第一次检查的时候，</p><p>Sequence只检查A就可以了，因为A不通过Evaluate，那么这个Sequence就没办法从头开始执行，所以Sequence的DoEvaludate也不通过。</p><p>而Priority Selector则先检查A，A不通过就检查B，如此类推，仅当所有的子结点都无法通过Evaluate的时候，才会不通过DoEvaludate。</p><p><strong>Tick</strong>是节点执行的接口，仅仅当Evaluate通过时，才会执行。子类需要重载Tick，才能达到所想要的逻辑。例如Sequence和Priority Selector，它们的Tick也是不一样的：</p><p>Sequence里当active child节点A Tick返回Ended时，Sequence就会将当前的active child设成节点B（如果有B的话），并返回Running。当Sequence最后的子结点N Tick返回Ended时，Sequence也返回Ended。</p><p>Priority Selector则是当目前的active child返回Ended的时候，它也返回Ended。Running的时候，它也返回Running。</p><p>正是通过重载DoEvaluate和Tick，BT框架实现了Sequence，PrioritySelector，Parallel，ParalleFlexible这几个逻辑节点。如果你有特殊的需求，也可以重载DoEvaluate和Tick来实现！</p><h2 id="BTAction"><a href="#BTAction" class="headerlink" title="BTAction"></a>BTAction</h2><p>BTAction是负责游戏逻辑的行为节点，也就是行为树里面的“行为”。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// BTAction.cs</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BTAction</span> : <span class="hljs-title">BTNode</span> &#123;<br>   <span class="hljs-keyword">private</span> BTActionStatus _status = BTActionStatus.Ready;<br>   <br>   <span class="hljs-comment">//...</span><br><br>   <span class="hljs-comment">// 第一次进入行为</span><br>   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Enter</span> ()</span> &#123;<span class="hljs-comment">//... Debug functionality&#125;</span><br>   <br>   <span class="hljs-comment">// 离开行为</span><br>   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Exit</span> ()</span> &#123;<span class="hljs-comment">//... Debug functionality&#125;</span><br><br>   <span class="hljs-comment">// 行为的执行，返回BTResult</span><br>   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> BTResult <span class="hljs-title">Execute</span> ()</span> &#123;<span class="hljs-comment">//...&#125;</span><br><br>   <span class="hljs-comment">// 重载BTNode的Tick，加入了Enter，Exit，Execute的概念</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> BTResult <span class="hljs-title">Tick</span> ()</span> &#123;<br>      BTResult result = BTResult.Ended;<br>      <span class="hljs-keyword">if</span> (_status == BTActionStatus.Ready) &#123;<br>         Enter();<br> _status = BTActionStatus.Running;<br>      &#125;<br>      <br>      <span class="hljs-comment">// not using else so that the status changes reflect instantly</span><br>      <span class="hljs-keyword">if</span> (_status == BTActionStatus.Running) &#123;<br>         result = Execute();<br>         <span class="hljs-keyword">if</span> (result != BTResult.Running) &#123;<br>            Exit();<br>    _status = BTActionStatus.Ready;<br> &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> result;<br>   &#125;<br><br>   <span class="hljs-comment">// 重载清零接口，因为外部没有办法调用Exit</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Clear</span> ()</span> &#123;<br>      <span class="hljs-comment">// not cleared yet</span><br>      <span class="hljs-keyword">if</span> (_status != BTActionStatus.Ready) &#123;<br>         Exit();<br> _status = BTActionStatus.Ready;<br>      &#125;<br>   &#125;<br><br>   <span class="hljs-comment">//...</span><br><br>   <span class="hljs-keyword">private</span> <span class="hljs-built_in">enum</span> BTActionStatus &#123;<br>      Ready = <span class="hljs-number">1</span>,<br>      Running = <span class="hljs-number">2</span>,<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>BTAction里面最重要的是Tick，它重载了BTNode的Tick，增加了对Enter，Exit，Execute的支持。如果大家对有限状态机比较熟悉，一个状态机里面的状态通常都会支持这三个方法，分别用来初始化，清零，和执行逻辑。在每一次行为节点的一个运行周期（不是生命周期）里，Enter仅在一开始被调用，Exit仅在最后被调用，Execute会在每一次Tick被调用。</p><p>例如我们可以这样实现DoRun：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// DoRun.cs</span><br><br><span class="hljs-comment">// 在某些简单的情况下，没有必要将动画和位移逻辑分开的话，可以这样写；</span><br><span class="hljs-comment">// 但通常为了更好的逻辑分离，我并不会将它们放在一起。而是分成两个不同的行为。</span><br><span class="hljs-comment">//   protected override void Enter () &#123;</span><br><span class="hljs-comment">//      database.GetComponent&lt;Animator&gt;().Play(&quot;Run&quot;);</span><br><span class="hljs-comment">//   &#125;</span><br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> BTResult <span class="hljs-title">Execute</span> ()</span> &#123;<br>   <span class="hljs-comment">//...</span><br><br>   <span class="hljs-keyword">if</span> (CheckArrived()) &#123;<br>      <span class="hljs-keyword">return</span> BTResult.Ended;   <span class="hljs-comment">// 告诉父节点我要结束了</span><br>   &#125;<br>   MoveToDestination();<br>   <span class="hljs-keyword">return</span> BTResult.Running;   <span class="hljs-comment">// 告诉父节点我还在运行</span><br>&#125;<br></code></pre></td></tr></table></figure><p>就是这么简单！</p><p>同时，我们可以看到DoRun并没有引用行为节点（也不应该引用），也就是说，它是一个逻辑上独立的行为节点，可以部署到行为树的任何位置。<strong>行为节点的逻辑独立，可以让我们写的每一个行为，都可以放到我们自己的逻辑库里面，给以后的项目调用！</strong></p><h2 id="Demo的局限和改进方法"><a href="#Demo的局限和改进方法" class="headerlink" title="Demo的局限和改进方法"></a><strong>Demo的局限和改进方法</strong></h2><p>如果你有耐心看到这里，你一定已经发现了Demo有一个bug——当半兽人和哥布林在同一方向（相对于英雄）的时候，英雄会先逃跑，然后在某一个点上迅速来回翻转。这是因为AI在Escape和Fight这两个分支上快速切换。</p><p>一个改进的方法是<strong>分等级的行为树（Hierarchical Behavior Tree）</strong>[1]：</p><p>有一个做决策的行为树A，和一个按照命令执行的行为树B。A根据游戏世界的情况做出决策，然后将命令放到Database里，然后B根据命令做出动作。由于两个行为树都放在一个Game Object里，所以Database是A、B共享的。通常，决策者A并不会每一帧都做出决策，而是设定一个冷却时间。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">// DecisionAI.cs<br><br>// 设定1.5秒的冷却时间<br>_root.interval = 1.5f;<br></code></pre></td></tr></table></figure><p>改进的Demo代码可以在<a href="https://zhuanlan.zhihu.com/p/BT-Test/tree/improved">这里</a>下载。</p><p>这样一个分等级的行为树有两个好处：</p><ol><li>让决策逻辑和执行逻辑分离。面对同样的决策，不同Game Object可能有不同的执行方法。</li><li>玩家控制的角色和AI控制的角色可以分享同一个执行逻辑——只需要负责玩家控制的代码将命令存放到Database里面供执行逻辑使用就可以了。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ul><li>我们从BT框架的使用为学习入口，解释了行为树框架的实现原理；</li><li>也了解了怎么去拓展出个性化的逻辑节点和行为节点来满足项目需求；</li><li>通过逻辑独立地拓展BTAction，我们能够积累自己的逻辑库！</li><li>最后我们提到了分等级的行为树，它可以帮助我们将决策逻辑和执行逻辑分开（并解决了demo里面的一个bug）。</li></ul><p>BT框架还可以怎样拓展？我的下一个目标就是将它打造成一个Unity3d的插件，可以通过GUI来搭建行为树，而不用通过代码——当然，行为节点还是得自己用代码写。</p><p><strong>转自知乎</strong>：</p><p><a href="https://zhuanlan.zhihu.com/p/19890016">游戏AI - 行为树Part1：简介 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/19891875">游戏AI - 行为树Part2：框架 - 知乎 (zhihu.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>游戏编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C# 之Yield Return语法的作用和好处</title>
    <link href="/2022/06/01/C%20Sharp%E4%B9%8BYield%20Return%E8%AF%AD%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%A5%BD%E5%A4%84/"/>
    <url>/2022/06/01/C%20Sharp%E4%B9%8BYield%20Return%E8%AF%AD%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%A5%BD%E5%A4%84/</url>
    
    <content type="html"><![CDATA[<p>首先我贴出平时正常输出偶数集合的办法</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  学习Yield Return 语法</span><br><span class="hljs-comment"> *  使用两个方法，显示1 - 100之间的全部偶数</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">YieldReturn</span>语法解析<br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>       <span class="hljs-keyword">static</span>  <span class="hljs-keyword">private</span> List&lt;<span class="hljs-built_in">int</span>&gt; _numArray; <span class="hljs-comment">//用来保存1-100 这100个整数</span><br><br>        Program() <span class="hljs-comment">//构造函数。我们可以通过这个构造函数往待测试集合中存入1-100这100个测试数据</span><br>        &#123;<br>            _numArray = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;(); <span class="hljs-comment">//给集合变量开始在堆内存上开内存，并且把内存首地址交给这个_numArray变量</span><br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; i++) <br>            &#123;<br>                _numArray.Add(i);  <span class="hljs-comment">//把1到100保存在集合当中方便操作</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">new</span> Program();<br><br>            TestMethod();<br><br><br>        &#125;<br><br>        <span class="hljs-comment">//测试求1到100之间的全部偶数</span><br>        <span class="hljs-function"><span class="hljs-keyword">static</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TestMethod</span>()</span><br>        &#123;<br>            <span class="hljs-keyword">foreach</span> (<span class="hljs-function"><span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> <span class="hljs-title">GetAllEvenNumber</span>())</span> <br>            &#123;<br>                Console.WriteLine(item); <span class="hljs-comment">//输出偶数测试</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//测试我们正常情况下拿到全部偶数的方法</span><br>       <span class="hljs-function"><span class="hljs-keyword">static</span>  IEnumerable&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-title">GetAllEvenNumber</span>()</span><br>        &#123;<br>            List&lt;<span class="hljs-built_in">int</span>&gt; result = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;(); <span class="hljs-comment">//开集合内存存偶数用</span><br><br>            <span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">int</span> num <span class="hljs-keyword">in</span> _numArray) <br>            &#123;<br>                <span class="hljs-keyword">if</span>(num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) <span class="hljs-comment">//判断是不是偶数</span><br>                &#123;<br>                    <span class="hljs-comment">//yield return num;</span><br>                    result.Add(num); <span class="hljs-comment">//存入集合</span><br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">//返回偶数集合变量   可能有人会觉得奇怪返回类型不是List&lt;int&gt;这样可以吗</span><br>            <span class="hljs-comment">//这个就要回到我们的里氏替换原则了，子类是可以替换父类的，也就是当父类用</span><br>            <span class="hljs-comment">//比如我这个方法是想得到IEnumerable&lt;int&gt; 类型变量，但是我给了List&lt;int&gt;类型变量</span><br>            <span class="hljs-comment">//注意List&lt;int&gt; 是继承 IEnumerable&lt;int&gt; 的，什么意思当我们把子类当父类使用，</span><br>            <span class="hljs-comment">//那么大才小用，因为子类很多都是继承父亲，你自身增加很多字段或者方法，这样就不能用了。</span><br>            <span class="hljs-keyword">return</span> result;  <br>            <span class="hljs-comment">//yield break;</span><br>        &#125;<br><br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>贴出使用Yiele Return办法输出耦合集合</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  学习Yield Return 语法</span><br><span class="hljs-comment"> *  使用两个方法，显示1 - 100之间的全部偶数</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">YieldReturn</span>语法解析<br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>       <span class="hljs-keyword">static</span>  <span class="hljs-keyword">private</span> List&lt;<span class="hljs-built_in">int</span>&gt; _numArray; <span class="hljs-comment">//用来保存1-100 这100个整数</span><br><br>        Program() <span class="hljs-comment">//构造函数。我们可以通过这个构造函数往待测试集合中存入1-100这100个测试数据</span><br>        &#123;<br>            _numArray = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;(); <span class="hljs-comment">//给集合变量开始在堆内存上开内存，并且把内存首地址交给这个_numArray变量</span><br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; i++) <br>            &#123;<br>                _numArray.Add(i);  <span class="hljs-comment">//把1到100保存在集合当中方便操作</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">new</span> Program();<br><br>            TestMethod();<br><br><br>        &#125;<br><br>        <span class="hljs-comment">//测试求1到100之间的全部偶数</span><br>        <span class="hljs-function"><span class="hljs-keyword">static</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TestMethod</span>()</span><br>        &#123;<br>            <span class="hljs-keyword">foreach</span> (<span class="hljs-function"><span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> <span class="hljs-title">GetAllEvenNumber</span>())</span> <br>            &#123;<br>                Console.WriteLine(item); <span class="hljs-comment">//输出偶数测试</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//测试我们使用Yield Return情况下拿到全部偶数的方法</span><br>       <span class="hljs-function"><span class="hljs-keyword">static</span>  IEnumerable&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-title">GetAllEvenNumber</span>()</span><br>        &#123;<br><br>            <span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">int</span> num <span class="hljs-keyword">in</span> _numArray) <br>            &#123;<br>                <span class="hljs-keyword">if</span>(num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) <span class="hljs-comment">//判断是不是偶数</span><br>                &#123;<br>                    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> num; <span class="hljs-comment">//返回当前偶数</span><br><br>                &#125;<br>            &#125;        <br>            <span class="hljs-keyword">yield</span> <span class="hljs-keyword">break</span>;  <span class="hljs-comment">//当前集合已经遍历完毕，我们就跳出当前函数，其实你不加也可以</span><br>            <span class="hljs-comment">//这个作用就是提前结束当前函数，就是说这个函数运行完毕了。</span><br>        &#125;<br><br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>​大家测试了2个代码结果没，是不是都可以正确拿到全部偶数集合，具体我需要你们测，这样进步快，才会真是学会。只看不练假把戏。</p><p>​现在我们说他们的区别：<br>​这个才是真正要学的地方<br>​我们需要下断点</p><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/5-31-1-1.png"></p><p>​我希望你是在断点调试，具体就贴太多，你会发现代码跑到Yield return num的时候，当前函数就会结束，并把这个num交给这里，我先上图</p><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/5-31-1-2.png"></p><p>​最终会给item变量。<br>​然后输出，然后在执行 GetAllEvenNumber（）方法，和上次得到偶数是一样。<br>​我们发现这个Yield Return是可以让当前函数的进程状态切换到阻塞状态，然后去选择了把cpu交给当前的出进程，这样就转而执行调用方函数。 （补充个小知识点其实我们写的程序加入到内存中，并不定就是一个进程，我们会根据情况分成几个子进程去干活，方便操作系统去管理以及多道程序运行在内存，提高计算机资源的利用率）<br>​这样有个好处，我们假如有1000000个数据，我们需要得到里面的耦合，当我们通过这个方法得到一个耦合会立马显示在控制台上。而不是等很久也就把全部偶数都查找到存入集合当中，然后在一一遍历输出。<br>​这个好处是很大的。比如我们用户可能就看数据开始肯定不是全部值需要部分就可以，看完这些在看后面的，这样数据会让觉得显示没有延迟。</p><p>​下面我们来断点调一般的查找偶数的函数</p><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/5-31-1-3.png"></p><p>​我们发现这个循环没有跑完是不会退出当前函数的，也就是必须要查找全部的偶数才可以。这样假如我们很多数据。就会一直等这个数据才可以拿到这个数据去显示给用户看。<br>这样就麻烦了。</p><p>​因此我们下个结论：Yield Return关键字的作用就是退出当前函数，并且会保存当前函数执行到什么地方，也就上下文。你发现没下次执行这个函数上次跑来的代码是不会重复执行的，</p><p>​但是你一般的return result 假如你在循环体提前return ,下面调这个函数是会从第一步开始重新执行的。不会记录上次执行的地方。</p><p>​<strong>转自CSDN :</strong> <a href="https://blog.csdn.net/qq_33060405/article/details/78484825">彻底搞懂C#之Yield Return语法的作用和好处_牛掰是怎么形成的的博客-CSDN博客_c# yield</a></p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C Sharp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C# 连接数据库</title>
    <link href="/2022/05/30/CSharp-%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2022/05/30/CSharp-%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="C-连接数据库"><a href="#C-连接数据库" class="headerlink" title="C# 连接数据库"></a>C# 连接数据库</h1><h2 id="c-连接数据库的步骤，和相关的方法调用"><a href="#c-连接数据库的步骤，和相关的方法调用" class="headerlink" title="c# 连接数据库的步骤，和相关的方法调用"></a>c# 连接数据库的步骤，和相关的方法调用</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//第一步：创建Connection 数据库连接对象</span><br>         SqlConnection conn = <span class="hljs-keyword">new</span> SqlConnection(<span class="hljs-string">&quot;server = . ; uid = sa ; pwd = jnos;database = JINGDONGDB&quot;</span>);<br>         <br><span class="hljs-comment">//第二步：打开连接数据库</span><br>         conn.Open();<br>         <br><span class="hljs-comment">//第三步：使用数据库，@符号表示可以换行，代码也连接在一起</span><br>         <span class="hljs-built_in">string</span> sql = <span class="hljs-string">$@&quot;select ProductNo, ProductName, ProductImage,</span><br><span class="hljs-string">        Price,password from Product where ProductNo=<span class="hljs-subst">&#123;_ProductNo&#125;</span>and</span><br><span class="hljs-string">         password=&#x27;<span class="hljs-subst">&#123;_password&#125;</span>&#x27;&quot;</span>;   <br>         <br>SqlCommand command = <span class="hljs-keyword">new</span> SqlCommand(sql,conn);<br>         SqlDataReader reader = command.ExecuteReader();<span class="hljs-comment">//</span><br><br><span class="hljs-comment">//在数据库里面是为  next（） 有数据为 true 没有数据为 flase</span><br>         <span class="hljs-keyword">if</span> (reader.Read())<br>         &#123;<br>             <span class="hljs-built_in">string</span> ProductNo = reader[<span class="hljs-string">&quot;ProductNo&quot;</span>].ToString();<br>             <span class="hljs-built_in">string</span> ProductName = reader[<span class="hljs-string">&quot;ProductName&quot;</span>].ToString();<br>             MessageBox.Show(<span class="hljs-string">$&quot;欢迎<span class="hljs-subst">&#123;ProductName&#125;</span>登录成功&quot;</span>);<br>         &#125;<br>         <span class="hljs-keyword">else</span><br>         &#123;<br>             MessageBox.Show(<span class="hljs-string">&quot;账号或密码错误，请重新输入！&quot;</span>);<br>         &#125;<br><br><br><br>         <span class="hljs-comment">//int resule = command.ExecuteNonQuery();//添加、删除、修改（返回行数受影响）接SqlCommand command = new SqlCommand(sql,conn);</span><br>                                                                 <span class="hljs-comment">//行 是添加删除修改的步骤</span><br>         <span class="hljs-comment">//object result = command.ExecuteScalar();//查询聚合函数用到</span><br>         <span class="hljs-comment">//if(resule &gt; 0)</span><br>         <span class="hljs-comment">//&#123;</span><br>         <span class="hljs-comment">//    MessageBox.Show(&quot;删除成功&quot;);</span><br>         <span class="hljs-comment">//&#125;</span><br>         <span class="hljs-comment">//else</span><br>         <span class="hljs-comment">//&#123;</span><br>         <span class="hljs-comment">//    MessageBox.Show(&quot;删除失败&quot;);</span><br>         <span class="hljs-comment">//&#125;</span><br>         <span class="hljs-comment">//第四步：关闭连接对象</span><br>         conn.Close();<br><br></code></pre></td></tr></table></figure><h3 id="相关的方法调用："><a href="#相关的方法调用：" class="headerlink" title="相关的方法调用："></a>相关的方法调用：</h3><p>command.ExecuteNonQuery：添加、删除、修改（返回行数受影响<br>command.ExecuteScalar：查询聚合函数<br>command.ExecuteReader：查询单列函数</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C# Array、ArrayList和List的区别</title>
    <link href="/2022/05/30/C%20Sharp%E4%B9%8BArray%E3%80%81ArrayList%E5%92%8CList%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/05/30/C%20Sharp%E4%B9%8BArray%E3%80%81ArrayList%E5%92%8CList%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="C-Array、ArrayList和List的区别"><a href="#C-Array、ArrayList和List的区别" class="headerlink" title="C#Array、ArrayList和List的区别"></a>C#Array、ArrayList和List的区别</h1><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><p>​<strong>Array</strong> 类是 C# 中所有数组的基类，它是在 System 命名空间中定义。Array 类提供了各种⽤于数组的属性和⽅法。<br>属性如： IsReadOnly数组只读。Length数组长度。<br>⽅法常⽤的如下： </p><ol><li><p><strong>Clear</strong><br>根据元素的类型，设置数组中某个范围的元素为零、为 false 或者为 null。 </p></li><li><p><strong>Copy(Array, Array, Int32)</strong><br>从数组的第⼀个元素开始复制某个范围的元素到另⼀个数组的第⼀个元素位置。长度由⼀个 32 位整数指定。 </p></li><li><p><strong>CopyTo(Array, Int32)</strong><br>从当前的⼀维数组中复制所有的元素到⼀个指定的⼀维数组的指定索引位置。索引由⼀个 32 位整数指定。 </p></li><li><p><strong>GetLength</strong><br>获取⼀个 32 位整数，该值表⽰指定维度的数组中的元素总数。 </p></li><li><p><strong>GetType</strong><br>获取当前实例的类型。从对象（Object）继承。 </p></li><li><p><strong>GetValue(Int32)</strong><br>获取⼀维数组中指定位置的值。索引由⼀个 32 位整数指定。 </p></li><li><p><strong>IndexOf(Array, Object)</strong><br>搜索指定的对象，返回整个⼀维数组中第⼀次出现的索引。 </p></li><li><p><strong>Reverse(Array)</strong><br>逆转整个⼀维数组中元素的顺序。 </p></li><li><p><strong>SetValue(Object, Int32)</strong><br>给⼀维数组中指定位置的元素设置值。索引由⼀个 32 位整数指定。</p></li><li><p><strong>Sort(Array)</strong><br>使⽤数组的每个元素的 IComparable 实现来排序整个⼀维数组中的元素。 </p></li><li><p><strong>ToString</strong><br>返回⼀个表⽰当前对象的字符串。从对象（Object）继承。</p></li></ol><p>使⽤⽅法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">int</span>[] nums = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span> &#125;;<br>Array.Sort(nums);<br></code></pre></td></tr></table></figure><hr><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>​<strong>ArrayList</strong>动态数组，是.Net Framework提供的⽤于数据存储和检索的专⽤类，它是命名空间System.Collections下的⼀部分。它的<br>⼤⼩是按照其中存储的数据来动态扩充与收缩的。所以，我们在声明ArrayList对象时并不需要指定它的长度。ArrayList继承了IList接⼝，<br>所以它可以很⽅便的进⾏数据的添加，插⼊和移除.比如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C#">ArrayList al = <span class="hljs-keyword">new</span> ArrayList();<br><span class="hljs-comment">//新增数据</span><br>al.Add(<span class="hljs-string">&quot;abc&quot;</span>); al.Add(<span class="hljs-number">123</span>);<br><span class="hljs-comment">//修改数据</span><br>al[<span class="hljs-number">2</span>] = <span class="hljs-number">345</span>;<br><span class="hljs-comment">//移除数据</span><br>al.RemoveAt(<span class="hljs-number">0</span>);<br><span class="hljs-comment">//插⼊数据</span><br>al.Insert(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;hello world&quot;</span>);<br></code></pre></td></tr></table></figure><hr><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>​在ArrayList中，我们不仅插⼊了字符串”abc”，⽽且⼜插⼊了数字123。这样在ArrayList中插⼊不同类型的数据是允许的。因为<br>ArrayList会把所有插⼊其中的数据都当作为object类型来处理。这样，在我们使⽤ArrayList中的数据来处理问题的时候，很可能会报类型<br>不匹配的错误，也就是说ArrayList不是类型安全的。既使我们保证在插⼊数据的时候都很小心，都有插⼊了同⼀类型的数据，但在使⽤的<br>时候，我们也需要将它们转化为对应的原类型来处理。这就存在了装箱与拆箱的操作，会带来很⼤的性能损耗。<br>　　正是因为ArrayList存在不安全类型与装箱拆箱的缺点，所以在C#2.0后出现了泛型的概念。⽽<strong>List</strong>类是ArrayList类的泛型等效类。它<br>的⼤部分⽤法都与ArrayList相似，因为List类也继承了IList接⼝。最关键的区别在于，在声明List集合时，我们同时需要为其声明List集合<br>内数据的对象类型。 比如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C#">List&lt;<span class="hljs-built_in">int</span>&gt; list = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;();<br><span class="hljs-comment">//新增数据</span><br> list.Add(<span class="hljs-number">123</span>);<br><span class="hljs-comment">//修改数据</span><br>list[<span class="hljs-number">0</span>] = <span class="hljs-number">345</span>;<br><span class="hljs-comment">//移除数据</span><br>list.RemoveAt(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>​上例中，如果我们往List泛型集合中插⼊string字符”hello world”，IDE就会报错，且不能通过编译。这样就避免了前⾯讲的类型安全问题与装箱拆箱的性能问题了。</p><p><strong>List泛型的好处：</strong><br>　　通过允许指定泛型类或⽅法操作的特定类型，泛型功能将类型安全的任务从您转移给了编译器。不需要编写代码来检测数据类型是否正确，因为会在编译时强制使⽤正确的数据类型。减少了类型强制转换的需要和运⾏时错误的可能性。泛型提供了类型安全但没有增加多个实现的开销。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p>三者都⽤来处理⼀组数据，继承了IEnumerable接⼝，可⽤于for循环处理。都可以通过索引下标进⾏获取和设置元素。</p></li><li><p>Array在内存中是连续的，长度固定，⽆法删除和增加新的元素。⽽ArrayList或List的容量可根据需要⾃动插⼊和删除元素。</p></li><li><p>Array可以具有多个维度，⽽ ArrayList或 List&lt; T&gt; 始终只具有⼀个维度。但是，您可以轻松创建数组列表或列表的列表。</p></li><li><p>特定类型（Object 除外）的数组 的性能优于 ArrayList的性能。 这是因为 ArrayList的元素属于 Object 类型；所以在存储或检索值类型时通常发⽣装箱和拆箱操作。不过，在不需要重新分配时（即最初的容量⼗分接近列表的最⼤容量），List&lt; T&gt; 的性能与同类型的数组⼗分相近。</p></li><li><p>在决定使⽤ List 还是使⽤ArrayList 类（两者具有类似的功能）时，记住List 类在⼤多数情况下执⾏得更好并且是类型安全的。如果对<br>List&lt; T&gt; 类的类型T 使⽤引⽤类型，则两个类的⾏为是完全相同的。但是，如果对类型T使⽤值类型，则需要考虑实现和装箱问题。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C Sharp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/05/29/hello-world/"/>
    <url>/2022/05/29/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
