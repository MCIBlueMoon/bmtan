<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C# 之Yield Return语法的作用和好处</title>
    <link href="/2022/05/31/C%20Sharp%E4%B9%8BYield%20Return%E8%AF%AD%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%A5%BD%E5%A4%84/"/>
    <url>/2022/05/31/C%20Sharp%E4%B9%8BYield%20Return%E8%AF%AD%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%A5%BD%E5%A4%84/</url>
    
    <content type="html"><![CDATA[<p>首先我贴出平时正常输出偶数集合的办法</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  学习Yield Return 语法</span><br><span class="hljs-comment"> *  使用两个方法，显示1 - 100之间的全部偶数</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">YieldReturn</span>语法解析<br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>       <span class="hljs-keyword">static</span>  <span class="hljs-keyword">private</span> List&lt;<span class="hljs-built_in">int</span>&gt; _numArray; <span class="hljs-comment">//用来保存1-100 这100个整数</span><br><br>        Program() <span class="hljs-comment">//构造函数。我们可以通过这个构造函数往待测试集合中存入1-100这100个测试数据</span><br>        &#123;<br>            _numArray = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;(); <span class="hljs-comment">//给集合变量开始在堆内存上开内存，并且把内存首地址交给这个_numArray变量</span><br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; i++) <br>            &#123;<br>                _numArray.Add(i);  <span class="hljs-comment">//把1到100保存在集合当中方便操作</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">new</span> Program();<br><br>            TestMethod();<br><br><br>        &#125;<br><br>        <span class="hljs-comment">//测试求1到100之间的全部偶数</span><br>        <span class="hljs-function"><span class="hljs-keyword">static</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TestMethod</span>()</span><br>        &#123;<br>            <span class="hljs-keyword">foreach</span> (<span class="hljs-function"><span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> <span class="hljs-title">GetAllEvenNumber</span>())</span> <br>            &#123;<br>                Console.WriteLine(item); <span class="hljs-comment">//输出偶数测试</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//测试我们正常情况下拿到全部偶数的方法</span><br>       <span class="hljs-function"><span class="hljs-keyword">static</span>  IEnumerable&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-title">GetAllEvenNumber</span>()</span><br>        &#123;<br>            List&lt;<span class="hljs-built_in">int</span>&gt; result = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;(); <span class="hljs-comment">//开集合内存存偶数用</span><br><br>            <span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">int</span> num <span class="hljs-keyword">in</span> _numArray) <br>            &#123;<br>                <span class="hljs-keyword">if</span>(num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) <span class="hljs-comment">//判断是不是偶数</span><br>                &#123;<br>                    <span class="hljs-comment">//yield return num;</span><br>                    result.Add(num); <span class="hljs-comment">//存入集合</span><br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">//返回偶数集合变量   可能有人会觉得奇怪返回类型不是List&lt;int&gt;这样可以吗</span><br>            <span class="hljs-comment">//这个就要回到我们的里氏替换原则了，子类是可以替换父类的，也就是当父类用</span><br>            <span class="hljs-comment">//比如我这个方法是想得到IEnumerable&lt;int&gt; 类型变量，但是我给了List&lt;int&gt;类型变量</span><br>            <span class="hljs-comment">//注意List&lt;int&gt; 是继承 IEnumerable&lt;int&gt; 的，什么意思当我们把子类当父类使用，</span><br>            <span class="hljs-comment">//那么大才小用，因为子类很多都是继承父亲，你自身增加很多字段或者方法，这样就不能用了。</span><br>            <span class="hljs-keyword">return</span> result;  <br>            <span class="hljs-comment">//yield break;</span><br>        &#125;<br><br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>贴出使用Yiele Return办法输出耦合集合</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  学习Yield Return 语法</span><br><span class="hljs-comment"> *  使用两个方法，显示1 - 100之间的全部偶数</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">YieldReturn</span>语法解析<br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>       <span class="hljs-keyword">static</span>  <span class="hljs-keyword">private</span> List&lt;<span class="hljs-built_in">int</span>&gt; _numArray; <span class="hljs-comment">//用来保存1-100 这100个整数</span><br><br>        Program() <span class="hljs-comment">//构造函数。我们可以通过这个构造函数往待测试集合中存入1-100这100个测试数据</span><br>        &#123;<br>            _numArray = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;(); <span class="hljs-comment">//给集合变量开始在堆内存上开内存，并且把内存首地址交给这个_numArray变量</span><br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; i++) <br>            &#123;<br>                _numArray.Add(i);  <span class="hljs-comment">//把1到100保存在集合当中方便操作</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">new</span> Program();<br><br>            TestMethod();<br><br><br>        &#125;<br><br>        <span class="hljs-comment">//测试求1到100之间的全部偶数</span><br>        <span class="hljs-function"><span class="hljs-keyword">static</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TestMethod</span>()</span><br>        &#123;<br>            <span class="hljs-keyword">foreach</span> (<span class="hljs-function"><span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> <span class="hljs-title">GetAllEvenNumber</span>())</span> <br>            &#123;<br>                Console.WriteLine(item); <span class="hljs-comment">//输出偶数测试</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//测试我们使用Yield Return情况下拿到全部偶数的方法</span><br>       <span class="hljs-function"><span class="hljs-keyword">static</span>  IEnumerable&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-title">GetAllEvenNumber</span>()</span><br>        &#123;<br><br>            <span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">int</span> num <span class="hljs-keyword">in</span> _numArray) <br>            &#123;<br>                <span class="hljs-keyword">if</span>(num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) <span class="hljs-comment">//判断是不是偶数</span><br>                &#123;<br>                    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> num; <span class="hljs-comment">//返回当前偶数</span><br><br>                &#125;<br>            &#125;        <br>            <span class="hljs-keyword">yield</span> <span class="hljs-keyword">break</span>;  <span class="hljs-comment">//当前集合已经遍历完毕，我们就跳出当前函数，其实你不加也可以</span><br>            <span class="hljs-comment">//这个作用就是提前结束当前函数，就是说这个函数运行完毕了。</span><br>        &#125;<br><br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>​大家测试了2个代码结果没，是不是都可以正确拿到全部偶数集合，具体我需要你们测，这样进步快，才会真是学会。只看不练假把戏。</p><p>​现在我们说他们的区别：<br>​这个才是真正要学的地方<br>​我们需要下断点</p><p><img src="G:\BlogPhoto\5-31\5-31-1\5-31-1-1.png" alt="5-31-1-1"></p><p>​我希望你是在断点调试，具体就贴太多，你会发现代码跑到Yield return num的时候，当前函数就会结束，并把这个num交给这里，我先上图</p><p><img src="G:\BlogPhoto\5-31\5-31-1\5-31-1-2.png" alt="这里写图片描述"></p><p>​最终会给item变量。<br>​然后输出，然后在执行 GetAllEvenNumber（）方法，和上次得到偶数是一样。<br>​我们发现这个Yield Return是可以让当前函数的进程状态切换到阻塞状态，然后去选择了把cpu交给当前的出进程，这样就转而执行调用方函数。 （补充个小知识点其实我们写的程序加入到内存中，并不定就是一个进程，我们会根据情况分成几个子进程去干活，方便操作系统去管理以及多道程序运行在内存，提高计算机资源的利用率）<br>​这样有个好处，我们假如有1000000个数据，我们需要得到里面的耦合，当我们通过这个方法得到一个耦合会立马显示在控制台上。而不是等很久也就把全部偶数都查找到存入集合当中，然后在一一遍历输出。<br>​这个好处是很大的。比如我们用户可能就看数据开始肯定不是全部值需要部分就可以，看完这些在看后面的，这样数据会让觉得显示没有延迟。</p><p>​下面我们来断点调一般的查找偶数的函数</p><p><img src="G:\BlogPhoto\5-31\5-31-1\5-31-1-3.png" alt="5-31-1-3"></p><p>​我们发现这个循环没有跑完是不会退出当前函数的，也就是必须要查找全部的偶数才可以。这样假如我们很多数据。就会一直等这个数据才可以拿到这个数据去显示给用户看。<br>这样就麻烦了。</p><p>​因此我们下个结论：Yield Return关键字的作用就是退出当前函数，并且会保存当前函数执行到什么地方，也就上下文。你发现没下次执行这个函数上次跑来的代码是不会重复执行的，</p><p>​但是你一般的return result 假如你在循环体提前return ,下面调这个函数是会从第一步开始重新执行的。不会记录上次执行的地方。</p><p>​<strong>转自CSDN :</strong> <a href="https://blog.csdn.net/qq_33060405/article/details/78484825">彻底搞懂C#之Yield Return语法的作用和好处_牛掰是怎么形成的的博客-CSDN博客_c# yield</a></p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C Sharp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C# Array、ArrayList和List的区别</title>
    <link href="/2022/05/30/C%20Sharp%E4%B9%8BArray%E3%80%81ArrayList%E5%92%8CList%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/05/30/C%20Sharp%E4%B9%8BArray%E3%80%81ArrayList%E5%92%8CList%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="C-Array、ArrayList和List的区别"><a href="#C-Array、ArrayList和List的区别" class="headerlink" title="C#Array、ArrayList和List的区别"></a>C#Array、ArrayList和List的区别</h1><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><p>​<strong>Array</strong> 类是 C# 中所有数组的基类，它是在 System 命名空间中定义。Array 类提供了各种⽤于数组的属性和⽅法。<br>属性如： IsReadOnly数组只读。Length数组长度。<br>⽅法常⽤的如下： </p><ol><li><p><strong>Clear</strong><br>根据元素的类型，设置数组中某个范围的元素为零、为 false 或者为 null。 </p></li><li><p><strong>Copy(Array, Array, Int32)</strong><br>从数组的第⼀个元素开始复制某个范围的元素到另⼀个数组的第⼀个元素位置。长度由⼀个 32 位整数指定。 </p></li><li><p><strong>CopyTo(Array, Int32)</strong><br>从当前的⼀维数组中复制所有的元素到⼀个指定的⼀维数组的指定索引位置。索引由⼀个 32 位整数指定。 </p></li><li><p><strong>GetLength</strong><br>获取⼀个 32 位整数，该值表⽰指定维度的数组中的元素总数。 </p></li><li><p><strong>GetType</strong><br>获取当前实例的类型。从对象（Object）继承。 </p></li><li><p><strong>GetValue(Int32)</strong><br>获取⼀维数组中指定位置的值。索引由⼀个 32 位整数指定。 </p></li><li><p><strong>IndexOf(Array, Object)</strong><br>搜索指定的对象，返回整个⼀维数组中第⼀次出现的索引。 </p></li><li><p><strong>Reverse(Array)</strong><br>逆转整个⼀维数组中元素的顺序。 </p></li><li><p><strong>SetValue(Object, Int32)</strong><br>给⼀维数组中指定位置的元素设置值。索引由⼀个 32 位整数指定。</p></li><li><p><strong>Sort(Array)</strong><br>使⽤数组的每个元素的 IComparable 实现来排序整个⼀维数组中的元素。 </p></li><li><p><strong>ToString</strong><br>返回⼀个表⽰当前对象的字符串。从对象（Object）继承。</p></li></ol><p>使⽤⽅法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">int</span>[] nums = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span> &#125;;<br>Array.Sort(nums);<br></code></pre></td></tr></table></figure><hr><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>​<strong>ArrayList</strong>动态数组，是.Net Framework提供的⽤于数据存储和检索的专⽤类，它是命名空间System.Collections下的⼀部分。它的<br>⼤⼩是按照其中存储的数据来动态扩充与收缩的。所以，我们在声明ArrayList对象时并不需要指定它的长度。ArrayList继承了IList接⼝，<br>所以它可以很⽅便的进⾏数据的添加，插⼊和移除.比如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C#">ArrayList al = <span class="hljs-keyword">new</span> ArrayList();<br><span class="hljs-comment">//新增数据</span><br>al.Add(<span class="hljs-string">&quot;abc&quot;</span>); al.Add(<span class="hljs-number">123</span>);<br><span class="hljs-comment">//修改数据</span><br>al[<span class="hljs-number">2</span>] = <span class="hljs-number">345</span>;<br><span class="hljs-comment">//移除数据</span><br>al.RemoveAt(<span class="hljs-number">0</span>);<br><span class="hljs-comment">//插⼊数据</span><br>al.Insert(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;hello world&quot;</span>);<br></code></pre></td></tr></table></figure><hr><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>​在ArrayList中，我们不仅插⼊了字符串”abc”，⽽且⼜插⼊了数字123。这样在ArrayList中插⼊不同类型的数据是允许的。因为<br>ArrayList会把所有插⼊其中的数据都当作为object类型来处理。这样，在我们使⽤ArrayList中的数据来处理问题的时候，很可能会报类型<br>不匹配的错误，也就是说ArrayList不是类型安全的。既使我们保证在插⼊数据的时候都很小心，都有插⼊了同⼀类型的数据，但在使⽤的<br>时候，我们也需要将它们转化为对应的原类型来处理。这就存在了装箱与拆箱的操作，会带来很⼤的性能损耗。<br>　　正是因为ArrayList存在不安全类型与装箱拆箱的缺点，所以在C#2.0后出现了泛型的概念。⽽<strong>List</strong>类是ArrayList类的泛型等效类。它<br>的⼤部分⽤法都与ArrayList相似，因为List类也继承了IList接⼝。最关键的区别在于，在声明List集合时，我们同时需要为其声明List集合<br>内数据的对象类型。 比如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C#">List&lt;<span class="hljs-built_in">int</span>&gt; list = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;();<br><span class="hljs-comment">//新增数据</span><br> list.Add(<span class="hljs-number">123</span>);<br><span class="hljs-comment">//修改数据</span><br>list[<span class="hljs-number">0</span>] = <span class="hljs-number">345</span>;<br><span class="hljs-comment">//移除数据</span><br>list.RemoveAt(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>​上例中，如果我们往List泛型集合中插⼊string字符”hello world”，IDE就会报错，且不能通过编译。这样就避免了前⾯讲的类型安全问题与装箱拆箱的性能问题了。</p><p><strong>List泛型的好处：</strong><br>　　通过允许指定泛型类或⽅法操作的特定类型，泛型功能将类型安全的任务从您转移给了编译器。不需要编写代码来检测数据类型是否正确，因为会在编译时强制使⽤正确的数据类型。减少了类型强制转换的需要和运⾏时错误的可能性。泛型提供了类型安全但没有增加多个实现的开销。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p>三者都⽤来处理⼀组数据，继承了IEnumerable接⼝，可⽤于for循环处理。都可以通过索引下标进⾏获取和设置元素。</p></li><li><p>Array在内存中是连续的，长度固定，⽆法删除和增加新的元素。⽽ArrayList或List的容量可根据需要⾃动插⼊和删除元素。</p></li><li><p>Array可以具有多个维度，⽽ ArrayList或 List&lt; T&gt; 始终只具有⼀个维度。但是，您可以轻松创建数组列表或列表的列表。</p></li><li><p>特定类型（Object 除外）的数组 的性能优于 ArrayList的性能。 这是因为 ArrayList的元素属于 Object 类型；所以在存储或检索值类型时通常发⽣装箱和拆箱操作。不过，在不需要重新分配时（即最初的容量⼗分接近列表的最⼤容量），List&lt; T&gt; 的性能与同类型的数组⼗分相近。</p></li><li><p>在决定使⽤ List 还是使⽤ArrayList 类（两者具有类似的功能）时，记住List 类在⼤多数情况下执⾏得更好并且是类型安全的。如果对<br>List&lt; T&gt; 类的类型T 使⽤引⽤类型，则两个类的⾏为是完全相同的。但是，如果对类型T使⽤值类型，则需要考虑实现和装箱问题。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C Sharp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/05/29/hello-world/"/>
    <url>/2022/05/29/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
