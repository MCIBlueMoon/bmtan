<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C# 设计模式</title>
    <link href="/2022/07/30/AssetBundle%20%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD/"/>
    <url>/2022/07/30/AssetBundle%20%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="AssetBundle-同步与异步加载"><a href="#AssetBundle-同步与异步加载" class="headerlink" title="AssetBundle 同步与异步加载"></a>AssetBundle 同步与异步加载</h1><h2 id="AssetBundle相关Api"><a href="#AssetBundle相关Api" class="headerlink" title="AssetBundle相关Api"></a>AssetBundle相关Api</h2><h3 id="AssetBundle-LoadAsset"><a href="#AssetBundle-LoadAsset" class="headerlink" title="AssetBundle.LoadAsset"></a><a href="https://docs.unity.cn/cn/2022.1/ScriptReference/AssetBundle.html">AssetBundle</a>.LoadAsset</h3><p>public Object <strong>LoadAsset</strong> (string <strong>name</strong>);</p><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>从捆绑包中加载名为 <code>name</code> 的资源。</p><p>您应该准确指定 AssetBundleBuild 对象中的名称，即对象的相对路径加文件扩展名。</p><p>在版本 5.0 之前，用户可以使用 Load 直接获取单个组件。该函数现已弃用。请改为使用 LoadAsset 加载游戏对象，然后在对象上查找组件。</p><hr><p>public Object <strong>LoadAsset</strong> (string <strong>name</strong>, Type <strong>type</strong>);</p><hr><h3 id="AssetBundleManifest-GetAllDependencies"><a href="#AssetBundleManifest-GetAllDependencies" class="headerlink" title="AssetBundleManifest.GetAllDependencies"></a><a href="https://docs.unity.cn/cn/2022.1/ScriptReference/AssetBundleManifest.html">AssetBundleManifest</a>.GetAllDependencies</h3><p>public string[] <strong>GetAllDependencies</strong> (string <strong>assetBundleName</strong>);</p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><table><thead><tr><th>assetBundleName</th><th>资源捆绑包的名称。</th></tr></thead></table><h4 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h4><p>获取给定 AssetBundle 的所有依赖 AssetBundle。</p><hr><h3 id="AssetBundle-Unload"><a href="#AssetBundle-Unload" class="headerlink" title="AssetBundle.Unload"></a><a href="https://docs.unity.cn/cn/2022.1/ScriptReference/AssetBundle.html">AssetBundle</a>.Unload</h3><p>public void <strong>Unload</strong> (bool <strong>unloadAllLoadedObjects</strong>);</p><h4 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h4><table><thead><tr><th>unloadAllLoadedObjects</th><th>确定是否还将卸载从 AssetBundle 加载的对象的当前实例。</th></tr></thead></table><h4 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h4><p>卸载 AssetBundle 释放其数据。</p><p>When <code>unloadAllLoadedObjects</code> is false, compressed file data inside the bundle itself will be freed, but any instances of objects loaded from this bundle will remain intact. After calling UnloadAsync on an AssetBundle, you cannot load any more objects from that bundle and other operations on the bundle will throw InvalidOperationException.After calling UnloadAsync on an AssetBundle, you cannot load any more objects from that bundle and other operations on the bundle will throw InvalidOperationException.</p><p>当 <code>unloadAllLoadedObjects</code> 为 true 时，也将销毁从该捆绑包加载的所有对象。如果场景中有 GameObjects 引用这些资源，则对它们的引用将丢失。</p><p>不管是哪种情况，除非重新加载该捆绑包，否则将无法再从它加载任何其他对象。</p><p>有关所使用的不同压缩格式及其在加载时对内存的影响的说明，请参阅<a href="https://docs.unity.cn/cn/2022.1/Manual/AssetBundles-Building.html">构建 AssetBundle</a>。</p><p>另请参阅：<a href="https://docs.unity.cn/cn/2022.1/ScriptReference/AssetBundle.UnloadAllAssetBundles.html">AssetBundle.UnloadAllAssetBundles</a>。</p><hr><h3 id="AssetBundle-UnloadAllAssetBundles"><a href="#AssetBundle-UnloadAllAssetBundles" class="headerlink" title="AssetBundle.UnloadAllAssetBundles"></a><a href="https://docs.unity.cn/cn/2022.1/ScriptReference/AssetBundle.html">AssetBundle</a>.UnloadAllAssetBundles</h3><p>public static void <strong>UnloadAllAssetBundles</strong> (bool <strong>unloadAllObjects</strong>);</p><h4 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h4><table><thead><tr><th>unloadAllObjects</th><th>确定是否还将卸载从 AssetBundle 加载的对象的当前实例。</th></tr></thead></table><h4 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h4><p>卸载当前已加载的所有 AssetBundle。</p><p>当 <code>unloadAllObjects</code> 为 false 时，将释放当前加载的捆绑包中的压缩文件数据，但已从捆绑包中加载的任何对象实例将保持不变。</p><p>当 <code>unloadAllObjects</code> 为 true 时，也将销毁从当前已加载的捆绑包加载的所有对象。如果场景中有 GameObject 引用这些资源，则对它们的引用将丢失。</p><p>不管是哪种情况，除非重新加载当前已加载的捆绑包，否则无法再从它们加载任何其他对象。</p><p>有关所使用的不同压缩格式及其在加载时对内存的影响的说明，请参阅<a href="https://docs.unity.cn/cn/2022.1/Manual/AssetBundles-Building.html">构建 AssetBundle</a>。</p><p>另请参阅：<a href="https://docs.unity.cn/cn/2022.1/ScriptReference/AssetBundle.Unload.html">AssetBundle.Unload</a>。</p><hr><h2 id="AB包管理器"><a href="#AB包管理器" class="headerlink" title="AB包管理器"></a>AB包管理器</h2><p><strong>目的</strong>：让外部更方便的进行资源加载</p><blockquote><p>声明AssetBundle、AssetBundleManifest和字典存储加载过的ab包</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//主包</span><br>   <span class="hljs-keyword">private</span> AssetBundle mainAB = <span class="hljs-literal">null</span>;<br>   <span class="hljs-comment">//依赖包获取用的配置文件</span><br>   <span class="hljs-keyword">private</span> AssetBundleManifest manifest = <span class="hljs-literal">null</span>;<br><br><span class="hljs-comment">//AB包不能重复加载 重复会报错</span><br>   <span class="hljs-comment">//字典 用字典来存储 加载过的ab包</span><br>   <span class="hljs-keyword">private</span> Dictionary&lt;<span class="hljs-built_in">string</span>, AssetBundle&gt; abDic = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">string</span>, AssetBundle&gt;();<br></code></pre></td></tr></table></figure><blockquote><p>PathUrl 和 MainABName 属性 方便获取路径和主包名</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> PathUrl<br>    &#123;<br>        <span class="hljs-keyword">get</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> Application.streamingAssetsPath + <span class="hljs-string">&quot;/&quot;</span>;<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 主包名 方便修改</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> MainABName<br>    &#123;<br>        <span class="hljs-keyword">get</span><br>        &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> UNITY_IOS</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;IOS&quot;</span><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> UNITY_ANDROID</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Android&quot;</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;PC&quot;</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p>LoadAB 用于加载AB包、获取依赖包相关信息、加载资源来源包等共同操作</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LoadAB</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> abName</span>)</span><br>    &#123;<br>        <span class="hljs-comment">//加载AB包</span><br>        <span class="hljs-keyword">if</span> (mainAB == <span class="hljs-literal">null</span>)<br>        &#123;<br>            mainAB = AssetBundle.LoadFromFile(PathUrl + MainABName);<br>            manifest = mainAB.LoadAsset&lt;AssetBundleManifest&gt;(<span class="hljs-string">&quot;AssetBundleManifest&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//我们获取依赖包的相关信息</span><br>        <span class="hljs-built_in">string</span>[] strs = manifest.GetAllDependencies(abName);<br>        AssetBundle ab = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; strs.Length; i++)<br>        &#123;<br>            <span class="hljs-comment">//判断包是否加载过</span><br>            <span class="hljs-keyword">if</span> (!abDic.ContainsKey(strs[i]))<br>            &#123;<br>                ab = AssetBundle.LoadFromFile(PathUrl + strs[i]);<br>                abDic.Add(strs[i], ab);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//加载资源来源包</span><br>        <span class="hljs-comment">//如果没有加载过 再加载</span><br>        <span class="hljs-keyword">if</span> (!abDic.ContainsKey(abName))<br>        &#123;<br>            ab = AssetBundle.LoadFromFile(PathUrl + abName);<br>            abDic.Add(abName, ab);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="同步加载"><a href="#同步加载" class="headerlink" title="同步加载"></a>同步加载</h2><h3 id="同步加载-1"><a href="#同步加载-1" class="headerlink" title="同步加载"></a>同步加载</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//同步加载</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">LoadRes</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> abName, <span class="hljs-built_in">string</span> resName</span>)</span><br>    &#123;<br>        <span class="hljs-comment">//加载AB包</span><br>        LoadAB(abName);<br><br>        <span class="hljs-comment">//为了外面方便 在加载资源时 判断一下 资源是不是GameObject</span><br>        <span class="hljs-comment">//如果是 直接实例化 再返回给外部</span><br><br><br>        Object obj = abDic[abName].LoadAsset(resName);<br>        <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">is</span> GameObject)<br>            <span class="hljs-keyword">return</span> Instantiate(obj);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> obj;<br>        <br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="同步加载-通过type指定类型"><a href="#同步加载-通过type指定类型" class="headerlink" title="同步加载 通过type指定类型"></a>同步加载 通过type指定类型</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">LoadRes</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> abName, <span class="hljs-built_in">string</span> resName,System.Type type</span>)</span><br>    &#123;<br>        <span class="hljs-comment">//加载AB包</span><br>        LoadAB(abName);<br><br>        <span class="hljs-comment">//为了外面方便 在加载资源时 判断一下 资源是不是GameObject</span><br>        <span class="hljs-comment">//如果是 直接实例化 再返回给外部</span><br><br><br>        Object obj = abDic[abName].LoadAsset(resName,type);<br>        <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">is</span> GameObject)<br>            <span class="hljs-keyword">return</span> Instantiate(obj);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> obj;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="同步加载，根据泛型指定类型"><a href="#同步加载，根据泛型指定类型" class="headerlink" title="同步加载，根据泛型指定类型"></a>同步加载，根据泛型指定类型</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//同步加载，根据泛型指定类型</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">LoadRes</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-built_in">string</span> abName, <span class="hljs-built_in">string</span> resName</span>) <span class="hljs-keyword">where</span> T:Object</span><br>    &#123;<br>        <span class="hljs-comment">//加载AB包</span><br>        LoadAB(abName);<br><br>        <span class="hljs-comment">//为了外面方便 在加载资源时 判断一下 资源是不是GameObject</span><br>        <span class="hljs-comment">//如果是 直接实例化 再返回给外部</span><br><br><br>        T obj = abDic[abName].LoadAsset&lt;T&gt;(resName);<br>        <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">is</span> GameObject)<br>            <span class="hljs-keyword">return</span> Instantiate(obj);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> obj;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="异步加载"><a href="#异步加载" class="headerlink" title="异步加载"></a>异步加载</h2><p><font color="FF0000"><b>！！！ 这里的异步加载 AB包并没有使用异步加载，只是从AB包中 加载资源时 使用异步</b></font></p><h3 id="根据名字异步加载"><a href="#根据名字异步加载" class="headerlink" title="根据名字异步加载"></a>根据名字异步加载</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LoadResAsync</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> abName,<span class="hljs-built_in">string</span> resName,UnityAction&lt;Object&gt; callBack</span>)</span><br>    &#123;<br>        StartCoroutine(ReallyLoadResAsync(abName, resName, callBack));<br>    &#125;  <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> IEnumerator <span class="hljs-title">ReallyLoadResAsync</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> abName, <span class="hljs-built_in">string</span> resName, UnityAction&lt;Object&gt; callBack</span>)</span><br>    &#123;<br>        <span class="hljs-comment">//加载AB包</span><br>        LoadAB(abName);<br><br>        <span class="hljs-comment">//为了外面方便 在加载资源时 判断一下 资源是不是GameObject</span><br>        <span class="hljs-comment">//如果是 直接实例化 再返回给外部</span><br>        AssetBundleRequest abr = abDic[abName].LoadAssetAsync(resName);<br>        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> abr;<br>        <span class="hljs-comment">//异步加载结束后 通过委托 传递给外部 外部来使用</span><br>        <span class="hljs-keyword">if</span> (abr.asset <span class="hljs-keyword">is</span> GameObject)<br>            callBack(Instantiate(abr.asset));<br>        <span class="hljs-keyword">else</span><br>            callBack(abr.asset);<br>        <br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="根据Type异步加载"><a href="#根据Type异步加载" class="headerlink" title="根据Type异步加载"></a>根据Type异步加载</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//根据Type异步加载</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LoadResAsync</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> abName, <span class="hljs-built_in">string</span> resName,System.Type type, UnityAction&lt;Object&gt; callBack</span>)</span><br>    &#123;<br>        StartCoroutine(ReallyLoadResAsync(abName, resName, callBack));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> IEnumerator <span class="hljs-title">ReallyLoadResAsync</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> abName, <span class="hljs-built_in">string</span> resName,System.Type type, UnityAction&lt;Object&gt; callBack</span>)</span><br>    &#123;<br>        <span class="hljs-comment">//加载AB包</span><br>        LoadAB(abName);<br><br>        <span class="hljs-comment">//为了外面方便 在加载资源时 判断一下 资源是不是GameObject</span><br>        <span class="hljs-comment">//如果是 直接实例化 再返回给外部</span><br>        AssetBundleRequest abr = abDic[abName].LoadAssetAsync(resName,type);<br>        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> abr;<br>        <span class="hljs-comment">//异步加载结束后 通过委托 传递给外部 外部来使用</span><br>        <span class="hljs-keyword">if</span> (abr.asset <span class="hljs-keyword">is</span> GameObject)<br>            callBack(Instantiate(abr.asset));<br>        <span class="hljs-keyword">else</span><br>            callBack(abr.asset);<br><br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="根据泛型异步加载"><a href="#根据泛型异步加载" class="headerlink" title="根据泛型异步加载"></a>根据泛型异步加载</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LoadResAsync</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-built_in">string</span> abName, <span class="hljs-built_in">string</span> resName, UnityAction&lt;T&gt; callBack</span>) <span class="hljs-keyword">where</span> T:Object</span><br>    &#123;<br>        StartCoroutine(ReallyLoadResAsync(abName, resName, callBack));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> IEnumerator <span class="hljs-title">ReallyLoadResAsync</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-built_in">string</span> abName, <span class="hljs-built_in">string</span> resName, UnityAction&lt;T&gt; callBack</span>) <span class="hljs-keyword">where</span> T : Object</span><br>    &#123;<br>        <span class="hljs-comment">//加载AB包</span><br>        LoadAB(abName);<br><br>        <span class="hljs-comment">//为了外面方便 在加载资源时 判断一下 资源是不是GameObject</span><br>        <span class="hljs-comment">//如果是 直接实例化 再返回给外部</span><br>        AssetBundleRequest abr = abDic[abName].LoadAssetAsync&lt;T&gt;(resName);<br>        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> abr;<br>        <span class="hljs-comment">//异步加载结束后 通过委托 传递给外部 外部来使用</span><br>        <span class="hljs-keyword">if</span> (abr.asset <span class="hljs-keyword">is</span> GameObject)<br>            callBack(Instantiate(abr.asset) <span class="hljs-keyword">as</span> T);<br>        <span class="hljs-keyword">else</span><br>            callBack(abr.asset <span class="hljs-keyword">as</span> T);<br><br>    &#125;<br></code></pre></td></tr></table></figure><hr><h2 id="包卸载"><a href="#包卸载" class="headerlink" title="包卸载"></a>包卸载</h2><h3 id="单个包卸载"><a href="#单个包卸载" class="headerlink" title="单个包卸载"></a>单个包卸载</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">UnLoad</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> abName</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(abDic.ContainsKey(abName))<br>        &#123;<br>            abDic[abName].Unload(<span class="hljs-literal">false</span>);<br>            abDic.Remove(abName);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="所有包卸载"><a href="#所有包卸载" class="headerlink" title="所有包卸载"></a>所有包卸载</h3><pre><code class="C#">public void ClearAB()    &#123;        AssetBundle.UnloadAllAssetBundles(false);        abDic.Clear();        mainAB = null;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>热更新</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AssetBundle</tag>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C# 设计模式</title>
    <link href="/2022/06/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/06/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="C-设计模式"><a href="#C-设计模式" class="headerlink" title="C#设计模式"></a>C#设计模式</h1><h2 id="设计模式概述"><a href="#设计模式概述" class="headerlink" title="设计模式概述"></a>设计模式概述</h2><p>设计模式共<strong>23</strong>种。主要分为三部分：创建型模式、机构型模式、行为型模式。</p><p><strong>创建型模式：</strong>所有的模式都涉及到创建对象实例的方式。</p><p><strong>结构型模式：</strong>如何组合类和对象以获得更大的结构。</p><p><strong>行为型模式：</strong>通常和对象之间的通信有关。</p><p><strong>创建型模式：简单工厂模式、工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式</strong></p><p>工厂方法：提供了一个简单的决策类，它根据提供的数据返回一个抽象基类的多个子类中的一个。</p><p>抽象工厂：提供了一个创建并返回一些列相关对象的接口。</p><p>单例：某个类只能有一个实例。它提供了一个访问该实例的全局访问点。</p><p>建造者：将一个复杂的构建与它的表示分开，这样就能根据程序的需要创建不同的表现形式。</p><p>原型：先实例化一个类，然后拷贝或克隆该类来创建新的实例，可以用公有方法进一步修改这些实例。</p><p><strong>结构型模式：适配器模式、桥接模式、组合模式、装饰模式、外观模式、享元模式、代理模式</strong></p><p>适配器：将一个类的接口传换成另一个类的接口。</p><p>桥接：可以将一个类的接口与它的实现分离，这样可以不用修改客户端代码就能改变或替换实现过程。</p><p>组合：是一个对象的集合，其中的任何一个对象既可以是一个组合，也可以只是一个叶子对象。</p><p>装饰：用一个类包装给定的类，并为它添加新的功能，将所有未改动的方法传递给下面的类。</p><p>外观：将一系列复杂的对象放在一起，并提供一个新的、更简单的访问这些数据的接口。</p><p>享元：把一部分的类数据移到类外部，在执行方法时将数据传递进来，通过这种方式限制那些又小又相似的实例的增加数量。</p><p>代理：为一个比较复杂的对象提供一个简单的占位对象，实例化该复杂对象，在某种程度上比较浪费时间或代价较高。</p><p><strong>行为型模式：职责链、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、模板方法模式、访问者模式</strong></p><p>职责链：把请求从链中的一个对象传递到下一个对象，直到请求被响应为止。通过这种方式在对象之间去除耦合。</p><p>命令：用简单的对象表示软件命令的执行，支持登陆和取消操作。</p><p>解释器：提供一个如何把语言元素包含在程序中的定义。</p><p>迭代器：提供了一种顺序访问一个类中的一系列数据的方式。</p><p>中介者：定义了如何用一个对象简化对象之间的通信，是对象之间不必相互了解。</p><p>备忘录：定义了如何保存一个类实例的内容以便以后能恢复它。</p><p>观察者：定义了一种把改动通知给多个对象的方式。</p><p>状态：允许一个对象在其内部状态改变时修改它的行为。</p><p>策略：将算法封装到类里。</p><p>模板方法：提供了算法的抽象定义。</p><p>访问者：在不改变类的前提下，为一个类添加多种操作。</p><hr><h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/UML%E4%BD%BF%E7%94%A8.png"></p><p><strong>注意:</strong></p><p>“+”表示public，”-“表示private，”#”表示protected</p><p>空心三角形+实线表示实现<strong>继承</strong></p><p>空心三角形+虚线表示实现<strong>接口</strong></p><p><strong>关联关系</strong>用实线箭头</p><p><strong>聚合关系</strong>用空心菱形+实线箭头</p><p><strong>依赖关系</strong>用虚线箭头</p><hr><h2 id="面向对象六大原则"><a href="#面向对象六大原则" class="headerlink" title="面向对象六大原则"></a>面向对象六大原则</h2><h4 id="①-单一职责原则"><a href="#①-单一职责原则" class="headerlink" title="① 单一职责原则"></a>① 单一职责原则</h4><p><strong>定义：</strong></p><blockquote><p>单一职责原则，就一个类而言，应该仅有一个引起它变化的原因。</p></blockquote><ol><li><p><strong>如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。</strong></p></li><li><p><strong>软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离。</strong></p></li><li><p><strong>如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责。</strong></p></li></ol><p><strong>好处</strong>:</p><ul><li>类的复杂性降低，实现什么职责都有清晰明确的定义</li><li>可读性提高，复杂性降低，那当然可读性提高了</li><li>可维护性提高，可读性提高，那当然更容易维护了</li><li>变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助</li></ul><hr><h4 id="②-开放-封闭原则"><a href="#②-开放-封闭原则" class="headerlink" title="② 开放-封闭原则"></a>② 开放-封闭原则</h4><p><strong>定义：</strong></p><blockquote><p>开放-封闭原则，是说软件实体（类、模块、函数等等)应该可以扩展，但是不可修改。对于扩展是开放的（Open for extension)，对于更改是封闭的（Closed for modification)</p></blockquote><ol><li><p><strong>无论模块是多么的‘封闭’，都会存在一些无法对之封闭的变化。既然不可能完全封闭，设计人员必须对于他设计的模块应该对哪种变化封闭做出选择。他必须先猜测出最有可能发生的变化种类，然后构造抽象来隔离那些变化。</strong></p></li><li><p><strong>等到变化发生时立即采取行动。</strong></p></li><li><p><strong>在我们最初编写代码时，假设变化不会发生。当变化发生时，我们就创建抽象来隔离以后发生的同类变化。</strong></p></li><li><p><strong>面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码。</strong></p></li><li><p><strong>我们希望的是在开发工作展开不久就知道可能发生的变化。查明可能发生的变化所等待的时间越长，要创建正确的抽象就越困难。</strong></p></li><li><p><strong>开放-封闭原则是面向对象设计的核心所在。遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是可维护、可扩展、可复用、灵活性好。开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象，然而，对于应用程序中的每个部分都刻意地进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要</strong></p></li></ol><p><strong>好处</strong>：</p><ul><li>通过扩展已有的软件系统，可以提供新的行为,以满足对软件的新需求，是变化中的软件有一定的适应性和灵活性。</li><li>已有的软件模块，特别是最重要的抽象模块不能再修改，这就使变化中的软件系统有一定的稳定性和延续性</li></ul><hr><h4 id="③-依赖倒转原则"><a href="#③-依赖倒转原则" class="headerlink" title="③ 依赖倒转原则"></a>③ 依赖倒转原则</h4><p><strong>定义：</strong></p><blockquote><p>A．高层模块不应该依赖低层模块。两个都应该依赖抽象。</p><p>B．抽象不应该依赖细节。细节应该依赖抽象。</p><p>C.   要针对接口编程、不要对实现编程</p></blockquote><p><strong>好处：</strong></p><p>​<strong>依赖倒置原则可以提高程序的可扩展性，也可有效的降低程序耦合；依赖倒置原则避免了修改负责复杂逻辑的高层模块，大大提高了程序的稳定性。</strong></p><hr><h4 id="④-里氏转换原则"><a href="#④-里氏转换原则" class="headerlink" title="④ 里氏转换原则"></a>④ 里氏转换原则</h4><p><strong>定义：</strong></p><blockquote><p>里氏代换原则（LSP):子类型必须能够替换掉它们的父类型。</p></blockquote><ol><li><strong>一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。也就是说，在软件里面，把父类都替换成它的子类，程序的行为没有变化，简单地说，子类型必须能够替换掉它们的父类型。</strong></li><li><strong>只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。</strong></li><li><strong>由于子类型的可替换性才使得使用父类类型的模块在无需修改的情况下就可以扩展。</strong></li></ol><p><strong>好处：</strong></p><ul><li><p>约束继承泛滥，它也是开闭原则的一种很好的体现。</p></li><li><p>提高了代码的重用性。</p></li><li><p>降低了系统的出错率。类的扩展不会给原类造成影响，降低了代码出错的范围和系统出错的概率。</p></li><li><p>加强程序的健壮性，同时变更时可以做到非常好的兼容性，提高程序的维护性、可扩展性，降低需求变更时引入的风险。</p></li></ul><hr><h4 id="⑤-迪米特法则"><a href="#⑤-迪米特法则" class="headerlink" title="⑤ 迪米特法则"></a>⑤ 迪米特法则</h4><p><strong>定义：</strong></p><blockquote><p>迪米特法则(LoD)，如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。</p></blockquote><ol><li><strong>在类的结构设计上，每一个类都应当尽量降低成员的访问权限</strong></li><li><strong>迪米特法则其根本思想，是强调了类之间的松耦合。</strong></li><li><strong>类之间的耦合越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。</strong></li></ol><p><strong>好处：</strong></p><ul><li><p>降低了类之间耦合度，提高了模块的相对独立性。</p></li><li><p>亲和度降低，提高了类的可复用率和系统的扩展性。</p></li></ul><hr><h4 id="⑥-接口隔离原则"><a href="#⑥-接口隔离原则" class="headerlink" title="⑥ 接口隔离原则"></a>⑥ 接口隔离原则</h4><p><strong>定义：</strong></p><blockquote><p>接口隔离原则(Interface Segregation Principle, ISP)：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。</p></blockquote><ol><li><strong>每一个接口应该承担一种相对独立的角色，不干不该干的事情，干该干的事请</strong>。</li><li><strong>接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的接口，而不要提供大的总接口</strong></li><li><strong>在使用接口隔离原则时我们要控制接口的颗粒度，颗粒度不能太大，也不能太小。如果太小就会造成接口泛滥，不利于维护；接口入如果太大就会违背接口隔离原则，灵活性较差，使用起来不方便</strong>。</li></ol><p><strong>好处：</strong></p><ul><li><p>接口隔离原则是为了约束接口降低类对接口的依赖性</p></li><li><p>接口隔离提高了系统的内聚性,减少了对外交互,降低了系统的耦合性</p></li><li><p>能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法,当实现这个接口的时候,被迫设计冗余的代码。</p></li></ul><hr><h2 id="一、创建型设计模式"><a href="#一、创建型设计模式" class="headerlink" title="一、创建型设计模式"></a>一、创建型设计模式</h2><h3 id="1、简单工厂模式"><a href="#1、简单工厂模式" class="headerlink" title="1、简单工厂模式"></a>1、简单工厂模式</h3><h4 id="①-引言"><a href="#①-引言" class="headerlink" title="① 引言"></a>① 引言</h4><p>　　这个系列也是自己对设计模式的一些学习笔记,希望对一些初学设计模式的人有所帮助的,在上一个专题中介绍了单例模式,在这个专题中继续为大家介绍一个比较容易理解的模式——简单工厂模式。</p><h4 id="②-简单工厂模式的介绍"><a href="#②-简单工厂模式的介绍" class="headerlink" title="② 简单工厂模式的介绍"></a>② 简单工厂模式的介绍</h4><p>　　说到简单工厂，自然的第一个疑问当然就是什么是简单工厂模式了？ 在现实生活中工厂是负责生产产品的,同样在设计模式中,简单工厂模式我们也可以理解为负责<strong>生产对象的一个类</strong>, 我们平常编程中，当使用”new”关键字创建一个对象时，此时该类就依赖与这个对象，也就是他们之间的耦合度高，当需求变化时，我们就不得不去修改此类的源码，此时我们可以运用面向对象（OO）的很重要的原则去解决这一的问题，该原则就是——<font color="#FF0000">封装改变，既然要封装改变，自然也就要找到改变的代码，然后把改变的代码用类来封装</font>，这样的一种思路也就是我们简单工厂模式的实现方式了。下面通过一个现实生活中的例子来引出简单工厂模式。</p><h4 id="③-实现"><a href="#③-实现" class="headerlink" title="③ 实现"></a>③ 实现</h4><p><strong>简单工厂类：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c#"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">OperationFactory</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Operation <span class="hljs-title">createOperate</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> operate</span>)</span><br>    &#123;<br>     Operation oper=<span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">switch</span>(operate)<br>        &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span>:<br>                oper = <span class="hljs-keyword">new</span> OperationAdd();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span>:<br>                oper = <span class="hljs-keyword">new</span> OpeationSub();<br>            <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*&quot;</span>:<br>                oper = <span class="hljs-keyword">new</span> OperationMul();<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/&quot;</span>:<br>                oper = <span class="hljs-keyword">new</span> OperationDiv();<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> oper;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82UML.png"></p><h4 id="④-优点与缺点"><a href="#④-优点与缺点" class="headerlink" title="④ 优点与缺点"></a>④ 优点与缺点</h4><p>​<strong>1.主要优点</strong></p><p>​    简单工厂模式的主要优点如下：</p><p>​    (1) 工厂类包含必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的职责，而仅仅“消费”产品，简单工厂模式实现了对象创建和使用的分离。</p><p>​    (2) 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以在一定程度减少使用者的记忆量。</p><p>​    (3) 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。</p><p>​     <strong>2. 主要缺点</strong></p><p>​    简单工厂模式的主要缺点如下：</p><p>​    (1) 由于工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响。</p><p>​    (2) 使用简单工厂模式势必会增加系统中类的个数（引入了新的工厂类），增加了系统的复杂度和理解难度。</p><p>​    (3) 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。</p><p>​    (4) 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。</p><hr><h3 id="2、工厂方法模式"><a href="#2、工厂方法模式" class="headerlink" title="2、工厂方法模式"></a>2、工厂方法模式</h3><h4 id="①-引言-1"><a href="#①-引言-1" class="headerlink" title="① 引言"></a>① 引言</h4><p>　　<strong>工厂方法模式(Factory Method Pattern)：</strong>定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。工厂方法模式又简称为工厂模式(Factory Pattern)，又可称作虚拟构造器模式(Virtual Constructor Pattern)或多态工厂模式(Polymorphic Factory Pattern)。工厂方法模式是一种类创建型模式。</p><h4 id="②-工厂方法模式的介绍"><a href="#②-工厂方法模式的介绍" class="headerlink" title="② 工厂方法模式的介绍"></a>② 工厂方法模式的介绍</h4><p>　　工厂方法模式之所以可以解决简单工厂的模式，是因为它的实现把具体产品的创建推迟到子类中，此时工厂类不再负责所有产品的创建，而只是给出具体工厂必须实现的接口，这样工厂方法模式就可以允许系统不修改工厂类逻辑的情况下来添加新产品，这样也就克服了简单工厂模式中缺点。</p><h4 id="③-实现-1"><a href="#③-实现-1" class="headerlink" title="③ 实现"></a>③ 实现</h4><div align="center"><b>工厂方法UML</b></div><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95UML.png"></p><blockquote><p>&#x2F;&#x2F;工厂接口</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">interface</span> <span class="hljs-title">IFactory</span><br>&#123;<br>    <span class="hljs-function">Operation <span class="hljs-title">CreateOperation</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>加减乘除各间一个具体工厂去实现这个接口</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">AddFactory</span>:<span class="hljs-title">IFactory</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Operation <span class="hljs-title">CreateOperation</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> OperationAdd();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">SubFactory</span>:<span class="hljs-title">IFactory</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Operation <span class="hljs-title">CreateOperation</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> OperationSub();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">MulFactory</span>:<span class="hljs-title">IFactory</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Operation <span class="hljs-title">CreateOperation</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> OperationMul();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">DivFactory</span>:<span class="hljs-title">IFactory</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Operation <span class="hljs-title">CreateOperation</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> OperationDiv();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>客户端实现</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C#">IFactory operFactory=<span class="hljs-keyword">new</span> AddFactory();<br>Operation oper=operFactory.CreatOperation();<br>oper.NumberA=<span class="hljs-number">1</span>;<br>oper.NumberB=<span class="hljs-number">2</span>;<br><span class="hljs-built_in">double</span> result=oper.GetResult;<br></code></pre></td></tr></table></figure><div align="center"><b>工厂方法结构图</b></div><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><h4 id="④-优点与缺点-1"><a href="#④-优点与缺点-1" class="headerlink" title="④ 优点与缺点"></a>④ 优点与缺点</h4><p>​<strong>1.主要优点</strong></p><p>​    工厂方法模式的主要优点如下：</p><p>​    (1) 在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。</p><p>​    (2) 基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够让工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，就正是因为所有的具体工厂类都具有同一抽象父类。</p><p>​    (3) 使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改<strong>抽象工厂</strong>和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了，这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。</p><p>​<strong>2.主要缺点</strong></p><p>   工厂方法模式的主要缺点如下：</p><p>   (1) 在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。</p><p>   (2) 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。</p><h4 id="⑤-总结"><a href="#⑤-总结" class="headerlink" title="⑤ 总结"></a>⑤ 总结</h4><p><strong>工厂方法模式(Factory Method)</strong>,定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。</p><hr><h3 id="3、抽象工厂模式"><a href="#3、抽象工厂模式" class="headerlink" title="3、抽象工厂模式"></a>3、抽象工厂模式</h3><h4 id="①-引言-2"><a href="#①-引言-2" class="headerlink" title="① 引言"></a>① 引言</h4><p>​工厂方法模式是为了克服简单工厂模式的缺点而设计出来的,简单工厂模式的工厂类随着产品类的增加需要增加额外的代码），而工厂方法模式每个具体工厂类只完成单个实例的创建,所以它具有很好的可扩展性。但是在现实生活中，一个工厂只创建单个产品这样的例子很少，因为现在的工厂都多元化了，一个工厂创建一系列的产品，如果我们要设计这样的系统时，工厂方法模式显然在这里不适用，然后抽象工厂模式却可以很好地解决一系列产品创建的问题</p><h4 id="②-抽象工厂模式的介绍"><a href="#②-抽象工厂模式的介绍" class="headerlink" title="② 抽象工厂模式的介绍"></a>② 抽象工厂模式的介绍</h4><p>​抽象工厂模式：<strong>提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，它是一种对象创建型模式。</strong></p><h4 id="③-实现-2"><a href="#③-实现-2" class="headerlink" title="③ 实现"></a>③ 实现</h4><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82Uml.png"></p><blockquote><p>IDepartment接口，用于客户端访问，解除与具体数据库访问的耦合</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">interface</span> <span class="hljs-title">IDepartment</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span>(<span class="hljs-params">Department department</span>)</span>;<br>    <br>    <span class="hljs-function">Department <span class="hljs-title">GetDepartment</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> id</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>SqlseverDepartment类，用于访问SQL sever的Department</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlserverDepartment</span> : <span class="hljs-title">Ideparment</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span>(<span class="hljs-params">Department department</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;在Sql server中给Department 表增加一条记录&quot;</span>)<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Department <span class="hljs-title">GetDepartment</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> id</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;在Sql sever中根据Id得到Department 表一条记录&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>AccessDeapartment类，用于访问Acces的Department.</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">AccessDepartment</span> :<span class="hljs-title">IDepartment</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span>(<span class="hljs-params">Department department</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;在Acess中给Department 表增加一条记录&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Department <span class="hljs-title">GetDepartment</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> id</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;在Acess中根据Id得到Department 表一条记录&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>IFactory接口，定义一个创建访问User表对象的抽象的工厂接口</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">interface</span> <span class="hljs-title">IFactory</span><br>&#123;<br>    <span class="hljs-function">IUser <span class="hljs-title">CreateUser</span>()</span>;<br>    <span class="hljs-function">IDepartment <span class="hljs-title">CreateDepartment</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>SqlSeverFactory类，实现IFactory接口，实现SqlseverUser和SqlserverDepartment</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlseverFactory</span>:<span class="hljs-title">IFactory</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IUser <span class="hljs-title">CreateUser</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SqlseverUser();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IDepartment <span class="hljs-title">CreateDepartment</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SqlseverDepartment();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>AccessFactory类，实现IFactory接口，实现AccessrUser和AccessDepartment</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">AccessFactory</span>:<span class="hljs-title">IFactory</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IUser <span class="hljs-title">CreateUser</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AccessrUser();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IDepartment <span class="hljs-title">CreateDepartment</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AccessDepartment();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>客户端代码</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&#123;<br>    User user = <span class="hljs-keyword">new</span> User();<br>    Department dept=<span class="hljs-keyword">new</span> Department();<br>    <span class="hljs-comment">//IFactory factory= new SqlseverFactory();</span><br>    IFactory factory= <span class="hljs-keyword">new</span> AccessFactory();<br>    <br>    IUser iu=factory.CreateUser();<br>    <br>    iu.Insert(user);<br>    iu.GetUser(dept);<br>    id.GetDepartment(<span class="hljs-number">1</span>);<br>    <br>    Console.Read();<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><h4 id="④-优点与缺点-2"><a href="#④-优点与缺点-2" class="headerlink" title="④ 优点与缺点"></a>④ 优点与缺点</h4><p>​<strong>1.主要优点</strong></p><p>​    抽象工厂模式的主要优点如下：</p><p>​    (1) 抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易，所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。</p><p>​    (2) 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。</p><p>​    (3) 增加新的产品族很方便，无须修改已有系统，符合“开闭原则”。</p><p>​    <strong>2. 主要缺点</strong></p><p>​    抽象工厂模式的主要缺点如下：</p><p>​    增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了“开闭原则”。</p><h4 id="⑤-总结-1"><a href="#⑤-总结-1" class="headerlink" title="⑤ 总结"></a>⑤ 总结</h4><p><strong>抽象工厂模式</strong>，提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。</p><hr><h3 id="4、单例模式"><a href="#4、单例模式" class="headerlink" title="4、单例模式"></a>4、单例模式</h3><h4 id="①-引言-3"><a href="#①-引言-3" class="headerlink" title="① 引言"></a>① 引言</h4><p>​单例”字面意思上理解为——一个类只有一个实例，所以单例模式也就是<font color="FF0000"><strong>保证一个类只有一个实例的一种实现方法</strong></font>，单例模式的一个官方定义：<strong>确保一个类只有一个实例,并提供一个全局访问点。</strong></p><h4 id="②-单例设计模式介绍"><a href="#②-单例设计模式介绍" class="headerlink" title="② 单例设计模式介绍"></a>② 单例设计模式介绍</h4><p>​<strong>单例模式（Singleton）</strong>，保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p>​“通常我们可以让一个全局变量是的一个对象被访问，但它不能防止你实例化多个对象。一个最好办法就是，让类自身负责保存它的唯一实例。这个类可以保证有没有其他实例可以被创建，并且它可以提供一个访问该实例的方法。</p><p>​<strong>单例模式因为Singleton类封装它的唯一实例，这样它可以严格控制客户怎样访问它以及何时访问它。简单地说就是对唯一实例的受控访问。</strong></p><h4 id="③-实现-3"><a href="#③-实现-3" class="headerlink" title="③ 实现"></a>③ 实现</h4><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><blockquote><p>Singleton类，定义一个GetInstance操作，允许客户访问它的唯一实例。GetInstance 是一个静态方法，主要负责创建自己的唯一实例。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span>()</span><br>    &#123;<br>        <span class="hljs-comment">//构造方法让其private,这就毒死了外界利用new创建此类实例的可能</span><br>    &#125;<br>    <br>    <span class="hljs-comment">//此方法是获得本类实例的唯一全局访问点</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">GetInstance</span>()</span><br>    &#123;<br>        <span class="hljs-comment">//若实例不存在，则new一个新实例，否则返回已有的实例</span><br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)<br>        &#123;<br>            instance = <span class="hljs-keyword">new</span> Sington();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instacne;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>客户端代码</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&#123;<br>    Singleton s1 = Singleton.GetInstance();<br>    Singleton s2 = Singleton.GetInstance();<br>    <br>    <span class="hljs-keyword">if</span>(s1==s2)<br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;两个对象是相同的实例&quot;</span>);<br>    &#125;<br>    Console.Read();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="④-多线程使用单例模式所引发的问题"><a href="#④-多线程使用单例模式所引发的问题" class="headerlink" title="④ 多线程使用单例模式所引发的问题"></a>④ 多线程使用单例模式所引发的问题</h4><p>上面的单例模式的实现在单线程下确实是完美的,然而在多线程的情况下会得到多个Singleton实例,因为在两个线程同时运行GetInstance方法时，此时两个线程判断(uniqueInstance &#x3D;&#x3D;null)这个条件时都返回真，此时两个线程就都会创建Singleton的实例，这样就违背了我们单例模式初衷了，既然上面的实现会运行多个线程执行，那<strong>我们对于多线程的解决方案自然就是使GetInstance方法在同一时间只运行一个线程运行就好了</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span><br>    &#123;<br>        <span class="hljs-comment">// 定义一个静态变量来保存类的实例</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;<br><br>        <span class="hljs-comment">// 定义一个标识确保线程同步</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">object</span> locker = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>();<br><br>        <span class="hljs-comment">// 定义私有构造函数，使外界不能创建该类实例</span><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span>()</span><br>        &#123;<br>        &#125;<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 定义公有方法提供一个全局访问点,同时你也可以定义公有属性来提供全局访问点</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>       <br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">GetInstance</span>()</span><br>        &#123;<br>            <span class="hljs-comment">// 当第一个线程运行到这里时，此时会对locker对象 &quot;加锁&quot;，</span><br>            <span class="hljs-comment">// 当第二个线程运行该方法时，首先检测到locker对象为&quot;加锁&quot;状态，该线程就会挂起等待第一个线程解锁</span><br>            <span class="hljs-comment">// lock语句运行完之后（即线程运行完之后）会对该对象&quot;解锁&quot;</span><br>            <span class="hljs-keyword">lock</span> (locker)<br>            &#123;<br>                <span class="hljs-comment">// 如果类的实例不存在则创建，否则直接返回</span><br>                <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>)<br>                &#123;<br>                    uniqueInstance = <span class="hljs-keyword">new</span> Singleton();<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> uniqueInstance;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>上面这种解决方案确实可以解决多线程的问题,但是**上面代码对于每个线程都会对线程辅助对象locker加锁之后再判断实例是否存在，对于这个操作完全没有必要的，因为当第一个线程创建了该类的实例之后，后面的线程此时只需要直接判断（uniqueInstance&#x3D;&#x3D;null）为假，此时完全没必要对线程辅助对象加锁之后再去判断，所以上面的实现方式增加了额外的开销，损失了性能，为了改进上面实现方式的缺陷，我们只需要在lock语句前面加一句（uniqueInstance&#x3D;&#x3D;null）的判断就可以避免锁所增加的额外开销，这种实现方式我们就叫它 **<font color="FF0000"><b>“双重锁定”</b></font>，下面具体看看实现代码的：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span><br>   &#123;<br>       <span class="hljs-comment">// 定义一个静态变量来保存类的实例</span><br>       <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;<br><br>       <span class="hljs-comment">// 定义一个标识确保线程同步</span><br>       <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">object</span> locker = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>();<br><br>       <span class="hljs-comment">// 定义私有构造函数，使外界不能创建该类实例</span><br>       <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span>()</span><br>       &#123;<br>       &#125;<br><br>       <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>       <span class="hljs-comment"><span class="hljs-doctag">///</span> 定义公有方法提供一个全局访问点,同时你也可以定义公有属性来提供全局访问点</span><br>       <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">GetInstance</span>()</span><br>       &#123;<br>           <span class="hljs-comment">// 当第一个线程运行到这里时，此时会对locker对象 &quot;加锁&quot;，</span><br>           <span class="hljs-comment">// 当第二个线程运行该方法时，首先检测到locker对象为&quot;加锁&quot;状态，该线程就会挂起等待第一个线程解锁</span><br>           <span class="hljs-comment">// lock语句运行完之后（即线程运行完之后）会对该对象&quot;解锁&quot;</span><br>           <span class="hljs-comment">// 双重锁定只需要一句判断就可以了</span><br>           <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>)<br>           &#123;<br>               <span class="hljs-keyword">lock</span> (locker)<br>               &#123;<br>                   <span class="hljs-comment">// 如果类的实例不存在则创建，否则直接返回</span><br>                   <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>)<br>                   &#123;<br>                       uniqueInstance = <span class="hljs-keyword">new</span> Singleton();<br>                   &#125;<br>               &#125;<br>           &#125;<br>           <span class="hljs-keyword">return</span> uniqueInstance;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><h4 id="⑤-C-中实现了单例模式的类"><a href="#⑤-C-中实现了单例模式的类" class="headerlink" title="⑤ C#中实现了单例模式的类"></a>⑤ C#中实现了单例模式的类</h4><p>经过查看，.NET类库中确实存在单例模式的实现类，不过该类不是公开的，下面就具体看看该类的一个实现的(该类具体存在于System.dll程序集，命名空间为System,可以用反射工具Reflector去查看源码的)</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SR</span><br>    &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SR loader;<br>        <span class="hljs-function"><span class="hljs-keyword">internal</span> <span class="hljs-title">SR</span>()</span><br>        &#123;<br>        &#125;<br>        <span class="hljs-comment">// 主要是因为该类不是公有，所以这个全部访问点也定义为私有的了</span><br>        <span class="hljs-comment">// 但是思想还是用到了单例模式的思想的</span><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SR <span class="hljs-title">GetLoader</span>()</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (loader == <span class="hljs-literal">null</span>)<br>            &#123;<br>                SR sr = <span class="hljs-keyword">new</span> SR();<br>                Interlocked.CompareExchange&lt;SR&gt;(<span class="hljs-keyword">ref</span> loader, sr, <span class="hljs-literal">null</span>);<br>            &#125;<br>            <span class="hljs-keyword">return</span> loader;<br>        &#125;<br><br>        <span class="hljs-comment">// 这个公有方法中调用了GetLoader方法的</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">object</span> <span class="hljs-title">GetObject</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span><br>        &#123;<br>            SR loader = GetLoader();<br>            <span class="hljs-keyword">if</span> (loader == <span class="hljs-literal">null</span>)<br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> loader.resources.GetObject(name, Culture);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="⑥-总结"><a href="#⑥-总结" class="headerlink" title="⑥ 总结"></a>⑥ 总结</h4><p><strong>单例模式（Singleton）</strong>，保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><hr><h3 id="5、原型模式"><a href="#5、原型模式" class="headerlink" title="5、原型模式"></a>5、原型模式</h3><h4 id="①-引言-4"><a href="#①-引言-4" class="headerlink" title="① 引言"></a>① 引言</h4><p>​在软件系统中，当创建一个类的实例的过程很昂贵或很复杂，并且我们需要创建多个这样类的实例时，如果我们用new操作符去创建这样的类实例，这未免会增加创建类的复杂度和耗费更多的内存空间，因为这样在内存中分配了多个一样的类实例对象，然后如果采用工厂模式来创建这样的系统的话，随着产品类的不断增加，导致子类的数量不断增多，反而增加了系统复杂程度，所以在这里使用工厂模式来封装类创建过程并不合适，然而原型模式可以很好地解决这个问题，因为每个类实例都是相同的，当我们需要多个相同的类实例时，没必要每次都使用new运算符去创建相同的类实例对象，此时我们一般思路就是想——只创建一个类实例对象，如果后面需要更多这样的实例，可以通过对原来对象拷贝一份来完成创建，这样在内存中不需要创建多个相同的类实例，从而减少内存的消耗和达到类实例的复用。然而这个思路正是<strong>原型模式</strong>的实现方式。</p><h4 id="②-原型设计模式介绍"><a href="#②-原型设计模式介绍" class="headerlink" title="② 原型设计模式介绍"></a>② 原型设计模式介绍</h4><p><strong>原型模式（prototype）</strong>，用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象</p><p>在现实生活中，也有很多原型设计模式的例子，例如，细胞分裂的过程，一个细胞的有丝分裂产生两个相同的细胞；还有西游记中孙悟空变出后孙的本领和火影忍者中鸣人的隐分身忍术，写多份简历等。</p><h4 id="③-实现-4"><a href="#③-实现-4" class="headerlink" title="③ 实现"></a>③ 实现</h4><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><blockquote><p>原型类</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Prototype</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> id;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Prototype</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> id</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.id=id;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Id<br>    &#123;<br>        <span class="hljs-keyword">get</span>&#123;<span class="hljs-keyword">return</span> id;&#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">//抽象类的关键就是有这样一个Clone方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Prototype <span class="hljs-title">Clone</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>具体原型类</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcretePrototype</span> : <span class="hljs-title">Prototype</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcretePrototype</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> id</span>):<span class="hljs-title">base</span>(<span class="hljs-params">id</span>)</span><br>    &#123;<br>        <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> Prototype <span class="hljs-title">clone</span>()</span><br>    &#123;<br>        <span class="hljs-comment">//创建当前对象的浅表副本。方法时创建一个新对象，然后将当前对象的非静态字段复制到该新对象。如果字段时值类型的，则对该字段执行逐位复制。如果字段是引用类型，则复制引用但不复制引用的对象；因此，原始对象及其副本引用同一对象</span><br>        <span class="hljs-keyword">return</span> (Prototype)<span class="hljs-keyword">this</span>.MemberWiseClone();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>客户端代码</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&#123;<br>    ConcretePrototype p1= <span class="hljs-keyword">new</span> ConcretePrototype(<span class="hljs-string">&quot;I&quot;</span>);<br>    <span class="hljs-comment">//克隆类ConcretePrototype的对象p1就能得到新得实例c1</span><br>    ConcretePrototype c1= <span class="hljs-keyword">new</span> (ConcretePrototype)p1.Clone();<br>    Console.WriteLine(<span class="hljs-string">&quot;Clonded:&#123;0&#125;&quot;</span>,c1.Id);<br>    Console.Read();<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="④-浅拷贝和深拷贝"><a href="#④-浅拷贝和深拷贝" class="headerlink" title="④ 浅拷贝和深拷贝"></a>④ 浅拷贝和深拷贝</h4><p><strong>MemberwiseClone</strong>方法创建一个<strong>浅表副本</strong>，方法是创建一个新对象，然后将当前对象的非静态字段复制到该新对象。如果字段是<strong>值类型的，则对该字段执行逐位复制</strong>。如果字段是<strong>引用类型，则复制引用单不复制引用的对象</strong>；因此原始对象及其副本引用同一对象。</p><p>例如，考虑引用对象A和B的被称为X的对象。对象B依次引用对象C。X的浅表副本创建一个新对象X2，该对象也引用对象A和B。相比而言，X的深层副本创建一个新对象X2，该对象引用新对象A2和B2（人别为A和B的副本）。B2有引用新对象C2，C2是C的副本。该实例阐释了千层和深层复制操作之间的区别。</p><p>有很多方法可以实现深层复制操作，前提是浅表赋值操作有MemberwiseClone方法执行但不符合您的要求。这些要求包括：</p><ul><li>调用要复制的对象的构造函数以创建含有从第一个对象中提出的属性值的第二个对象。这假定对象的值完全由类构造函数定义。</li><li>调用MemberwiseClone方法创建的对象的浅表副本，然后将指定新的对象，其值均相同，院士对象的任何属性或字段的值是引用类型。该实例中的DeepCopy方法阐释了这种方法。</li><li>序列化要深层复制的对象，然后将序列化的数据还原到另一个对象变量。</li><li>使用带递归的反射执行的深层复制操作。</li></ul><p>下面的实力掩饰MemberwiseClone方法。它定义了ShallowCopy方法，该方法通过调用MemberwiseClone方法来在Person对象上执行浅表复制操作。他还定义了在Person对象上执行深层复制操作的DeepCopy方法。</p><p><strong>深拷贝</strong>把引用对象的变量指向复制过的新对象，而不是原有的被引用的对象。</p><div align="center"><b>简历的深拷贝复制实现</b></div><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%B7%B1%E6%8B%B7%E8%B4%9D.png"></p><blockquote><p>工作经历类</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//让工作经历实现ICloneable接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">WorkExperinece</span>:<span class="hljs-title">ICloneable</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> workDate;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> WorkDate<br>    &#123;<br>        <span class="hljs-keyword">get</span>;<br>        <span class="hljs-keyword">set</span>;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> company;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Company<br>    &#123;<br>        <span class="hljs-keyword">get</span>;<br>        <span class="hljs-keyword">set</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">Clone</span>()</span><br>    &#123;<br>        <span class="hljs-comment">//&quot;工作经历&quot;类实现克隆方法</span><br>        <span class="hljs-keyword">return</span> (Object)<span class="hljs-keyword">this</span>.MemberwiseColne();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>简历类</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">Resume</span> : <span class="hljs-title">Icloneable</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> sex;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> age;<br>    <span class="hljs-keyword">private</span> Workexperience work;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Resume</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.name=name;<br>        work=<span class="hljs-keyword">new</span> WorkExperience();<br>    &#125;<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Resume</span>(<span class="hljs-params">WorkExperience work</span>)</span><br>    &#123;<br>        <span class="hljs-comment">//提供Clone方法调用的私有构造函数，以便克隆&quot;工作经历&quot;的数据</span><br>        <span class="hljs-keyword">this</span>.work=(WorkExperience)work.Clone();<br>    &#125;<br>    <span class="hljs-comment">//设置个人信息</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetPersonalInfo</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> sex,<span class="hljs-built_in">string</span> age</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.sex=sex;<br>        <span class="hljs-keyword">this</span>.age=age;<br>    &#125;<br>    <span class="hljs-comment">//设置工作经历</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetWorkExperience</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> workDate,<span class="hljs-built_in">string</span> company</span>)</span><br>    &#123;<br>        work.WorkDate=workDate;<br>        work.Company=company<br>    &#125;<br>    <span class="hljs-comment">//显示</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Display</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;&#123;0&#125;&#123;1&#125;&#123;2&#125;&quot;</span>,name,sex,gae);<br>        Console.WriteLine(<span class="hljs-string">&quot;工作经历：&#123;0&#125;&#123;1&#125;&quot;</span>,work.WorkDate,work.Company);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//调用私有的构造方法，让“工作经历”克隆完成，然后再给这个“简历”对象的相关字段赋值，最终返回一个深拷贝的简历对象</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">Clone</span>()</span><br>&#123;<br>    Resume obj=<span class="hljs-keyword">new</span> Resume(<span class="hljs-keyword">this</span>.work);<br>    obj.name=<span class="hljs-keyword">this</span>.name;<br>    obj.sex=<span class="hljs-keyword">this</span>.sex;<br>    obj.age=<span class="hljs-keyword">this</span>.age;<br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="⑤-优点和缺点"><a href="#⑤-优点和缺点" class="headerlink" title="⑤ 优点和缺点"></a>⑤ 优点和缺点</h4><p><strong>原型模式的优点有：</strong></p><ol><li>原型模式向客户隐藏了创建新实例的复杂性</li><li>原型模式允许动态增加或较少产品类。</li><li>原型模式简化了实例的创建结构，工厂方法模式需要有一个与产品类等级结构相同的等级结构，而原型模式不需要这样。</li><li>产品类不需要事先确定产品的等级结构，因为原型模式适用于任何的等级结构</li></ol><p><strong>原型模式的缺点有：</strong></p><ol><li>每个类必须配备一个克隆方法</li><li>配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。</li></ol><h4 id="⑥-总结-1"><a href="#⑥-总结-1" class="headerlink" title="⑥ 总结"></a>⑥ 总结</h4><p><strong>原型模式（prototype）</strong>，用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象</p><hr><h3 id="6、建造者模式"><a href="#6、建造者模式" class="headerlink" title="6、建造者模式"></a>6、建造者模式</h3><h4 id="①-引言-5"><a href="#①-引言-5" class="headerlink" title="① 引言"></a>① 引言</h4><p>​在软件系统中，有时需要创建一个复杂对象，并且这个复杂对象由其各部分子对象通过一定的步骤组合而成。例如一个采购系统中，如果需要采购员去采购一批电脑时，在这个实际需求中，电脑就是一个复杂的对象，它是由CPU、主板、硬盘、显卡、机箱等组装而成的，如果此时让采购员一台一台电脑去组装的话真是要累死采购员了，这里就可以采用建造者模式来解决这个问题，我们可以把电脑的各个组件的组装过程封装到一个建造者类对象里，建造者只要负责返还给客户端全部组件都建造完毕的产品对象就可以了。然而现实生活中也是如此的，如果公司要采购一批电脑，此时采购员不可能自己去买各个组件并把它们组织起来，此时采购员只需要像电脑城的老板说自己要采购什么样的电脑就可以了，电脑城老板自然会把组装好的电脑送到公司。</p><h4 id="②-建造者设计模式介绍"><a href="#②-建造者设计模式介绍" class="headerlink" title="② 建造者设计模式介绍"></a>② 建造者设计模式介绍</h4><p>​如果需要<strong>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</strong>的意图的时候，我们需要应用于一个设计模式，‘<strong>建造者（Builder）模式</strong>’，又称叫生成器模式叫生成器模式。建造者模式可以将一个产品的内部表象与产品的生成过程分割开来，从而可以使一个建造过程生成具有不同的内部表象的产品对象。<strong>如果我们用了建造者模式，那么用户就只需指定需要建造的类型就可以得到它们，而具体建造的过程和细节就不需知道了</strong>。</p><p>​<strong>建造者模式是在当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方法时适用的模式</strong></p><h4 id="③-实现-5"><a href="#③-实现-5" class="headerlink" title="③ 实现"></a>③ 实现</h4><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><blockquote><p>Product类——产品类，由多个部件组成</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">Product</span><br>&#123;<br>    IList&lt;<span class="hljs-built_in">string</span>&gt; parts=<span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">string</span>&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> part</span>)</span><br>    &#123;<br>    parts.Add(part);    <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Show</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;\n 产品 创建 ——&quot;</span>);<br>        <span class="hljs-keyword">foreach</span>(<span class="hljs-built_in">string</span> part <span class="hljs-keyword">in</span> parts)<br>        &#123;<br>            Console.WriteLine(part);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Bulider类——抽象建造者类，确定产品由两个部件PartA和PartB组成，并声明一个得到产品建造后结果的方法GetResult</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPartA</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BulidPartB</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Product <span class="hljs-title">GetResult</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ConcreteBuilder类——具体建造者类</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteBuilder</span> :<span class="hljs-title">Builder</span><br>&#123;<br>    <span class="hljs-keyword">private</span> Product porduct =<span class="hljs-keyword">new</span> Product();<br>    <br>    <span class="hljs-comment">//建造具体的两个部件A和B</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPartA</span>()</span><br>    &#123;<br>        product.Add(<span class="hljs-string">&quot;部件A&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPartB</span>()</span><br>    &#123;<br>        product.Add(<span class="hljs-string">&quot;部件B&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> Product <span class="hljs-title">GetResult</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> product;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ConcreteBuilder2类——具体建造者类</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteBuilder2</span> :<span class="hljs-title">Builder</span><br>&#123;<br>    <span class="hljs-keyword">private</span> Product porduct =<span class="hljs-keyword">new</span> Product();<br>    <br>    <span class="hljs-comment">//建造具体的两个部件A和B</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPartA</span>()</span><br>    &#123;<br>        product.Add(<span class="hljs-string">&quot;部件X&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPartB</span>()</span><br>    &#123;<br>        product.Add(<span class="hljs-string">&quot;部件Y&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> Product <span class="hljs-title">GetResult</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> product;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Director类——指挥者类</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">Director</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Coonstruct</span>(<span class="hljs-params">Builder builder</span>)</span><br>    &#123;<br>        <span class="hljs-comment">//用来指挥建造过程</span><br>        builder.BuildPartA();<br>        builder.BuildPartB();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>客户端代码，客户不需知道具体的建造过程</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&#123;<br>    Director dircetor =<span class="hljs-keyword">new</span> Dircetor();<br>    Builder b1 = <span class="hljs-keyword">new</span> ConcreteBuilder1();<br>    Builder b2 = <span class="hljs-keyword">new</span> ConcreteBuilder2();<br>    <br>    <span class="hljs-comment">//指挥者用ConcreteBuilder1和ConcreteBuilder2的方法来建造产品</span><br>    director.Construct(b1);<br>    Product p1 = b1.GetResult();<br>    p1.Show();<br>    <br>    director.Construct(b2);<br>    Product p2 = b2.GetResult();<br>    p2.Show();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="④-总结"><a href="#④-总结" class="headerlink" title="④ 总结"></a>④ 总结</h4><p><strong>建造者（Builder）模式</strong>，将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</p><hr><h2 id="二、结构型设计模式"><a href="#二、结构型设计模式" class="headerlink" title="二、结构型设计模式"></a>二、结构型设计模式</h2><h3 id="1、适配器模式"><a href="#1、适配器模式" class="headerlink" title="1、适配器模式"></a>1、适配器模式</h3><h4 id="①-引言-6"><a href="#①-引言-6" class="headerlink" title="① 引言"></a>① 引言</h4><p>​在实际的开发过程中，由于应用环境的变化（例如使用语言的变化），我们需要的实现在新的环境中没有现存对象可以满足，但是其他环境却存在这样现存的对象。那么如果将“将现存的对象”在新的环境中进行调用呢？解决这个问题的办法就是我们本文要介绍的适配器模式——<strong>使得新环境中不需要去重复实现已经存在了的实现而很好地把现有对象（指原来环境中的现有对象）加入到新环境来使用</strong>。</p><h4 id="②-适配器设计模式介绍"><a href="#②-适配器设计模式介绍" class="headerlink" title="② 适配器设计模式介绍"></a>② 适配器设计模式介绍</h4><p>​适配器模式——把一个类的接口变换成客户端所期待的另一种接口，从而使原本接口不匹配而无法一起工作的两个类能够在一起工作。</p><p>​当系统的数据和行为都正确，但接口不符合时，我们应该考虑用适配器，目的时使控制范围之外的一个原有对象与某个接口匹配。适配器模式主要应用与希望复用一些现存的类，但是接口又与复用环境要求不一致的情况。<strong>适配器模式有类的适配器模式和对象的适配器模式两种形式。</strong>但由于类适配器模式通过多重继承对一个接口与另一个接口进行匹配，<strong>而C#不支持多重继承，所以主要是对象适配器</strong>。</p><h4 id="③-实现-6"><a href="#③-实现-6" class="headerlink" title="③ 实现"></a>③ 实现</h4><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><blockquote><p>Target (这是客户所期待的接口。目标可以是具体的或抽象的的类，也可以是接口)</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">Target</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Request</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;普通请求！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Adpatee(需要适配的类)代码如下：</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">Adaptee</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SpecificRequest</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;特殊请求！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Adapter(通过在内部包装一个Adaptee对象，把源接口转换成目标接口)</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span>:<span class="hljs-title">Target</span><br>&#123;<br>    <span class="hljs-comment">//建立一个私有的Adaptee对象</span><br>    <span class="hljs-keyword">private</span> Adaptee adaptee=<span class="hljs-keyword">new</span> Adaptee();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Request</span>()</span><br>    &#123;<br>        <span class="hljs-comment">//这样就可以把表面上调用Request()方法编程实际调用SpecificRequest()</span><br>        adaptee.SpecificRequest();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>客户端代码</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&#123;<br>    Target target=<span class="hljs-keyword">new</span> Adapter();<br>    <span class="hljs-comment">//对客户端来说，调用的就是Target的Request()</span><br>    target.Requset();<br>    Console.Read();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="④-适配器模式的-NET应用"><a href="#④-适配器模式的-NET应用" class="headerlink" title="④ 适配器模式的.NET应用"></a>④ 适配器模式的.NET应用</h4><p>​在.NET中有一个类库已经实现了适配器，那就是<strong>DataAdapter</strong>。<strong>DataAdapter用作DataSet和数据源之间的适配器以便检索和保存数据。DataAdapter通过映射Fill（者更改了DataSet中数据以便与数据源中的数据相匹配）和Updata（这更改了数据源中的数据以便于DataSet中的数据相匹配）来提供这一适配器</strong></p><h4 id="⑤-优点和缺点-1"><a href="#⑤-优点和缺点-1" class="headerlink" title="⑤ 优点和缺点"></a>⑤ 优点和缺点</h4><p><strong>类的适配器模式：</strong></p><p><strong>优点：</strong></p><ul><li>可以在不修改原有代码的基础上来复用现有类，很好地符合 “开闭原则”</li><li>可以重新定义Adaptee(被适配的类)的部分行为，因为在类适配器模式中，Adapter是Adaptee的子类</li><li>仅仅引入一个对象，并不需要额外的字段来引用Adaptee实例（这个即是优点也是缺点）。</li></ul><p><strong>缺点：</strong></p><ul><li>用一个具体的Adapter类对Adaptee和Target进行匹配，当如果想要匹配一个类以及所有它的子类时，类的适配器模式就不能胜任了。因为类的适配器模式中没有引入Adaptee的实例，光调用this.SpecificRequest方法并不能去调用它对应子类的SpecificRequest方法。</li><li>采用了 “多继承”的实现方式，带来了不良的高耦合。</li></ul><p><strong>对象的适配器模式</strong></p><p><strong>优点：</strong></p><ul><li>可以在不修改原有代码的基础上来复用现有类，很好地符合 “开闭原则”（这点是两种实现方式都具有的）</li><li>采用 “对象组合”的方式，更符合松耦合。</li></ul><p>缺点：</p><ul><li>使得重定义Adaptee的行为较困难，这就需要生成Adaptee的子类并且使得Adapter引用这个子类而不是引用Adaptee本身。</li></ul><h4 id="6、总结"><a href="#6、总结" class="headerlink" title="6、总结"></a>6、总结</h4><p><strong>适配器模式（Adapter）</strong>，将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不能兼容而不能一起工作的那些类可以一起工作</p><hr><h3 id="2、桥接模式"><a href="#2、桥接模式" class="headerlink" title="2、桥接模式"></a>2、桥接模式</h3><h4 id="①-桥接设计模式介绍"><a href="#①-桥接设计模式介绍" class="headerlink" title="① 桥接设计模式介绍"></a>① 桥接设计模式介绍</h4><p>​桥接模式即将抽象部分与实现部分脱耦，使它们可以独立变化。桥接模式的目的就是使两者分离，根据面向对象的封装变化的原则，我们可以把实现部分的变化封装到另外一个类中，这样的一个思路也就是桥接模式的实现，我们可以对照桥接模式的实现代码来解决我们的分析思路。</p><h4 id="②-合成-x2F-聚合复用原则"><a href="#②-合成-x2F-聚合复用原则" class="headerlink" title="② 合成&#x2F;聚合复用原则"></a>② 合成&#x2F;聚合复用原则</h4><p>​<strong>合成&#x2F;聚合复用原则（CARP）</strong>尽量使用合成&#x2F;聚合，尽量不要使用类继承。</p><p>​<strong>聚合</strong>表示一种<strong>弱’拥有‘</strong>关系，<strong>体现的是A对象可以包含B对象，但B对象不是A对象的一部分</strong>；<strong>合成</strong>则是一种<strong>强的’拥有‘</strong>关系，<strong>体现了严格部分和整体关系，部分和整体的生命周期一样</strong>。</p><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%90%88%E6%88%90%E8%81%9A%E5%90%88.png"></p><p>​<font color="FF000"><b>好处：</b></font>font优先使用对象的合成&#x2F;聚合将有助于保持每个类被封装，并被集中在单个任务上。这样类和类继承层次回保持较小规模，并且不太可能增长为不可控制的庞然大物。</p><h4 id="③-实现-7"><a href="#③-实现-7" class="headerlink" title="③ 实现"></a>③ 实现</h4><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><blockquote><p>Implementor实现者类 </p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Implementor</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ConcreteImplementorA和ConcreteImplementorB等派生</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteImplementorA</span> : <span class="hljs-title">Implementor</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;具体实现A地方法执行&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteImplementorB</span> : <span class="hljs-title">Implementor</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;具体实现B地方法执行&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Abstraction类</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">Abstraction</span><br>&#123;<br>    <span class="hljs-keyword">protected</span> Implementor implementor;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetImplementor</span>(<span class="hljs-params">Implementor implementor</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.implementor=implementor<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation</span>()</span><br>    &#123;<br>        implementor.Operation();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>RefinedAbstraction类</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">RefinedAbstraction</span> : <span class="hljs-title">Abstraction</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation</span>()</span><br>    &#123;<br>        implementor.Operation();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>客户端实现</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&#123;<br>    Abstraction ab = <span class="hljs-keyword">new</span> RefinedAbstraction();<br>    <br>    ab.SetImplementor(<span class="hljs-keyword">new</span> ConcreteImplementorA());<br>    ab.Operation();<br>    <br>    ab.SetImplementor(<span class="hljs-keyword">new</span> ConcreteImplementorB());<br>    ab.Operation();<br>    <br>    Console.Read();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="④-优点和缺点"><a href="#④-优点和缺点" class="headerlink" title="④ 优点和缺点"></a>④ 优点和缺点</h4><p><strong>优点：</strong></p><p>把抽象接口与其实现解耦。</p><p>抽象和实现可以独立扩展，不会影响到对方。</p><p>实现细节对客户透明，对用于隐藏了具体实现细节。</p><p><strong>缺点：</strong> 增加了系统的复杂度</p><h4 id="⑤-总结-2"><a href="#⑤-总结-2" class="headerlink" title="⑤ 总结"></a>⑤ 总结</h4><p><strong>桥接模式（Bridge）</strong>，将抽象部分与它的实现部分分离，使它们都可以独立地变化。</p><hr><h3 id="3、装饰者模式"><a href="#3、装饰者模式" class="headerlink" title="3、装饰者模式"></a>3、装饰者模式</h3><h4 id="①-引言-7"><a href="#①-引言-7" class="headerlink" title="① 引言"></a>① 引言</h4><p>​在软件开发中，我们经常想要对一类对象添加不同的功能，例如要给手机添加贴膜，手机挂件，手机外壳等，如果此时利用继承来实现的话，就需要定义无数的类，如StickerPhone（贴膜是手机类）、AccessoriesPhone（挂件手机类）等，这样就会导致 ”子类爆炸“问题，为了解决这个问题，我们可以使用<strong>装饰者模式来动态地给一个对象添加额外的职责</strong>。</p><h4 id="②-装饰者设计模式介绍"><a href="#②-装饰者设计模式介绍" class="headerlink" title="② 装饰者设计模式介绍"></a>② 装饰者设计模式介绍</h4><p>​装饰者模式以对客户透明的方式动态地给一个对象附加上更多的责任，装饰者模式相比生成子类可以更灵活地增加功能。每个装饰的对象的实现就和如何使用这个对象分离开了，每个装饰对象只关心自己的功能，不需要关心如何被添加到对象链当中。</p><h4 id="③-实现-8"><a href="#③-实现-8" class="headerlink" title="③ 实现"></a>③ 实现</h4><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E8%80%85%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><blockquote><p>Component类</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Component</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ConcreteComponent类</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteComponent</span> : <span class="hljs-title">Component</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;具体对象的操作&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Decorator类</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Decorator</span> : <span class="hljs-title">Component</span><br>&#123;<br>    <span class="hljs-keyword">protected</span> Component component;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetComponent</span>(<span class="hljs-params">Component component</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.component=component<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(component != <span class="hljs-literal">null</span>)<br>        &#123;<br>            component.Operation();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ConcreteDecoratorA类</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteDecoratorA</span> :<span class="hljs-title">Decorator</span><br>&#123;<br>    <span class="hljs-comment">//本类独有的功能，以区别于ConcreteDecoratorB</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> addedState;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation</span>()</span><br>    &#123;<br>        <span class="hljs-comment">//首先运行原Component 的 Operation（），再执行本类的功能，如addedState，相当于对原Component进行了装饰</span><br>        <span class="hljs-keyword">base</span>.Operation();<br>        addedState=<span class="hljs-string">&quot;New State&quot;</span>;<br>        Console.WriteLine(<span class="hljs-string">&quot;具体装饰对象A的操作&quot;</span>)；<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteDecoratorB</span> :<span class="hljs-title">Decorator</span><br>&#123;<br>    <span class="hljs-comment">//本类独有的功能，以区别于ConcreteDecoratorB</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddedBehavior</span>()</span><br>    &#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation</span>()</span><br>    &#123;<br>        <span class="hljs-comment">//首先运行原Component 的 Operation（），再执行本类的功能，如AddedBehavior，相当于对原Component进行了装饰</span><br>        <span class="hljs-keyword">base</span>.Operation();<br>        AddedBehavior();<br>        Console.WriteLine(<span class="hljs-string">&quot;具体装饰对象B的操作&quot;</span>)；<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>客户端代码</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&#123;<br>    ConcreteComponent c = <span class="hljs-keyword">new</span> ConcreteComponent();<br>    ConcreteDecoratorA d1 = <span class="hljs-keyword">new</span> ConcreteDecoratorA();<br>    ConcreteDecoratorB d2 = <span class="hljs-keyword">new</span> ConcreteDecoratorB();<br>    <br>    d1.SetComponent(c);<br>    d2.SetComponent(d1);<br>    d2.Operation();<br>    <br>    Console.Read();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="④-优点和缺点-1"><a href="#④-优点和缺点-1" class="headerlink" title="④ 优点和缺点"></a>④ 优点和缺点</h4><p><strong>优点</strong>：</p><ol><li>装饰这模式和继承的目的都是扩展对象的功能，但装饰者模式比继承更灵活</li><li>通过使用不同的具体装饰类以及这些类的排列组合，设计师可以创造出很多不同行为的组合</li><li>装饰者模式有很好地可扩展性</li></ol><p><strong>缺点</strong>：装饰者模式会导致设计中出现许多小对象，如果过度使用，会让程序变的更复杂。并且更多的对象会是的差错变得困难，特别是这些对象看上去都很像。</p><h4 id="⑤-总结-3"><a href="#⑤-总结-3" class="headerlink" title="⑤ 总结"></a>⑤ 总结</h4><p><strong>装饰模式（Decorator）</strong>，动态地给一个对象添加一些额外地职责，就增加功能来说，装饰者模式比生成子类更加灵活。</p><hr><h3 id="4、组合模式"><a href="#4、组合模式" class="headerlink" title="4、组合模式"></a>4、组合模式</h3><h4 id="①-引言-8"><a href="#①-引言-8" class="headerlink" title="① 引言"></a>① 引言</h4><p>​在软件开发过程中，我们经常会遇到处理简单对象和复合对象的情况，例如对操作系统中目录的处理就是这样的一个例子，因为目录可以包括单独的文件，也可以包括文件夹，文件夹又是由文件组成的，由于简单对象和复合对象在功能上区别，导致在操作过程中必须区分简单对象和复合对象，这样就会导致客户调用带来不必要的麻烦，然而作为客户，它们希望能够始终一致地对待简单对象和复合对象。然而组合模式就是解决这样的问题。</p><h4 id="②-组合设计模式介绍"><a href="#②-组合设计模式介绍" class="headerlink" title="② 组合设计模式介绍"></a>② 组合设计模式介绍</h4><p>​组合模式允许你将对象组合成树形结构来表现”部分-整体“的层次结构，使得客户以一致的方式处理单个对象以及对象的组合。</p><p>​当发现<strong>需求中体现部分与整体层次的结构</strong>时，以及你<strong>希望用户可以忽略组合对象与单个对象的不同，统一地使用组合结构中地所有对象时，就应该考虑组合模式</strong>。</p><h4 id="③-实现-9"><a href="#③-实现-9" class="headerlink" title="③ 实现"></a>③ 实现</h4><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><blockquote><p>Component为组合中的对象声明接口，再适当情况下，实现所有类共有接口的默认行为。声明一个接口用于访问和管理Component的子部件</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Component</span><br>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-built_in">string</span> name;<br>    <br>    publicComponent(<span class="hljs-built_in">string</span> name)<br>    &#123;<br>        <span class="hljs-keyword">this</span>.name=name;<br>    &#125;<br>    <span class="hljs-comment">//通常都用Add和Remove方法来提高增加或溢出树叶或树枝的功能</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Add</span>(<span class="hljs-params">Component c</span>)</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Remove</span>(<span class="hljs-params">Componnent c</span>)</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Display</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> depth</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Leaf再组合中表示叶结点对象，叶节点没有子结点</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">Leaf</span> : <span class="hljs-title">Componnent</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Leaf</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>):<span class="hljs-title">base</span>(<span class="hljs-params">name</span>)</span>&#123;&#125;<br>    <br>    <span class="hljs-comment">//由于叶子没有再增加分支和树叶，所以Add和Remove方法实现它没有意义，但这样做可以消除叶节点和枝结点对象再抽象层次的区别，它们具备完全一致的接口</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Add</span>(<span class="hljs-params">Component c</span>)</span><br>    &#123;<br>        Console.writeLine(<span class="hljs-string">&quot;Cannot add to a leaf&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Remove</span>(<span class="hljs-params">Componnent c</span>)</span><br>    &#123;<br>        Console.writeLine(<span class="hljs-string">&quot;Cannot remove to a leaf&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//叶节点的具体方法，此处是显示其名称和级别</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Display</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> depth</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-keyword">new</span> String(<span class="hljs-string">&#x27;-&#x27;</span>,depth)+name);<br>    &#125;<br><br>    <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Composite 定义又枝节点行为，用来存储子部件，再Component接口中实现于子部件有关的操作，比如增加Add和删除Remove。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">Composite</span>:<span class="hljs-title">Component</span><br>&#123;<br>    <span class="hljs-comment">//一个子对象集合用来存储其下属的枝节点和叶节点</span><br>    <span class="hljs-keyword">private</span> List&lt;Component&gt;children = <span class="hljs-keyword">new</span> Lsit&lt;Component&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Composite</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>):<span class="hljs-title">base</span>(<span class="hljs-params">name</span>)</span><br>    &#123;<br>        <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Add</span>(<span class="hljs-params">Component c</span>)</span><br>    &#123;<br>        children.Add(c);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Remove</span>(<span class="hljs-params">Component c</span>)</span><br>    &#123;<br>        children.<span class="hljs-keyword">remove</span>(c);<br>    &#125;<br>    <br>    <span class="hljs-comment">//显示其枝节点名称，并对其下级进行遍历</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Display</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> depth</span>)</span><br>    &#123;<br>        Console.writeLine(<span class="hljs-keyword">new</span> String(<span class="hljs-string">&#x27;-&#x27;</span>,depth)+name);<br>        <span class="hljs-keyword">foreach</span>(Component component <span class="hljs-keyword">in</span> children )<br>        &#123;<br>            component.Display(depth+<span class="hljs-number">2</span>);<br>        &#125;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>客户端代码</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&#123;<br>    <span class="hljs-comment">//生成树根root，根上长出两叶LeafA和LeafB</span><br>    Composite root = <span class="hljs-keyword">new</span> Composite(<span class="hljs-string">&quot;root&quot;</span>);<br>    root.Add(<span class="hljs-keyword">new</span> Leaf(<span class="hljs-string">&quot;Leaf A&quot;</span>));<br>    root.Add(<span class="hljs-keyword">new</span> Leaf(<span class="hljs-string">&quot;Leaf B&quot;</span>));<br>    <br>    <span class="hljs-comment">//根上长出分值Composite X，分支上也有两叶LeafXA和LeafXB</span><br>    Composite comp = <span class="hljs-keyword">new</span> Composite(<span class="hljs-string">&quot;Composite X&quot;</span>);<br>    comp.Add(<span class="hljs-keyword">new</span> Leaf(<span class="hljs-string">&quot;Leaf XA&quot;</span>));<br>    comp.Add(<span class="hljs-keyword">new</span> Leaf(<span class="hljs-string">&quot;Leaf XB&quot;</span>));<br>    <br>    root.Add(comp);<br>    <br>    <span class="hljs-comment">//在Composite X上再长出分枝CompositeXY，分枝上也有两叶LeafXYA和LeafXYB</span><br>    Composite comp2=<span class="hljs-keyword">new</span> Composite(<span class="hljs-string">&quot;Composite XY&quot;</span>);<br>    comp2.Add(<span class="hljs-keyword">new</span> Leaf(<span class="hljs-string">&quot;Leaf XYA&quot;</span>));<br>    comp2.Add(<span class="hljs-keyword">new</span> Leaf(<span class="hljs-string">&quot;Leaf XYB&quot;</span>));<br>    <br>    comp.Add(comp2);<br>    <span class="hljs-comment">//根部又掌出两叶 C和D，可惜D没长牢，被风吹走了</span><br>    root.Add(<span class="hljs-keyword">new</span> Leaf(<span class="hljs-string">&quot;Leaf C&quot;</span>));<br>    <br>    Leaf leaf=newLeaf(<span class="hljs-string">&quot;Leaf D&quot;</span>);<br>    root.Add(leaf);<br>    root.Remove(leaf);<br>    <br>    <span class="hljs-comment">//显示大树的样子</span><br>    root.Display(<span class="hljs-number">1</span>);<br>    <br>    Console.Read();            <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="④-优点和缺点-2"><a href="#④-优点和缺点-2" class="headerlink" title="④ 优点和缺点"></a>④ 优点和缺点</h4><p><strong>优点：</strong></p><ol><li>组合模式使得客户端代码可以一致地处理对象和对象容器，无需关系处理的单个对象，还是组合的对象容器。</li><li>将”客户代码与复杂的对象容器结构“解耦。</li><li>可以更容易地往组合对象中加入新的构件。</li></ol><p><strong>缺点：</strong>使得设计更加复杂。客户端需要花更多时间理清类之间的层次关系。（这个是几乎所有设计模式所面临的问题）。</p><h4 id="⑤-总结-4"><a href="#⑤-总结-4" class="headerlink" title="⑤ 总结"></a>⑤ 总结</h4><p><strong>组合模式（Composite）</strong>，将对象组合成树形结构以表示‘部分-整体’的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p><hr><h3 id="5、外观模式"><a href="#5、外观模式" class="headerlink" title="5、外观模式"></a>5、外观模式</h3><h4 id="①-引言-9"><a href="#①-引言-9" class="headerlink" title="① 引言"></a>① 引言</h4><p>​在软件开发过程中，客户端程序经常会与复杂系统的内部子系统进行耦合，从而导致客户端程序随着子系统的变化而变化，然而为了将复杂系统的内部子系统与客户端之间的依赖解耦，从而就有了外观模式，也称作 ”门面“模式。</p><h4 id="②-外观设计模式介绍"><a href="#②-外观设计模式介绍" class="headerlink" title="② 外观设计模式介绍"></a>② 外观设计模式介绍</h4><p>​外观模式提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。使用外观模式时，我们创建了一个统一的类，用来包装子系统中一个或多个复杂的类，客户端可以直接通过外观类来调用内部子系统中方法，从而外观模式让客户和子系统之间避免了紧耦合。</p><h4 id="③-实现-10"><a href="#③-实现-10" class="headerlink" title="③ 实现"></a>③ 实现</h4><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><blockquote><p>四个子系统的类</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">SubSystemOne</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodOne</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;子系统方法一&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">SubsystemTwo</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MethodTwo</span>()</span><br>    &#123;<br>        Console,WriteLine(<span class="hljs-string">&quot;子系统方法二&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">SubsystemThree</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MethodThree</span>()</span><br>    &#123;<br>        Console,WriteLine(<span class="hljs-string">&quot;子系统方法三&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">SubsystemFour</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MethodFour</span>()</span><br>    &#123;<br>        Console,WriteLine(<span class="hljs-string">&quot;子系统方法四&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>外观类</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C#">SubsystemOne one;<br>SubsystemTwo two;<br>SubsystemThree three;<br>SubsystemFour four;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Facade</span>()</span><br>&#123;<br>    one = <span class="hljs-keyword">new</span> SubsystemOne();<br>tow = SubsystemTwo();<br>three = SubsystemThree();<br>four = SubsystemFour();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MethodA</span>()</span><br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;\n方法组A（）----&quot;</span>);<br>    one.MethodOne();<br>tow.MethodTwo();<br>four.MethodFour();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MethodB</span>()</span><br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;\n方法组B（）----&quot;</span>);<br>tow.MethodTwo();<br>three.MethodThree();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>客户端调用</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&#123;<br>    Facade facade=<span class="hljs-keyword">new</span> Facade();<br>    facade.MethodA();<br>    facade.MethodB();<br>    <br>    Console.Read();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="④-优点和缺点-3"><a href="#④-优点和缺点-3" class="headerlink" title="④ 优点和缺点"></a>④ 优点和缺点</h4><p><strong>优点：</strong></p><ol><li>外观模式对客户屏蔽了子系统组件，从而简化了接口，减少了客户处理的对象数目并使子系统的使用更加简单。</li><li>外观模式实现了子系统与客户之间的松耦合关系，而子系统内部的功能组件是紧耦合的。松耦合使得子系统的组件变化不会影响到它的客户。</li></ol><p><strong>缺点：</strong></p><ol><li>如果增加新的子系统可能需要修改外观类或客户端的源代码，这样就违背了”开——闭原则“（不过这点也是不可避免）。</li></ol><h4 id="⑤-总结-5"><a href="#⑤-总结-5" class="headerlink" title="⑤ 总结"></a>⑤ 总结</h4><p><strong>外观模式（Facade）</strong>，为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用</p><hr><h3 id="6、享元模式"><a href="#6、享元模式" class="headerlink" title="6、享元模式"></a>6、享元模式</h3><h4 id="①-引言-10"><a href="#①-引言-10" class="headerlink" title="① 引言"></a>① 引言</h4><p>​在软件开发过程，如果我们需要重复使用某个对象的时候，如果我们重复地使用new创建这个对象的话，这样我们在内存就需要多次地去申请内存空间了，这样可能会出现内存使用越来越多的情况，这样的问题是非常严重，然而享元模式可以解决这个问题。</p><h4 id="②-享元设计模式介绍"><a href="#②-享元设计模式介绍" class="headerlink" title="② 享元设计模式介绍"></a>② 享元设计模式介绍</h4><p>​享元模式——运用共享技术有效地支持大量细粒度的对象。享元模式可以避免大量相似类的开销，在软件开发中如果需要生成大量细粒度的类实例来表示数据，如果这些实例除了几个参数外基本上都是相同的，这时候就可以使用享元模式来大幅度减少需要实例化类的数量。如果能把这些参数（指的这些类实例不同的参数）移动类实例外面，在方法调用时将他们传递进来，这样就可以通过共享大幅度地减少单个实例的数目。（这个也是享元模式的实现要领）,然而我们把类实例外面的参数称为享元对象的外部状态，把在享元对象内部定义称为内部状态。具体享元对象的内部状态与外部状态的定义为：</p><p>​<strong>内部状态：</strong>在享元对象的内部并且不会随着环境的改变而改变的共享部分</p><p>​<strong>外部状态：</strong>随环境改变而改变的，不可以共享的状态。</p><p>​如果一个应用程序使用了大量的对象，而大量的这些对象造成了很大的存储开销时就应该考虑使用；还有就是对象的大多数状态可以外部状态，如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象，此时可以考虑使用享元模式。</p><h4 id="③-实现-11"><a href="#③-实现-11" class="headerlink" title="③ 实现"></a>③ 实现</h4><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><blockquote><p>Flyweight类，他是所有具体享元类的超类或接口，通过这个接口，Flyweight可以接受并作用于外部状态</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Flyweight</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> extrinsicstate</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ConcreteFlyweight 时继承 Flyweight 超类或实现Flyweight接口，并为内部状态增加存储空间。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteFlyweight</span> : <span class="hljs-title">Flyweight</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> extrinsicstate</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;具体Flyweight：&quot;</span>+extrinsicstate);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>UnsharedConcreteFlyweight 是指那些不需要共享的Flyweight子类。因为Flyweight接口共享成为可能，但它并不强制共享</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">UnsharedConcreteFlyweight</span> : <span class="hljs-title">Flyweight</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> extrinsicstate</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;不共享的具体Flyweight：&quot;</span>+extrinsicstate);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>FlyweightFactory,是一个享元工厂，用来创建并管理Flyweight对象。它主要是用来确保合理地共享Flyweight，当用户请求一个Flyweight时，FlyweightFactory对象提供一个已创建的实例或者创建一个（如果不存在的话）。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">FlyweightFactory</span><br>&#123;<br>    <span class="hljs-keyword">private</span> Hashtable flyweight = <span class="hljs-keyword">new</span> Hashtable();<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FlyweightFactory</span>()</span><br>    &#123;<br>        flyweights.Add(<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-keyword">new</span> ConcreteFlyweight());<br>        flyweights.Add(<span class="hljs-string">&quot;Y&quot;</span>,<span class="hljs-keyword">new</span> ConcreteFlyweight());<br>        flyweights.Add(<span class="hljs-string">&quot;Z&quot;</span>,<span class="hljs-keyword">new</span> ConcreteFlyweight());<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Flyweight <span class="hljs-title">GetFlyweight</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> key</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> ((Flyweight)flyweights[Key]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>客户端代码</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&#123;<br>    <span class="hljs-built_in">int</span> extrinsicstate=<span class="hljs-number">22</span>;<br>    <br>    FlyweightFactory f =<span class="hljs-keyword">new</span> FlyweightFactory();<br>    <br>    Flyweight fx=f.GetFlyweight(<span class="hljs-string">&quot;X&quot;</span>);<br>    fx.Operation(--extrinsicstate);<br>    <br>    Flyweight fy=f.GetFlyweight(<span class="hljs-string">&quot;Y&quot;</span>);<br>    fy.Operation(--extrinsicstate);<br>    <br>    Flyweight fz=f.GetFlyweight(<span class="hljs-string">&quot;Y&quot;</span>);<br>    fz.Operation(--extrinsicstate);<br>    <br>    UnsharedConcreteFlyweight uf=<span class="hljs-keyword">new</span> UnsharedConcreteFlyweight();<br>    <br>    uf.Operation(--extrinsicstate);<br>    <br>    Console.Read();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="④-优点和缺点-4"><a href="#④-优点和缺点-4" class="headerlink" title="④ 优点和缺点"></a>④ 优点和缺点</h4><p><strong>优点：</strong></p><ol><li>降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力。</li></ol><p><strong>缺点：</strong></p><ol><li>为了使对象可以共享，需要将一些状态外部化，这使得程序的逻辑更复杂，使系统复杂化。</li><li>享元模式将享元对象的状态外部化，而读取外部状态使得运行时间稍微变长。</li></ol><h4 id="⑤-总结-6"><a href="#⑤-总结-6" class="headerlink" title="⑤ 总结"></a>⑤ 总结</h4><p><strong>享元模式（Flyweight）</strong>运用共享技术有效地支持大量细粒度的对象。</p><hr><h3 id="7、代理模式"><a href="#7、代理模式" class="headerlink" title="7、代理模式"></a>7、代理模式</h3><h4 id="①-引言-11"><a href="#①-引言-11" class="headerlink" title="① 引言"></a>① 引言</h4><p>​在软件开发过程中，有些对象有时候会由于网络或其他的障碍，以至于不能够或者不能直接访问到这些对象，如果直接访问对象给系统带来不必要的复杂性，这时候可以在客户端和目标对象之间增加一层中间层，让代理对象代替目标对象，然后客户端只需要访问代理对象，由代理对象去帮我们去请求目标对象并返回结果给客户端，这样的一个解决思路就是代理模式。</p><h4 id="②-代理设计模式介绍"><a href="#②-代理设计模式介绍" class="headerlink" title="② 代理设计模式介绍"></a>② 代理设计模式介绍</h4><p>代理模式按照使用目的可以分为以下几种：</p><ul><li><strong>远程（Remote）代理：</strong>为一个位于不同的地址空间的对象提供一个局域代表对象。这个不同的地址空间可以是本电脑中，也可以在另一台电脑中。最典型的例子就是——客户端调用Web服务或WCF服务。</li><li><strong>虚拟（Virtual）代理：</strong>根据需要创建一个资源消耗较大的对象，使得对象只在需要时才会被真正创建。</li><li><strong>Copy-on-Write代理：</strong>虚拟代理的一种，把复制（或者叫克隆）拖延到只有在客户端需要时，才真正采取行动。</li><li><strong>保护（Protect or Access）代理：</strong>控制一个对象的访问，可以给不同的用户提供不同级别的使用权限。</li><li><strong>防火墙（Firewall）代理：</strong>保护目标不让恶意用户接近。</li><li><strong>智能引用（Smart Reference）代理：</strong>当一个对象被引用时，提供一些额外的操作，比如将对此对象调用的次数记录下来等。</li><li><strong>Cache代理：</strong>为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以这些结果。</li></ul><p>在上面所有种类的代理模式中，虚拟代理、远程代理、智能引用代理和保护代理较为常见的代理模式。</p><p>​代理模式——就是给某一个对象提供一个代理，并由代理对象控制对原对象的引用。在一些情况下，一个客户不想或者不能直接引用一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。</p><h4 id="③-实现-12"><a href="#③-实现-12" class="headerlink" title="③ 实现"></a>③ 实现</h4><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><blockquote><p>Subject 类，定义了RealSubject 和Proxy的共用接口，这样就在任何使用RealSubject的地方都可以使用Proxy</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Subject</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Request</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>RealSubject类，定义Proxy所代表的真实实体</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">RealSubject</span>:<span class="hljs-title">Subject</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Request</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;真实的请求&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Proxy类，保存一个引用使得代理可以访问实体，并提供一个与Subject的接口相同的接口，这样代理就可以替代实体</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">Proxy</span>:<span class="hljs-title">Subject</span><br>&#123;<br>    RealSubject realSubject;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Request</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(realSubject==<span class="hljs-literal">null</span>)<br>        &#123;<br>            realSubject=<span class="hljs-keyword">new</span> Realsubject();<br>        &#125;<br>        realSubject.Request();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>客户端代码</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&#123;<br>    Proxy proxy=<span class="hljs-keyword">new</span> proxy();<br>    proxy.Request();<br>    <br>    Conosle.Read();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="④-优点和缺点-5"><a href="#④-优点和缺点-5" class="headerlink" title="④ 优点和缺点"></a>④ 优点和缺点</h4><p><strong>优点：</strong></p><ol><li>代理模式能够将调用用于真正被调用的对象隔离，在一定程度上降低了系统的耦合度；</li><li>代理对象在客户端和目标对象之间起到一个中介的作用，这样可以起到对目标对象的保护。代理对象可以在对目标对象发出请求之前进行一个额外的操作，例如权限检查等。</li></ol><p><strong>缺点：</strong></p><ol><li>由于在客户端和真实主题之间增加了一个代理对象，所以会造成请求的处理速度变慢</li><li>实现代理类也需要额外的工作，从而增加了系统的实现复杂度。</li></ol><h4 id="⑤-总结-7"><a href="#⑤-总结-7" class="headerlink" title="⑤ 总结"></a>⑤ 总结</h4><p><strong>代理模式（Proxy）</strong>，为其他对象提供一种代理以控制这个对象的访问。</p><hr><h2 id="三、行为型设计模式"><a href="#三、行为型设计模式" class="headerlink" title="三、行为型设计模式"></a>三、行为型设计模式</h2><h3 id="1、模板方法模式"><a href="#1、模板方法模式" class="headerlink" title="1、模板方法模式"></a>1、模板方法模式</h3><h4 id="①-引言-12"><a href="#①-引言-12" class="headerlink" title="① 引言"></a>① 引言</h4><p>​提到模板，肯定不免想到生活中的“简历模板”、“论文模板”、“Word中模版文件”等，在现实生活中，模板的概念就是——有一个规定的格式，然后每个人都可以根据自己的需求或情况去更新它，例如简历模板，下载下来的简历模板的格式都是相同的，然而我们下载下来简历模板之后我们可以根据自己的情况填充不同的内容要完成属于自己的简历。在设计模式中，模板方法模式中模板和生活中模板概念非常类似.</p><h4 id="②-模板方法设计模式介绍"><a href="#②-模板方法设计模式介绍" class="headerlink" title="② 模板方法设计模式介绍"></a>② 模板方法设计模式介绍</h4><p>​模板方法模式——在一个抽象类中定义一个操作中的算法骨架（对应于生活中的大家下载的模板），而将一些步骤延迟到子类中去实现（对应于我们根据自己的情况向模板填充内容）。模板方法使得子类可以不改变一个算法的结构前提下，重新定义算法的某些特定步骤，模板方法模式把不变行为搬到超类中，从而去除了子类中的重复代码。</p><h4 id="③-实现-13"><a href="#③-实现-13" class="headerlink" title="③ 实现"></a>③ 实现</h4><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><blockquote><p>AbstractClass是抽象类，其实也就是一抽象模板，定义并实现了一个模板方法。这个模板方法一般是一个具体方方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤再相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AbstractClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrimitiveOperation1</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrimitiveOperation2</span>()</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TemplateMethod</span>()</span><br>    &#123;<br>        PrimitiveOperation1();<br>        PrimitiveOperation2();<br>        Console.WriteLine(<span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ConcreteClass,实现父类所定义的一个或多个抽象方法。每一个AbstractClass 都可以由任意多个ConcreteClass 与之对应，而每一个ConcreteClass都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteClassA</span> :<span class="hljs-title">AbstractClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrimitiveOperation1</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;具体类A的方法1实现&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrimitiveOperation2</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;具体类A的方法2实现&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteClassB</span> : <span class="hljs-title">AbstractClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrimitiveOperation1</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;具体类B的方法1实现&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrimitiveOperation2</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;具体类B的方法2实现&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>客户端调用</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&#123;<br>    AbstractClass c;<br>    <br>    c=<span class="hljs-keyword">new</span> ConcreteClassA();<br>    c.TemplateMethod();<br>    <br>    c=<span class="hljs-keyword">new</span> ConcreteClassB();<br>    c.TemplateMethod();<br>    <br>    Console.Read();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="④-优点和缺点-6"><a href="#④-优点和缺点-6" class="headerlink" title="④ 优点和缺点"></a>④ 优点和缺点</h4><p><strong>优点：</strong></p><ol><li>实现了代码复用</li><li>能够灵活应对子步骤的变化，符合开放-封闭原则</li></ol><p><strong>缺点</strong>：因为引入了一个抽象类，如果具体实现过多的话，需要用户或开发人员需要花更多的时间去理清类之间的关系。</p><p> 附：在.NET中模板方法的应用也很多，例如我们在开发自定义的Web控件或WinForm控件时，我们只需要重写某个控件的部分方法。</p><h4 id="⑤-总结-8"><a href="#⑤-总结-8" class="headerlink" title="⑤ 总结"></a>⑤ 总结</h4><p><strong>模板方法模式（TemplateMethod）</strong>，定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><hr><h3 id="2、命令模式"><a href="#2、命令模式" class="headerlink" title="2、命令模式"></a>2、命令模式</h3><h4 id="①-命令设计模式介绍"><a href="#①-命令设计模式介绍" class="headerlink" title="① 命令设计模式介绍"></a>① 命令设计模式介绍</h4><p>​命令模式属于对象的行为型模式。命令模式是把一个操作或者行为抽象为一个对象中，通过对命令的抽象化来使得发出命令的责任和执行命令的责任分隔开。命令模式的实现可以提供命令的撤销和恢复功能。</p><h4 id="②-实现"><a href="#②-实现" class="headerlink" title="② 实现"></a>② 实现</h4><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><blockquote><p>Command类，用来声明执行操作的接口</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Command</span><br>&#123;<br>    <span class="hljs-keyword">protected</span> Receiver receiver;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Command</span>(<span class="hljs-params">Receiver receive</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.receive=receive<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ConcreteCommand类，将一个接收者对象绑定于一个动作，调用接收者相应的操作，以实现Execute。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteCommand</span> : <span class="hljs-title">Command</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcreteCommand</span>(<span class="hljs-params">Reciver reciver</span>):<span class="hljs-title">base</span>(<span class="hljs-params">receiver</span>)</span><br>    &#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Execute</span>()</span><br>    &#123;<br>        receiver.Action();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Invoker类，要求该命令执行这个请求</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">Invoker</span><br>&#123;<br>    <span class="hljs-keyword">private</span> Command command;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetCommand</span>(<span class="hljs-params">Command command</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.command=command;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ExecuteCommand</span>()</span><br>    &#123;<br>        command.Execute();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Receiver类，知道如何实施与执行一个与请求相关的操作，任何类都可能作为一个接收者。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">Receiver</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Action</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;执行请求！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>客户端代码，创建一个具体命令对象并设定它的接收者。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&#123;<br>    Receiver r=<span class="hljs-keyword">new</span> Receiver();<br>    Command c=<span class="hljs-keyword">new</span> ConcreteCommand(r);<br>    Invoker i=<span class="hljs-keyword">new</span> Invoker();<br>    <br>    i.SetCommand(c);<br>    i.ExecuteCommand();<br>    <br>    Console.Read();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="③-优点和缺点"><a href="#③-优点和缺点" class="headerlink" title="③ 优点和缺点"></a>③ 优点和缺点</h4><p>命令模式使得命令发出的一个和接收的一方实现低耦合。</p><p><strong>优点：</strong></p><ul><li>命令模式使得新的命令很容易被加入到系统里。</li><li>可以设计一个命令队列来实现对请求的Undo和Redo操作。</li><li>可以较容易地将命令写入日志。</li><li>可以把命令对象聚合在一起，合成为合成命令。合成命令式合成模式的应用。</li></ul><p><strong>缺点：</strong></p><ul><li>使用命令模式可能会导致系统有过多的具体命令类。这会使得命令模式在这样的系统里变得不实际。</li></ul><h4 id="④-总结-1"><a href="#④-总结-1" class="headerlink" title="④ 总结"></a>④ 总结</h4><p><strong>命令模式（Command）</strong>将一个请求封装为一个对象，从而使你可用不同的请求队客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。</p><hr><h3 id="3、迭代器模式"><a href="#3、迭代器模式" class="headerlink" title="3、迭代器模式"></a>3、迭代器模式</h3><h4 id="①-引言-13"><a href="#①-引言-13" class="headerlink" title="① 引言"></a>① 引言</h4><p>​迭代器是针对集合对象而生的，对于集合对象而言，必然涉及到集合元素的添加删除操作，同时也肯定支持遍历集合元素的操作，我们此时可以把遍历操作也放在集合对象中，但这样的话，集合对象就承担太多的责任了，面向对象设计原则中有一条是单一职责原则，所以我们要尽可能地分离这些职责，用不同的类去承担不同的职责。迭代器模式就是用迭代器类来承担遍历集合元素的职责。</p><h4 id="②-迭代器设计模式介绍"><a href="#②-迭代器设计模式介绍" class="headerlink" title="② 迭代器设计模式介绍"></a>② 迭代器设计模式介绍</h4><p>​迭代器模式提供了一种方法顺序访问一个聚合对象（理解为集合对象）中各个元素，而又无需暴露该对象的内部表示，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。</p><h4 id="③-实现-14"><a href="#③-实现-14" class="headerlink" title="③ 实现"></a>③ 实现</h4><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><blockquote><p>Iterator迭代器抽象类</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Iterator</span><br>&#123;<br>    <span class="hljs-comment">//用于定义得到开始对象、得到下一个对象、判断是否到结尾、当前对象等抽象方法、统一接口</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-built_in">object</span> <span class="hljs-title">First</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-built_in">object</span> <span class="hljs-title">Next</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">IsDone</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-built_in">object</span> <span class="hljs-title">CurrentItem</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Aggregate 聚集抽象类</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Aggregate</span><br>&#123;<br>    <span class="hljs-comment">//创建迭代器</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Iterator <span class="hljs-title">CreateIterator</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ConcreteIterator具体迭代器类，继承Iterator</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteIterator</span>:<span class="hljs-title">Iterator</span><br>&#123;<br>    <span class="hljs-comment">//定义了一个具体聚集对象</span><br>    <span class="hljs-keyword">private</span> ConcreteAggregate aggregate;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> current = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">//初始化时具体的聚集对象传入</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcreteIterator</span>(<span class="hljs-params">ConcreteAggregate aggregate</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.aggregate=aggregate;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">object</span> <span class="hljs-title">First</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> aggregate[<span class="hljs-number">0</span>]<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">object</span> <span class="hljs-title">Next</span>()</span><br>    &#123;<br>        <span class="hljs-built_in">object</span> ret =<span class="hljs-literal">null</span>;<br>        current++;<br>        <span class="hljs-keyword">if</span>(current&lt;aggregate.Count)<br>        &#123;<br>            ret=aggregate[current];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">IsDone</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> current &gt;= aggregate.Count?<span class="hljs-literal">true</span>:<span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">object</span> <span class="hljs-title">CurrentItem</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> aggregate[current];<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ConcreteAggregate具体聚集类 继承 Aggregate</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteAggregate</span> : <span class="hljs-title">Aggregate</span><br>&#123;<br>    <span class="hljs-keyword">private</span> IList&lt;<span class="hljs-built_in">object</span>&gt; items=<span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">object</span>&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> Iterator <span class="hljs-title">CreateIterator</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConcreteIterator(<span class="hljs-keyword">this</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Count<br>    &#123;<br>        <span class="hljs-keyword">get</span>&#123;<span class="hljs-keyword">return</span> items.Count;&#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">object</span> <span class="hljs-keyword">this</span>[<span class="hljs-built_in">int</span> index]<br>    &#123;<br>        <span class="hljs-keyword">get</span>&#123;<span class="hljs-keyword">return</span> items[index];&#125;<br>        <span class="hljs-keyword">set</span>&#123;items.Insert(index,<span class="hljs-keyword">value</span>);&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>客户端代码</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C#">ConcreteAggregate a=<span class="hljs-keyword">new</span> ConcreteAggregate();<br><br>a[<span class="hljs-number">0</span>]=<span class="hljs-string">&quot;0&quot;</span>;<br>a[<span class="hljs-number">1</span>]=<span class="hljs-string">&quot;1&quot;</span>;<br>a[<span class="hljs-number">2</span>]=<span class="hljs-string">&quot;2&quot;</span>;<br>a[<span class="hljs-number">3</span>]=<span class="hljs-string">&quot;3&quot;</span>;<br>a[<span class="hljs-number">4</span>]=<span class="hljs-string">&quot;4&quot;</span>;<br>a[<span class="hljs-number">5</span>]=<span class="hljs-string">&quot;5&quot;</span>;<br><br>Iterator i=<span class="hljs-keyword">new</span> ConcreteIterator(a);<br><span class="hljs-built_in">object</span> item=i.First();<br><span class="hljs-keyword">while</span>(!i.IsDone())<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;&#123;0&#125; 请买车票&quot;</span>,i.CuurentItem());<br>    <br>    Console.Read();<br>        <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="④-Net的迭代器实现"><a href="#④-Net的迭代器实现" class="headerlink" title="④ .Net的迭代器实现"></a>④ .Net的迭代器实现</h4><blockquote><p>IEumerator 支持对非泛型集合的简单迭代器接口</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IEumerator</span><br>&#123;<br>    <span class="hljs-built_in">object</span> Current<br>    &#123;<br>        <span class="hljs-keyword">get</span>;<br>    &#125;<br>    <span class="hljs-comment">//将枚举数推进到集合的下一个元素。</span><br>    <span class="hljs-comment">//true表示成功</span><br>    <span class="hljs-comment">//false表示位于集合末尾</span><br>    <span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">MoveNext</span>()</span>;<br>   <br>    <span class="hljs-comment">//恢复初始化指向的位置，该位置位于集合中第一个元素之前</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Reset</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>IEumerable 公开枚举数，该枚举数支持在非泛型集合上进行简单迭代</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IEnumerable</span><br>&#123;<br>    <span class="hljs-comment">//返回一个循环访问集合的枚举数</span><br>    <span class="hljs-function">IEumerator <span class="hljs-title">GetEnumerator</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>foreach应用</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C#">IList&lt;<span class="hljs-built_in">string</span>&gt; a=<span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">string</span>&gt;();<br><span class="hljs-keyword">foreach</span>(<span class="hljs-built_in">string</span> item <span class="hljs-keyword">in</span> a)<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>编译器里foreach实际上运用</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C#">IEnumerator&lt;<span class="hljs-built_in">string</span>&gt; e=a.GetEnumerator();<br><br><span class="hljs-keyword">while</span>(e.MoveNext())<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="⑤-优点和缺点-2"><a href="#⑤-优点和缺点-2" class="headerlink" title="⑤ 优点和缺点"></a>⑤ 优点和缺点</h4><p>​<strong>优点：</strong></p><ul><li>迭代器模式使得访问一个聚合对象的内容而无需暴露它的内部表示，即迭代抽象。</li><li>迭代器模式为遍历不同的集合结构提供了一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作</li></ul><p>　<strong>缺点：</strong></p><ul><li>迭代器模式在遍历的同时更改迭代器所在的集合结构会导致出现异常。所以使用foreach语句只能在对集合进行遍历，不能在遍历的同时更改集合中的元素。</li></ul><h4 id="⑥-总结-2"><a href="#⑥-总结-2" class="headerlink" title="⑥ 总结"></a>⑥ 总结</h4><p><strong>迭代器模式(Iterator)</strong>,提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。</p><hr><h3 id="4、观察者模式"><a href="#4、观察者模式" class="headerlink" title="4、观察者模式"></a>4、观察者模式</h3><h4 id="①-引言-14"><a href="#①-引言-14" class="headerlink" title="① 引言"></a>① 引言</h4><p>​在现实生活中，处处可见观察者模式，例如，微信中的订阅号，订阅博客和QQ微博中关注好友，这些都属于观察者模式的应用。</p><h4 id="②-观察者设计模式介绍"><a href="#②-观察者设计模式介绍" class="headerlink" title="② 观察者设计模式介绍"></a>② 观察者设计模式介绍</h4><p>​从生活中的例子可以看出，只要对订阅号进行关注的客户端，如果订阅号有什么更新，就会直接推送给订阅了的用户。从中，我们就可以得出观察者模式的定义。</p><p>　　观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象，这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己的行为。</p><h4 id="③-实现-15"><a href="#③-实现-15" class="headerlink" title="③ 实现"></a>③ 实现</h4><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E7%BB%93%E6%9E%84%E5%9B%BE.jpg"></p><blockquote><p>Subject类，可以翻译为主题或者抽象通知者，一般用一个抽象类或者一个接口实现。它把所有对观察者对象的引用保存在一个聚集里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Subject</span><br>&#123;<br>    <span class="hljs-keyword">private</span> IList&lt;Observer&gt; observers=<span class="hljs-keyword">new</span> List&lt;Observer&gt;();<br>    <span class="hljs-comment">//增加观察者</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Attach</span>(<span class="hljs-params">Observer observer</span>)</span><br>    &#123;<br>        observer.Add(observer);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Detach</span>(<span class="hljs-params">Observer observer</span>)</span><br>    &#123;<br>        observer.Remove(observer);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Notify</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">foreach</span>(Observer o <span class="hljs-keyword">in</span> observer)<br>        &#123;<br>            o.Update();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>Observer类，抽象观察者，为所有的具体观察者定义一个接口，在得到主题的通知时更新自己。这个接口叫做更新接口。抽象观察者一般用一个抽象类或者一个接口实现。更新接口通常包含一个Update（）方法，这个方法叫做更新方法。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Observer</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ConvreteSubject类，叫做具体主题或者具体通知者，将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色通常用一个具体子类实现。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteSubject</span> :　<span class="hljs-title">Subject</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> subjectState;<br>    <span class="hljs-comment">//具体观察者状态</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> SubjectState<br>    &#123;<br>        <span class="hljs-keyword">get</span>;<br>        <span class="hljs-keyword">set</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ConvreteObserver类，具体观察者，实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。具体观察者角色可以保存一个指向具体主题对象的引用。具体观察者角色通常用一给具体子类实现</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">ConvreteObserver</span> : <span class="hljs-title">Observer</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> observerState;<br>    <span class="hljs-keyword">private</span> ConcreteSubject subject;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcreteObsercer</span>(<span class="hljs-params">ConvreteSubject subject,<span class="hljs-built_in">string</span> name</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.subject=subject;<br>        <span class="hljs-keyword">this</span>.name=name;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span><br>    &#123;<br>        obseverState=subject.SubjectState;<br>        Console.WriteLine(<span class="hljs-string">&quot;观察者&#123;0&#125;的新状态&#123;1&#125;&quot;</span>,name,observerState);<br>    &#125;<br>    <span class="hljs-keyword">public</span> ConcreteSubject Subject<br>    &#123;<br>        <span class="hljs-keyword">get</span>;<br>        <span class="hljs-keyword">set</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>客户端代码</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&#123;<br>    ConcreteSubject s= <span class="hljs-keyword">new</span> ConcreteSubject();<br>    <br>    s.Attach(<span class="hljs-keyword">new</span> ConcreteObserver(s,<span class="hljs-string">&quot;X&quot;</span>));<br>    s.Attach(<span class="hljs-keyword">new</span> ConcreteObserver(s,<span class="hljs-string">&quot;Y&quot;</span>));<br>    s.Attach(<span class="hljs-keyword">new</span> ConcreteObserver(s,<span class="hljs-string">&quot;Z&quot;</span>));<br>    <br>    s.SubjectState=<span class="hljs-string">&quot;ABC&quot;</span>;<br>    s.Notify();<br>    <br>    Console.Read();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="④-优点和缺点-7"><a href="#④-优点和缺点-7" class="headerlink" title="④ 优点和缺点"></a>④ 优点和缺点</h4><p>​<strong>优点：</strong></p><ul><li>观察者模式实现了表示层和数据逻辑层的分离，并定义了稳定的更新消息传递机制，并抽象了更新接口，使得可以有各种各样不同的表示层，即观察者。</li><li>观察者模式在被观察者和观察者之间建立了一个抽象的耦合，被观察者并不知道任何一个具体的观察者，只是保存着抽象观察者的列表，每个具体观察者都符合一个抽象观察者的接口。</li><li>观察者模式支持广播通信。被观察者会向所有的注册过的观察者发出通知。</li></ul><p>　　<strong>缺点：</strong></p><ul><li>如果一个被观察者有很多直接和间接的观察者时，将所有的观察者都通知到会花费很多时间。</li><li>虽然观察者模式可以随时使观察者知道所观察的对象发送了变化，但是观察者模式没有相应的机制使观察者知道所观察的对象是怎样发生变化的。</li><li>如果在被观察者之间有循环依赖的话，被观察者会触发它们之间进行循环调用，导致系统崩溃，在使用观察者模式应特别注意这点。</li></ul><h4 id="⑤-总结-9"><a href="#⑤-总结-9" class="headerlink" title="⑤ 总结"></a>⑤ 总结</h4><p><strong>观察者模式（Observer）</strong>定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。</p><hr><h3 id="5、中介者模式"><a href="#5、中介者模式" class="headerlink" title="5、中介者模式"></a>5、中介者模式</h3><h4 id="①-引言-15"><a href="#①-引言-15" class="headerlink" title="① 引言"></a>① 引言</h4><p>​从生活中的例子可以看出，不论是QQ游戏还是QQ群，它们都是充当一个中间平台，QQ用户可以登录这个中间平台与其他QQ用户进行交流，如果没有这些中间平台，我们如果想与朋友进行聊天的话，可能就需要当面才可以了。电话、短信也同样是一个中间平台，有了这个中间平台，每个用户都不要直接依赖与其他用户，只需要依赖这个中间平台就可以了，一切操作都由中间平台去分发。</p><h4 id="②-中介者设计模式介绍"><a href="#②-中介者设计模式介绍" class="headerlink" title="② 中介者设计模式介绍"></a>② 中介者设计模式介绍</h4><p>​中介者模式，定义了一个中介对象来封装一系列对象之间的交互关系。中介者使各个对象之间不需要显式地相互引用，从而使耦合性降低，而且可以独立地改变它们之间的交互行为。</p><h4 id="③-实现-16"><a href="#③-实现-16" class="headerlink" title="③ 实现"></a>③ 实现</h4><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><blockquote><p>Mediator类抽象中介者类</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Mediator</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Send</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message,Colleague colleague</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Colleague类抽象同事类</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Colleague</span><br>&#123;<br>    <span class="hljs-keyword">protected</span> Mediator mediator;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Colleague</span>(<span class="hljs-params">Mediator mediator</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.mediator=mediator;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ConcreteMediator类具体中介者类</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteMediator</span> : <span class="hljs-title">Mediator</span><br>&#123;<br>    <span class="hljs-keyword">private</span> ConcreteColleague1 colleague1;<br>    <span class="hljs-keyword">private</span> ConcreteColleague2 colleague2;<br>    <br>    <span class="hljs-keyword">public</span>  ConcreteColleague1 colleague1<br>    &#123;<br>        <span class="hljs-keyword">set</span>&#123;colleague1=<span class="hljs-keyword">value</span>;&#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> ConcreteColleague2 colleague2<br>    &#123;<br>        <span class="hljs-keyword">set</span>&#123;colleague2=<span class="hljs-keyword">value</span>;&#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Send</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message,Colleague colleague</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(colleague==colleague1)<br>        &#123;<br>            colleague2.Notify(message);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            colleague1.Notify(message);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ConcreteColleague1和 ConcreteColleague2等各种同事对象</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteColleague1</span> :<span class="hljs-title">Colleague</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcreteColleague1</span>(<span class="hljs-params">Mediator mediator</span>):<span class="hljs-title">base</span>(<span class="hljs-params">mediator</span>)</span><br>    &#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Send</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        mediator.Send(message,<span class="hljs-keyword">this</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Notify</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;同事1得到信息：&quot;</span>+message);<br>    &#125;<br>    <br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteColleague2</span> :<span class="hljs-title">Colleague</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcreteColleague2</span>(<span class="hljs-params">Mediator mediator</span>):<span class="hljs-title">base</span>(<span class="hljs-params">mediator</span>)</span><br>    &#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Send</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        mediator.Send(message,<span class="hljs-keyword">this</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Notify</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;同事2得到信息：&quot;</span>+message);<br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p>客户端调用</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&#123;<br>    ConcreteMediator m = <span class="hljs-keyword">new</span> ConcreteMediator();<br>    <br>    ConcreteColleague1 c1 = <span class="hljs-keyword">new</span> concreteColleague1(m);<br>    ConcreteColleague2 c2 = <span class="hljs-keyword">new</span> concreteColleague2(m);<br>    <br>    m.Colleague1 = c1;<br>    m.Colleague2 = c2;<br>    <br>    c1.Send(<span class="hljs-string">&quot;吃过饭了吗?&quot;</span>);<br>    c2.Send(<span class="hljs-string">&quot;没有呢，你打算请客？&quot;</span>);<br>    <br>    Console.Read(); <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="④-优点和缺点-8"><a href="#④-优点和缺点-8" class="headerlink" title="④ 优点和缺点"></a>④ 优点和缺点</h4><p>​<strong>优点：</strong></p><ul><li>简化了对象之间的关系，将系统的各个对象之间的相互关系进行封装，将各个同事类解耦，使得系统变为松耦合。</li><li>提供系统的灵活性，使得各个同事对象独立而易于复用。</li></ul><p>　　<strong>缺点：</strong></p><ul><li>中介者模式中，中介者角色承担了较多的责任，所以一旦这个中介者对象出现了问题，整个系统将会受到重大的影响。例如，QQ游戏中计算欢乐豆的程序出错了，这样会造成重大的影响。</li><li>新增加一个同事类时，不得不去修改抽象中介者类和具体中介者类，此时可以使用观察者模式和状态模式来解决这个问题。</li></ul><h4 id="⑤-总结-10"><a href="#⑤-总结-10" class="headerlink" title="⑤ 总结"></a>⑤ 总结</h4><p><strong>中介者模式（Mediator）</strong>，用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显示地交互引用，从而使其耦合松散，而且可以独立地改变使它们之间地交互。</p><hr><h3 id="6、状态者模式"><a href="#6、状态者模式" class="headerlink" title="6、状态者模式"></a>6、状态者模式</h3><h4 id="①-引言-16"><a href="#①-引言-16" class="headerlink" title="① 引言"></a>① 引言</h4><p>​每个对象都有其对应的状态，而每个状态又对应一些相应的行为，如果某个对象有多个状态时，那么就会对应很多的行为。那么对这些状态的判断和根据状态完成的行为，就会导致多重条件语句，并且如果添加一种新的状态时，需要更改之前现有的代码。这样的设计显然违背了开闭原则。状态模式正是用来解决这样的问题的。状态模式将每种状态对应的行为抽象出来成为单独新的对象，这样状态的变化不再依赖于对象内部的行为。</p><h4 id="②-状态者设计模式介绍"><a href="#②-状态者设计模式介绍" class="headerlink" title="② 状态者设计模式介绍"></a>② 状态者设计模式介绍</h4><p>​状态模式——允许一个对象在其内部状态改变时自动改变其行为，对象看起来就像是改变了它的类。</p><h4 id="③-实现-17"><a href="#③-实现-17" class="headerlink" title="③ 实现"></a>③ 实现</h4><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E8%80%85%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><blockquote><p>State类，抽象状态类，定义一个接口以封装与Context的一个特定状态相关的行为。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">State</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Handle</span>(<span class="hljs-params">Context context</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ConcreteState类，具体状态，每一个子类实现一个与Context 的一个状态相关的行为。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteStateA</span> : <span class="hljs-title">state</span><br>&#123;<br>    <span class="hljs-comment">//设置 ConcreteStateA 的下一状态是ConcreteStateB</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Handle</span>(<span class="hljs-params">Context context</span>)</span><br>    &#123;<br>        context.State= <span class="hljs-keyword">new</span> ConcreteStateB();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteStateB</span> : <span class="hljs-title">state</span><br>&#123;<br>    <span class="hljs-comment">//设置 ConcreteStateB 的下一状态是ConcreteStateA</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Handle</span>(<span class="hljs-params">Context context</span>)</span><br>    &#123;<br>        context.State= <span class="hljs-keyword">new</span> ConcreteStateA();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Context类，维护一个ConcreteState子类的实例，这个实例定义当前的状态。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">Context</span><br>&#123;<br>    <span class="hljs-keyword">private</span> State state;<br>    <span class="hljs-comment">//定义Context的初始状态</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Context</span>(<span class="hljs-params">State state</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.state=state;<br>    &#125;<br>    <br>     <span class="hljs-comment">//可读写的状态属性，用于读取当前状态和设置新状态</span><br>     <span class="hljs-keyword">public</span> State state<br>     &#123;<br>     <span class="hljs-keyword">get</span>&#123;<span class="hljs-keyword">return</span> state;&#125;<br>        <span class="hljs-keyword">set</span><br>        &#123;<br>        state=<span class="hljs-keyword">value</span>;<br>            Console.WriteLine(<span class="hljs-string">&quot;当前状态：&quot;</span>+state.GetType().Name);<br>        &#125;<br>     &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Request</span>()</span><br>    &#123;<br>        <span class="hljs-comment">//对请求做处理，并设置下以状态</span><br>        state.Handle(<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>客户端代码</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&#123;<br>    <span class="hljs-comment">//设置Context的初始状态为ConcreteStateA</span><br>    Context c = <span class="hljs-keyword">new</span> Context(<span class="hljs-keyword">new</span> ConcreteStateA());<br>    <br>    <span class="hljs-comment">//不断请求，同时更改状态</span><br>    c.Request();<br>    c.Request();<br>    c.Request();<br>    c.Request();<br>    <br>    Console.Read();<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="④-优点和缺点-9"><a href="#④-优点和缺点-9" class="headerlink" title="④ 优点和缺点"></a>④ 优点和缺点</h4><p>​<strong>优点：</strong></p><ul><li>将状态判断逻辑每个状态类里面，可以简化判断的逻辑。</li><li>当有新的状态出现时，可以通过添加新的状态类来进行扩展，扩展性好。</li></ul><p>​<strong>缺点：</strong></p><ul><li>如果状态过多的话，会导致有非常多的状态类，加大了开销。</li></ul><h4 id="⑤-总结-11"><a href="#⑤-总结-11" class="headerlink" title="⑤ 总结"></a>⑤ 总结</h4><p><strong>状态模式（State）</strong>，当一个对象地内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。</p><hr><h3 id="7、策略者模式"><a href="#7、策略者模式" class="headerlink" title="7、策略者模式"></a>7、策略者模式</h3><h4 id="①-引言-17"><a href="#①-引言-17" class="headerlink" title="① 引言"></a>① 引言</h4><p>​在现实生活中，策略模式的例子也非常常见，例如，中国的所得税，分为企业所得税、外商投资企业或外商企业所得税和个人所得税，针对于这3种所得税，针对每种，所计算的方式不同，个人所得税有个人所得税的计算方式，而企业所得税有其对应计算方式。如果不采用策略模式来实现这样一个需求的话，可能我们会定义一个所得税类，该类有一个属性来标识所得税的类型，并且有一个计算税收的CalculateTax()方法，在该方法体内需要对税收类型进行判断，通过if-else语句来针对不同的税收类型来计算其所得税。这样的实现确实可以解决这个场景吗，但是这样的设计不利于扩展，如果系统后期需要增加一种所得税时，此时不得不回去修改CalculateTax方法来多添加一个判断语句，这样明白违背了“开放——封闭”原则。此时，我们可以考虑使用策略模式来解决这个问题，既然税收方法是这个场景中的变化部分，此时自然可以想到对税收方法进行抽象。</p><h4 id="②-策略者设计模式介绍"><a href="#②-策略者设计模式介绍" class="headerlink" title="② 策略者设计模式介绍"></a>② 策略者设计模式介绍</h4><p>​策略模式是对算法的包装，是把使用算法的责任和算法本身分割开，委派给不同的对象负责。策略模式通常把一系列的算法包装到一系列的策略类里面。用一句话慨括策略模式就是——“将每个算法封装到不同的策略类中，使得它们可以互换”</p><h4 id="③-实现-18"><a href="#③-实现-18" class="headerlink" title="③ 实现"></a>③ 实现</h4><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><blockquote><p>Strategy类,定义所有支持的算法的公共接口</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Starategy</span><br>&#123;<br>    <span class="hljs-comment">//算法方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AlgorithmInterface</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ConcreteStrategy，封装了具体的算法或行为，继承于Strategy</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteStrategyA</span> : <span class="hljs-title">Strategy</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AlgorithmInterface</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;算法A实现&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteStrategyB</span> : <span class="hljs-title">Strategy</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AlgorithmInterface</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;算法B实现&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteStrategyC</span> : <span class="hljs-title">Strategy</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AlgorithmInterface</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;算法C实现&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Context，用一个 ConcreteStrategy来配置，维护一个对Strategy对象引用</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">Context</span><br>&#123;<br>    Strategy strategy;<br>    <span class="hljs-comment">//初始化时，传入具体的策略对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Context</span>(<span class="hljs-params">Strategy strategy</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.strategy=strategy;<br>    &#125;<br>    <span class="hljs-comment">//上下文接口</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ContextInterface</span>()</span><br>    &#123;<br>        <span class="hljs-comment">//根据具体的策略对象，调用其算法的方法</span><br>        strategy.AlgorithmInterface();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>客户端代码</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&#123;<br>    Context context;<br>    <br>    <span class="hljs-comment">//由于实例化不同的策略，所以最终在调用context.ContextInterface();时，所获得的结果就不尽相同</span><br>    context=<span class="hljs-keyword">new</span> Context(<span class="hljs-keyword">new</span> ConcreteStrategyA());<br>    context.ContextInerface();<br>    <br>    context=<span class="hljs-keyword">new</span> Context(<span class="hljs-keyword">new</span> ConcreteStrategyB());<br>    context.ContextInerface();<br>    <br>    context=<span class="hljs-keyword">new</span> Context(<span class="hljs-keyword">new</span> ConcreteStrategyC());<br>    context.ContextInerface();<br>    <br>    Console.Read();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="④-优点和缺点-10"><a href="#④-优点和缺点-10" class="headerlink" title="④ 优点和缺点"></a>④ 优点和缺点</h4><p>​<strong>优点：</strong></p><ul><li>策略类之间可以自由切换。由于策略类都实现同一个接口，所以使它们之间可以自由切换。</li><li>易于扩展。增加一个新的策略只需要添加一个具体的策略类即可，基本不需要改变原有的代码。</li><li>避免使用多重条件选择语句，充分体现面向对象设计思想。</li></ul><p>　　<strong>缺点：</strong></p><ul><li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这点可以考虑使用IOC容器和依赖注入的方式来解决，关于IOC容器和依赖注入（Dependency Inject）的文章可以参考：<a href="http://www.cnblogs.com/lusd/articles/3175062.html">IoC 容器和Dependency Injection 模式</a>。</li><li>策略模式会造成很多的策略类。</li></ul><h4 id="⑤-总结-12"><a href="#⑤-总结-12" class="headerlink" title="⑤ 总结"></a>⑤ 总结</h4><p><strong>策略模式（Strategy）</strong>：它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。</p><hr><h3 id="8、责任链模式"><a href="#8、责任链模式" class="headerlink" title="8、责任链模式"></a>8、责任链模式</h3><h4 id="①-引言-18"><a href="#①-引言-18" class="headerlink" title="① 引言"></a>① 引言</h4><p>​在现实生活中，有很多请求并不是一个人说了就算的，例如面试时的工资，低于1万的薪水可能技术经理就可以决定了，但是1万~1万5的薪水可能技术经理就没这个权利批准，可能就需要请求技术总监的批准，所以在面试的完后，经常会有面试官说，你这个薪水我这边觉得你这技术可以拿这个薪水的，但是还需要技术总监的批准等的话。这个例子也就诠释了本文要介绍的内容。生活中的这个例子真是应用了责任链模式。</p><h4 id="②-责任链设计模式介绍"><a href="#②-责任链设计模式介绍" class="headerlink" title="② 责任链设计模式介绍"></a>② 责任链设计模式介绍</h4><p>​责任链模式指的是——某个请求需要多个对象进行处理，从而避免请求的发送者和接收之间的耦合关系。将这些对象连成一条链子，并沿着这条链子传递该请求，直到有对象处理它为止。</p><h4 id="③-实现-19"><a href="#③-实现-19" class="headerlink" title="③ 实现"></a>③ 实现</h4><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%B4%A3%E4%BB%BB%E9%93%BE%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><blockquote><p>Handler类，定义一个处理请示的接口。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Handler</span><br>&#123;<br>    <span class="hljs-keyword">protected</span> Handler successor;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SetSuccessor</span>(<span class="hljs-params">Handler successor</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.successor=successor;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HandleRequest</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> request</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ConcreteHandler类，具体处理者类，处理它所负责的请求，可访问它的后继者，如果可处理该请求,就处理之，否则就将该请求转发给它的后继者。</p><p>ConcreteHandler1，当请求数在0到10之间则有权处理，否则转到下一位。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteHandler1</span> :　<span class="hljs-title">Handler</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HandleRequest</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> request</span>)</span><br>    &#123;<br>        <span class="hljs-comment">//0到10，处理此请求</span><br>        <span class="hljs-keyword">if</span>(request&gt;=<span class="hljs-number">0</span> &amp;&amp; request&lt;<span class="hljs-number">10</span>)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;&#123;0&#125;处理请求&#123;1&#125;&quot;</span>,<span class="hljs-keyword">this</span>.GetType().Name,request);<br>            <br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(successor!=<span class="hljs-literal">null</span>)<br>        &#123;<br>            <span class="hljs-comment">//转移到下一位</span><br>            successor.HandleRequest(request);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ConcreteHandler2，当请求数在10到20之间则有权处理，否则转到下一位。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteHandler2</span> :　<span class="hljs-title">Handler</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HandleRequest</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> request</span>)</span><br>    &#123;<br>        <span class="hljs-comment">//10到20，处理此请求</span><br>        <span class="hljs-keyword">if</span>(request&gt;=<span class="hljs-number">10</span> &amp;&amp; request&lt;<span class="hljs-number">20</span>)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;&#123;0&#125;处理请求&#123;1&#125;&quot;</span>,<span class="hljs-keyword">this</span>.GetType().Name,request);<br>            <br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(successor!=<span class="hljs-literal">null</span>)<br>        &#123;<br>            <span class="hljs-comment">//转移到下一位</span><br>            successor.HandleRequest(request);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ConcreteHandler3，当请求数在20到30之间则有权处理，否则转到下一位。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteHandler3</span> :　<span class="hljs-title">Handler</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HandleRequest</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> request</span>)</span><br>    &#123;<br>        <span class="hljs-comment">//20到30，处理此请求</span><br>        <span class="hljs-keyword">if</span>(request&gt;=<span class="hljs-number">20</span> &amp;&amp; request&lt;<span class="hljs-number">30</span>)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;&#123;0&#125;处理请求&#123;1&#125;&quot;</span>,<span class="hljs-keyword">this</span>.GetType().Name,request);<br>            <br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(successor!=<span class="hljs-literal">null</span>)<br>        &#123;<br>            <span class="hljs-comment">//转移到下一位</span><br>            successor.HandleRequest(request);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p> 客户端代码，向链上的具体处理者对象提交请求</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&#123;<br>    Handlder h1 = <span class="hljs-keyword">new</span> COncreteHandler1();<br>    Handlder h2 = <span class="hljs-keyword">new</span> COncreteHandler2();<br>    Handlder h3 = <span class="hljs-keyword">new</span> COncreteHandler3();<br>    <span class="hljs-comment">//设置职责链上家与下家</span><br>    h1.SetSuccessor(h2);<br>    h2.SetSuccessor(h3);<br>    <br>    <span class="hljs-built_in">int</span>[] requests=&#123;<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">14</span>,<span class="hljs-number">22</span>,<span class="hljs-number">18</span>,<span class="hljs-number">3</span>,<span class="hljs-number">27</span>,<span class="hljs-number">20</span>&#125;;<br>    <span class="hljs-comment">//循环给最小处理者提交请求，不同的数额,由不同权限处理者处理</span><br>    <span class="hljs-keyword">foreach</span>(<span class="hljs-built_in">int</span> request <span class="hljs-keyword">in</span> requests)<br>    &#123;<br>        h1.HandleRequest(request);<br>    &#125;<br>    <br>    Console.Read();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="④-优点和缺点-11"><a href="#④-优点和缺点-11" class="headerlink" title="④ 优点和缺点"></a>④ 优点和缺点</h4><p>​<strong>优点：</strong></p><ul><li>降低了请求的发送者和接收者之间的耦合。</li><li>把多个条件判定分散到各个处理类中，使得代码更加清晰，责任更加明确。</li></ul><p>​<strong>缺点：</strong></p><ul><li>在找到正确的处理对象之前，所有的条件判定都要执行一遍，当责任链过长时，可能会引起性能的问题</li><li>可能导致某个请求不被处理。</li></ul><h4 id="⑤-总结-13"><a href="#⑤-总结-13" class="headerlink" title="⑤ 总结"></a>⑤ 总结</h4><p><strong>责任链模式（Chain of Responsibility）</strong>，使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，知道有一个对象处理它为止。</p><hr><h3 id="9、访问者模式"><a href="#9、访问者模式" class="headerlink" title="9、访问者模式"></a>9、访问者模式</h3><h4 id="①-引言-19"><a href="#①-引言-19" class="headerlink" title="① 引言"></a>① 引言</h4><p>​访问者模式是封装一些施加于某种数据结构之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构则可以保存不变。访问者模式适用于数据结构相对稳定的系统， 它把数据结构和作用于数据结构之上的操作之间的耦合度降低，使得操作集合可以相对自由地改变。</p><h4 id="②-访问者设计模式介绍"><a href="#②-访问者设计模式介绍" class="headerlink" title="② 访问者设计模式介绍"></a>② 访问者设计模式介绍</h4><p>​数据结构的每一个节点都可以接受一个访问者的调用，此节点向访问者对象传入节点对象，而访问者对象则反过来执行节点对象的操作。这样的过程叫做“双重分派”。节点调用访问者，将它自己传入，访问者则将某算法针对此节点执行。</p><h4 id="③-实现-20"><a href="#③-实现-20" class="headerlink" title="③ 实现"></a>③ 实现</h4><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BF%E9%97%AE%E8%80%85%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><blockquote><p>Visitor类，为该对象结构中 ConcreteElement的每一个类声明一个 Visit操作。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">visitor</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">VisitConcreteElementA</span>(<span class="hljs-params">ConcreteElementA concreteElementA</span>)</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">VisitConcreteElementB</span>(<span class="hljs-params">ConcreteElementB concreteElementB</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ConcreteVisitor1和 ConcreteVisitor2类，具体访问者，实现每个由Visitor声明的操作。每个操作实现算法的一部分，而该算法片断乃是对应于结构中对象的类。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">Concretevisitor1</span> : <span class="hljs-title">Visitor</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">VisitConcreteElementA</span>(<span class="hljs-params">ConcreteElementA concreteElementA</span>)</span><br>    &#123;<br>        Console.writeLine(<span class="hljs-string">&quot; &#123;0&#125;被&#123;1&#125;访问&quot;</span>，concreteElementA.GetType().Name, <span class="hljs-keyword">this</span>. GetType ().Name);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">VisitConcreteElementB</span>(<span class="hljs-params">ConcreteElementB concreteElementB</span>)</span><br>    &#123;<br>        Console.WriteLine ( <span class="hljs-string">&quot; &#123;0&#125;被&#123;1&#125;访问&quot;</span>，concreteElementB.GetType().Name, <span class="hljs-keyword">this</span>.GetType ( ).Name);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteVisitor2</span> : <span class="hljs-title">Visitor</span><br>&#123;<br>    <span class="hljs-comment">//代码上类类似，省略。</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Element类，定义一个Accept 操作，它以一个访问者为参数。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Element</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Accept</span> (<span class="hljs-params">Visitor visitor</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ConcreteElementA 和 ConcreteElementB类，具体元素，实现Accept操作。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteElementA</span>: <span class="hljs-title">Element</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Accept</span> (<span class="hljs-params">Visitor visitor</span>)</span><br>    &#123;<br>        <span class="hljs-comment">//充分利用双分派技术，实现处理与数据结构的分离</span><br>        visitor.VisitConcreteElementA (<span class="hljs-keyword">this</span>);<br>    &#125;<br>    <span class="hljs-comment">//其他相关方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OperationA</span>()</span>&#123;&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteElementB</span>: <span class="hljs-title">Element</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Accept</span> (<span class="hljs-params">Visitor visitor</span>)</span><br>    &#123;<br>        <span class="hljs-comment">//充分利用双分派技术，实现处理与数据结构的分离</span><br>        visitor.VisitConcreteElementB (<span class="hljs-keyword">this</span>);<br>    &#125;<br>    <span class="hljs-comment">//其他相关方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OperationB</span>()</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ObjectStructure类，能枚举它的元素，可以提供一个高层的接口以允许访问者访问它的元素。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> 0<span class="hljs-title">bjectStructure</span><br>&#123;<br>    <span class="hljs-keyword">private</span> IList&lt;Element&gt; elements = <span class="hljs-keyword">new</span> List&lt;Element&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Attach</span> (<span class="hljs-params">Element element</span>)</span><br>    &#123;<br>        elements.Add(element);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Detach</span> (<span class="hljs-params">Element element</span>)</span><br>    &#123;<br>        elements.Remove(element);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Accept</span> (<span class="hljs-params">visitor visitor</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">foreach</span> (Element e <span class="hljs-keyword">in</span> elements)<br>        &#123;<br>            e.Accept (visitor);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>客户端代码</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span> (<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&#123;<br>    objectstructure o = <span class="hljs-keyword">new</span> ObjectStructure();<br>    o.Attach (<span class="hljs-keyword">new</span> ConcreteElementA());<br>    o.Attach (<span class="hljs-keyword">new</span> ConcreteElementB());<br>    <br>    Concretevisitor1 v1 =<span class="hljs-keyword">new</span> Concretevisitor1();<br>    Concretevisitor2 v2 =<span class="hljs-keyword">new</span> Concretevisitor2();<br>    <br>    o.Accept(v1);<br>    o.Accept(v2);<br>    <br>    Console.Read();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="④-优点和缺点-12"><a href="#④-优点和缺点-12" class="headerlink" title="④ 优点和缺点"></a>④ 优点和缺点</h4><p>​<strong>优点：</strong></p><ul><li>访问者模式使得添加新的操作变得容易。如果一些操作依赖于一个复杂的结构对象的话，那么一般而言，添加新的操作会变得很复杂。而使用访问者模式，增加新的操作就意味着添加一个新的访问者类。因此，使得添加新的操作变得容易。</li><li>访问者模式使得有关的行为操作集中到一个访问者对象中，而不是分散到一个个的元素类中。这点类似与”中介者模式”。</li><li>访问者模式可以访问属于不同的等级结构的成员对象，而迭代只能访问属于同一个等级结构的成员对象。</li></ul><p>​<strong>缺点：</strong></p><ul><li>增加新的元素类变得困难。每增加一个新的元素意味着要在抽象访问者角色中增加一个新的抽象操作，并在每一个具体访问者类中添加相应的具体操作。</li></ul><h4 id="⑤-总结-14"><a href="#⑤-总结-14" class="headerlink" title="⑤ 总结"></a>⑤ 总结</h4><p><strong>访问者模式（Visitor）</strong>，表示一个作用于某个结构中的各元素的操作。它使你可以在不改变各元素类的前提下定义作用于这些元素的新操作</p><hr><h3 id="10、备忘录模式"><a href="#10、备忘录模式" class="headerlink" title="10、备忘录模式"></a>10、备忘录模式</h3><h4 id="①-引言-20"><a href="#①-引言-20" class="headerlink" title="① 引言"></a>① 引言</h4><p>​备忘者模式与命令模式有点相似，不同的是，命令模式保存的是发起人的具体命令（命令对应的是行为），而备忘录模式保存的是发起人的状态（而状态对应的数据结构，如属性）。</p><h4 id="②-备忘录设计模式介绍"><a href="#②-备忘录设计模式介绍" class="headerlink" title="② 备忘录设计模式介绍"></a>② 备忘录设计模式介绍</h4><p>​从字面意思就可以明白，备忘录模式就是对某个类的状态进行保存下来，等到需要恢复的时候，可以从备忘录中进行恢复。生活中这样的例子经常看到，如备忘电话通讯录，备份操作操作系统，备份数据库等。</p><p>　　备忘录模式的具体定义是：<strong>在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可以把该对象恢复到原先的状态。</strong></p><h4 id="③-实现-21"><a href="#③-实现-21" class="headerlink" title="③ 实现"></a>③ 实现</h4><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%87%E5%BF%98%E5%BD%95%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><blockquote><p>发起人(Originator）类</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">Originator</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> state;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> State<br>    &#123;<br>        <span class="hljs-comment">//需要保存的属性，可能有多个</span><br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> state; &#125;<br>        <span class="hljs-keyword">set</span> &#123;state = <span class="hljs-keyword">value</span>; &#125;<br>    &#125;<br>    <span class="hljs-comment">//创建备忘录，将当前需要保存的信息导入并</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Memento <span class="hljs-title">CreateMemento</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">new</span> Memento(state));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetMemento</span>(<span class="hljs-params">Memento memento</span>)</span><br>    &#123;<br>        <span class="hljs-comment">//恢复备忘录，将 Memento导入并将相关数据恢复</span><br>        state = memento.State;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Show</span>()</span><br>    &#123;<br>        <span class="hljs-comment">//显示数据</span><br>        Console.writeLine (<span class="hljs-string">&quot;State=&quot;</span> + state); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>备忘录（Memento）类</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">Memento</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> state;<br>    <span class="hljs-comment">//构造方法,将相关数据导入</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Memento</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> state</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.state = state;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> State<br>    &#123;<br>        <span class="hljs-comment">//需要保存的数据属性,可以是多个</span><br>        <span class="hljs-keyword">get</span>&#123; <span class="hljs-keyword">return</span> state;&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>管理者（Caretaker）类</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">Caretaker</span><br>&#123;<br>    <span class="hljs-keyword">private</span> Memento memento;<br>    <span class="hljs-keyword">public</span> Memento Memento<br>    &#123;<br>        <span class="hljs-comment">//得到或设置备忘录</span><br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> memento; &#125;<br>        <span class="hljs-keyword">set</span> &#123; memento = <span class="hljs-keyword">value</span>; &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>客户端代码</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> [] args</span>)</span><br>&#123;<br>    <span class="hljs-comment">//Originator初始状态属性为“On”</span><br>    Originator o =<span class="hljs-keyword">new</span> Originator();<br>    o.State = <span class="hljs-string">&quot;On&quot;</span> ;<br>    o.Show();<br>    <br>    <span class="hljs-comment">//保存状态时，由于有了很好的封装，可以隐藏Originator的实现细节</span><br>    Caretaker c = <span class="hljs-keyword">new</span> Caretaker();<br>    c.Memento = o.CreateMemento();<br>    <br>    <span class="hljs-comment">//Originator改变了状态属性为“Off&quot;</span><br>    o.State = <span class="hljs-string">&quot;Off&quot;</span>;<br>    <span class="hljs-comment">//Console.Read();</span><br>    o.Show();<br>    <br>    Console.Read();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="④-优点和缺点-13"><a href="#④-优点和缺点-13" class="headerlink" title="④ 优点和缺点"></a>④ 优点和缺点</h4><p>​<strong>优点：</strong></p><ul><li>如果某个操作错误地破坏了数据的完整性，此时可以使用备忘录模式将数据恢复成原来正确的数据。</li><li>备份的状态数据保存在发起人角色之外，这样发起人就不需要对各个备份的状态进行管理。而是由备忘录角色进行管理，而备忘录角色又是由管理者角色管理，符合单一职责原则。</li></ul><p>​<strong>缺点：</strong></p><ul><li>在实际的系统中，可能需要维护多个备份，需要额外的资源，这样对资源的消耗比较严重。</li></ul><h4 id="⑤-总结-15"><a href="#⑤-总结-15" class="headerlink" title="⑤ 总结"></a>⑤ 总结</h4><p><strong>备忘录（Memento）</strong>：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。</p><hr><h3 id="11、解释器模式"><a href="#11、解释器模式" class="headerlink" title="11、解释器模式"></a>11、解释器模式</h3><h4 id="①-解释器设计模式介绍"><a href="#①-解释器设计模式介绍" class="headerlink" title="① 解释器设计模式介绍"></a>① 解释器设计模式介绍</h4><p>​使用解释器模式的实例不是很多，但对于满足以上特点，且对运行效率要求不是很高的应用实例，如果用解释器模式来实现，其效果是非常好的。解释器模式是给定一种语言，定义它文法的一种表示，并定义一种解释器，这个解释器使用该表示来解释器语言中的句子。</p><h4 id="②-实现-1"><a href="#②-实现-1" class="headerlink" title="② 实现"></a>② 实现</h4><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><blockquote><p>AbstractExpression(抽象表达式)，声明一个抽象的解释操作，这个接口为抽象语法树中所有的节点所共享。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AbstractExpression</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Interpret</span> (<span class="hljs-params">Context context</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>TerminalExpression(终结符表达式)，实现与文法中的终结符相关联的解释操作。实现抽象表达式中所要求的接口，主要是一个interpret()方法。文法中每一个终结符都有一个具体终结表达式与之相对应。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">TerminalExpression</span> : <span class="hljs-title">AbstractExpression</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Interpret</span> (<span class="hljs-params">Context context</span>)</span><br>    &#123;<br>        Console.writeLine( <span class="hljs-string">&quot;终端解释器&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>NonterminalExpression（非终结符表达式)，为文法中的非终结符实现解释操作。对文法中每一条规则R1、R2……Rn都需要一个具体的非终结符表达式类。通过实现抽象表达式的 interpret()方法实现解释操作。解释操作以递归方式调用上面所提到的代表R1、R2……Rn中各个符号的实例变量。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">NonterminalExpression</span> : <span class="hljs-title">AbstractExpression</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Interpret</span> (<span class="hljs-params">Context context</span>)</span><br>    &#123;<br>        Console.writeLine (<span class="hljs-string">&quot;非终端解释器&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Context，包含解释器之外的一些全局信息。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">Context</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> input;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Input<br>    &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> input; &#125;<br>        <span class="hljs-keyword">set</span> &#123; input = <span class="hljs-keyword">value</span>;&#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> output;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Output<br>    &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> output; &#125;<br>        <span class="hljs-keyword">set</span> &#123; output = <span class="hljs-keyword">value</span>;&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>客户端代码，构建表示该文法定义的语言中一个特定的句子的抽象语法树。调用解释操作。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[]args</span>)</span><br>&#123;<br>    Context context =<span class="hljs-keyword">new</span> Context();<br>    IList&lt;AbstractExpression&gt; list = <span class="hljs-keyword">new</span> List&lt;AbstractExpression&gt;();<br>    list.Add(<span class="hljs-keyword">new</span> TerminalExpression());<br>    list.Add(<span class="hljs-keyword">new</span> NonterminalExpression());<br>    list.Add(<span class="hljs-keyword">new</span> TerminalExpression());<br>    list.Add(<span class="hljs-keyword">new</span> TerminalExpression());<br>    <br>    <span class="hljs-keyword">foreach</span> (AbstractExpression exp <span class="hljs-keyword">in</span> list)<br>    &#123;<br>        exp.Interpret (context);<br>    &#125;<br>    <br>    Console.Read();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="③-优点和缺点-1"><a href="#③-优点和缺点-1" class="headerlink" title="③ 优点和缺点"></a>③ 优点和缺点</h4><p>​<strong>优点：</strong></p><ol><li>扩展性好。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。</li><li>容易实现。在语法树中的每个表达式节点类都是相似的，所以实现其文法较为容易。</li></ol><p>​<strong>缺点：</strong></p><ol><li>执行效率较低。解释器模式中通常使用大量的循环和递归调用，当要解释的句子较复杂时，其运行速度很慢，且代码的调试过程也比较麻烦。</li><li>会引起类膨胀。解释器模式中的每条规则至少需要定义一个类，当包含的文法规则很多时，类的个数将急剧增加，导致系统难以管理与维护。</li><li>可应用的场景比较少。在软件开发中，需要定义语言文法的应用实例非常少，所以这种模式很少被使用到。</li></ol><h4 id="④-总结-2"><a href="#④-总结-2" class="headerlink" title="④ 总结"></a>④ 总结</h4><p><strong>解释器模式（interpreter）</strong>，给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C Sharp</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity 生命周期</title>
    <link href="/2022/06/05/Unity%E8%84%9A%E6%9C%AC%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2022/06/05/Unity%E8%84%9A%E6%9C%AC%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="Unity生命周期"><a href="#Unity生命周期" class="headerlink" title="Unity生命周期"></a>Unity生命周期</h1><h3 id="Unity生命周期图"><a href="#Unity生命周期图" class="headerlink" title="Unity生命周期图"></a>Unity生命周期图</h3><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/06-05/Unity%E8%84%9A%E6%9C%AC%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png"></p><h3 id="Reset"><a href="#Reset" class="headerlink" title="Reset"></a>Reset</h3><p><strong>Reset</strong> 是当Scripts第一次绑定到物体上或者点击Reset按钮的时候会触发，且只在Editor的模式下触发，游戏打包的时候并不会触发。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Reset</span>()</span><br>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Awake"><a href="#Awake" class="headerlink" title="Awake"></a>Awake</h3><p><strong>Awake</strong> 是当脚本实例在游戏运行被载入的时候运行，一般为了初始化游戏变量和游戏状态，注意，无论函数是否被激活，Awake 都会执行。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span><br>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="OnEable"><a href="#OnEable" class="headerlink" title="OnEable"></a>OnEable</h3><p><strong>OnEable</strong> 是在游戏对象是可激活状态的时候会调用</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnEable</span>()</span><br>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h3><p><strong>Start</strong> 也是为了初始化变量的方法但是和 <strong>Awake</strong> 有些许的不同</p><p>首先，<strong>Awake</strong> 是在项目初始化的时候被调用的，但是 <strong>Start</strong> 可能在初始之后调用，所有如果把一些状态放在 <strong>Start</strong> 中进行初始化，会很不安全，因为可能会有别的函数在 <strong>Start</strong> 之前就被执行，造成一些空引用的问题。</p><p>其次，如果对象不是处于激活状态，<strong>Start</strong> 是不会被调用的，而 <strong>Awake</strong> 无论是不是激活都会被引用。</p><p><strong>所以，建议把所有初始化都放在Awake上</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="FixedUpdate"><a href="#FixedUpdate" class="headerlink" title="FixedUpdate"></a>FixedUpdate</h3><p>Unity 建议，把所有的物理行为的每帧更新的逻辑都应当放在 <strong>FixedUpdate</strong> 里，原因因为这个是固定间隔的帧执行的，而普通的 <strong>Update</strong> 每一帧之间的间隔是不固定的，不一样的，所以一般都希望物体上的力是均匀的，否则会出现卡顿的现象。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FixedUpdate</span>()</span><br>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="OnTrigger、OnCollison、OnMouse"><a href="#OnTrigger、OnCollison、OnMouse" class="headerlink" title="OnTrigger、OnCollison、OnMouse"></a>OnTrigger、OnCollison、OnMouse</h3><p>先处理 <strong>OnTrigger</strong> 触发器行为，再处理 <strong>OnCollison</strong> 碰撞体行为，在此处理 <strong>OnMouse</strong> 的点击鼠标，点击输入的行为.</p><p>这三个行为是完全连续的行为。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnTrigger</span>()</span><br>&#123;<br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnCollison</span>()</span><br>&#123;<br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnMouse</span>()</span><br>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h3><p><strong>Update</strong> 是每一帧进行调用，是我们实现大部分游戏逻辑的方法.</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span><br>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="LateUpdate"><a href="#LateUpdate" class="headerlink" title="LateUpdate"></a>LateUpdate</h3><p><strong>LateUpdate</strong> 再所有 Update 方法执行之后执行，一般用于摄像机的跟随移动。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LateUpdate</span>()</span><br>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="OnGUI"><a href="#OnGUI" class="headerlink" title="OnGUI"></a>OnGUI</h3><p><strong>OnGUI</strong> 处理GUI数据，也是每一帧执行一次</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnGUI</span>()</span><br>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="OnDisable"><a href="#OnDisable" class="headerlink" title="OnDisable"></a>OnDisable</h3><p><strong>OnDisable</strong> 在对象被取消活跃状态的时候响应，和 <strong>OnEnable</strong> 相对应，但与此同时对象再次被激活的时候，<strong>OnEnable</strong> 也会再次响应。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnDisable</span>()</span><br>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="OnDestory"><a href="#OnDestory" class="headerlink" title="OnDestory"></a>OnDestory</h3><p><strong>OnDestory</strong> 在对象被销毁的时候被调用，但是如果一开始对象就处于不激活状态然后被销毁了，就不会调用这个函数。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnDisable</span>()</span><br>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>游戏编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>生命周期</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity 游戏AI之行为树</title>
    <link href="/2022/06/05/Unity%20AI%E4%B9%8B%E8%A1%8C%E4%B8%BA%E6%A0%91/"/>
    <url>/2022/06/05/Unity%20AI%E4%B9%8B%E8%A1%8C%E4%B8%BA%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="Unity-游戏AI之行为树"><a href="#Unity-游戏AI之行为树" class="headerlink" title="Unity 游戏AI之行为树"></a>Unity 游戏AI之行为树</h1><h2 id="游戏AI-行为树Part1：简介"><a href="#游戏AI-行为树Part1：简介" class="headerlink" title="游戏AI - 行为树Part1：简介"></a><strong>游戏AI - 行为树Part1：简介</strong></h2><p>游戏中的AI，大多数都是按照规则设定好的，没有太多花哨的技术。原因有几个：</p><p>一是出于风险成本的考虑，用一个新技术，需要程序员开发相应的算法和框架，游戏设计师重新上手设计方法和摸索算法的适用范围，小团队承受不起这样的开销，大团队又怕做坏名声；</p><p>二是“高级”的AI算法并不直观，难以设计。举一个例子，怎么利用神经网络来训练一个士兵AI？我见过的一个例子是设计师用几个按键来操作士兵移动攻击，然后程序自动记录敌我双方的数据和设计师的操作，最后利用这些信息作为input构建一个行为树。这个方法的问题有三个，一是效率奇慢，因为如果数据不够，行为树就可能覆盖不了所有情况，但多少才是“够”，又没有定论；二是错误的操作也会被记录下来，当然可以开发一个功能来删除设计师的某个动作；三是行为树的结果是无法解释的，相当于一个黑箱。</p><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/6-1-1-1.jpg"></p><p>由于上述的原因，一般的公司都会使用比较传统的有限状态机。</p><p>虽然第一次听的话可能会拗口，其实有限状态机的意思其实很简单，它包含了有限个的状态和状态间的转换条件。最直白的说法就是几个**if…else…**语句。为了弄明白这个概念，我们讲一个英雄的故事：</p><p>从前有一个胆小如鼠的英雄，</p><ol><li>他看到哥布林就会跑过去打它；</li><li>他看到半兽人就会逃跑；</li><li>他看不到哥布林也看不到半兽人就会休息；</li><li>他看到哥布林也看到半兽人也会跑。</li></ol><p>我们可以从中抽象出这样的一个有限状态机：</p><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/6-1-1-2.png"></p><p>有限状态机很符合我们的认知，但它有一个致命的缺点——它随着状态和转换条件的增多而急速地变得错综复杂，以至于很难对它做出改动（想象一下，多加一个状态，则需要增加几条转换线，越多状态，需要增加的转换线越多）。</p><p>也由于这个原因，比较多的开发者投入了行为树的怀抱。</p><h2 id="行为树"><a href="#行为树" class="headerlink" title="行为树"></a><strong>行为树</strong></h2><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>行为树的概念会比状态机要复杂些——行为树是一个包含逻辑节点和行为节点的树结构，每次需要找出一个行为的时候，会从树的根节点出发，遍历各个节点，找出第一个和当前数据相符合的行为。</p><p>很拗口对吧，下面来一个生动点的解释，继续上面的英雄的故事，但是是用行为树表达出来：</p><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/6-1-1-3.png"></p><p>这个行为树是等价于之前的有限状态机的。其中</p><p><strong>Root</strong>是根节点，每次需要寻找行为的时候都必须从这里开始。</p><p><strong>Priority Selector</strong>是一个逻辑节点，它的意思是让从左到右遍历自己的子节点，如果子节点的准入条件符合信息的话，就执行该子节点。如果英雄只看到哥布林，那么Orc in sight这个准入条件不符合，Escape不执行；Globlin in sight符合，于是执行Fight；因为Fight在Idle的左边，所以Fight的优先程度更高，于是Idle不执行。在我们的例子中，Idle可以看作是default behavior。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>从简单的行为树和有限状态机的对比，我们就可以看出，行为树由于引入了逻辑节点，它的转换条件更加少（线更少，更清晰），让<strong>拓展AI变得更加容易</strong>。</p><p>行为树还有另外一个优点：行为的<strong>重用</strong>（reuse)。</p><p>例如，Escape有一个跑的行为，而Fight则有跑的行为，和砍怪的行为。请看图：</p><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/6-1-1-4.png"></p><p><strong>Sequence</strong>同样是一个逻辑节点，它的意思是从左到右按顺序执行子节点，并且仅仅在一个子节点执行完成后才执行下一个子节点。在例子中，Do Run需要有一个自己判断到达目的地的方法，当该方法返回end的时候，才会执行Do Slash。</p><p>Escape和Fight的Do Run行为节点是一样的，只是Fight多了一个Do Slash行为节点而已。所以Do Run是一个可以重用的节点。</p><p>在行为树中，我们能够编写好Do Run，Do Slash这些基础的行为节点，和设定一些准入条件，就可以<strong>组成千变万化的AI</strong>了！</p><p>我们希望英雄在逃跑的时候群众发出嘘声，而在攻击的时候出现欢呼声：</p><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/6-1-1-5.png"></p><p>省略了其他部分，只画Escape部分。</p><p>Parallel是一个逻辑节点，它的意思是让所有子节点同时运行，那它什么时候结束呢，可以使当所有子节点都完成的时候结束，也可以让任一子节点完成时结束，视乎需要来做出选择。</p><p>那么在攻击当中会是怎么样实现的呢？大家可以尝试画出来，习惯一下行为树的思维方式。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ol><li><p>行为树拥有3种节点：</p></li><li><ol><li><p>根节点 Root</p></li><li><p>逻辑节点（可拓展）：</p></li><li><ol><li>Priority Selector</li><li>Sequence</li><li>Parallel</li></ol></li><li><p>行为节点</p></li></ol></li><li><p>行为树在复杂的情况比有限状态机更清晰，更可拓展</p></li><li><p>行为树有利于逻辑的重用</p></li><li><p>设计得好的行为树可以千变万化！</p></li></ol><p>之后，我会展示在游戏开发中怎么利用行为树作为框架来使用。</p><hr><h2 id="游戏AI-行为树Part2：框架"><a href="#游戏AI-行为树Part2：框架" class="headerlink" title="游戏AI - 行为树Part2：框架"></a><strong>游戏AI - 行为树Part2：框架</strong></h2><h2 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a><strong>关键词</strong></h2><p>在展开之前，我们先定义几个关键词（基本都以BT作为前缀…是Behavior Tree之意，别误会了…），会在下面的框架用到。</p><p><strong>BTNode</strong>：所有节点的base class。定义了一些节点的基本功能，并提供一些可继承的函数。</p><p><strong>BTAction</strong>：行为节点，继承于BTNode。具体的游戏逻辑应该放在这个节点里面。</p><p><strong>BTPrecondition</strong>：节点的准入条件，每一个BTNode都会有一个。具体的游戏逻辑判断可以继承于它。</p><p><strong>BTPrioritySelector</strong>：Priority Selector逻辑节点，继承于BTNode。每次执行，先有序地遍历子节点，然后执行符合准入条件的<strong>第一个</strong>子结点。可以看作是根据条件来选择一个子结点的<strong>选择器</strong>。</p><p><strong>BTSequence</strong>：Sequence逻辑节点，继承于BTNode。每次执行，有序地执行各个子结点，当一个子结点结束后才执行下一个。严格按照节点A、B、C的顺序执行，当最后的行为C结束后，BTSequence结束。</p><p><strong>BTParallel</strong>：Parallel逻辑节点，继承于BTNode。<strong>同时</strong>执行各个子结点。每当<strong>任一</strong>子结点的准入条件失败，它就不会执行。</p><p><strong>BTParallelFlexible</strong>：Parallel的一个变异，继承于BTNode。<strong>同时</strong>执行各个子节点。当<strong>所有</strong>子结点的准入条件都失败，它就不会执行。</p><p><strong>BTTree</strong>：将所有节点组合起来的地方。</p><p><strong>Database</strong>：<a href="https://link.zhihu.com/?target=http://en.wikipedia.org/wiki/Blackboard_system">黑板</a>，一个存放<strong>共享</strong>数据的地方，可以看成是一个Key－Value的字典。为什么需要黑板呢？因为设计良好的行为逻辑，应该是独立的，可以在行为树的任何位置部署的。也就是说行为A和行为B并没有直接的沟通方法。黑板的作用就是作为一个行为树的“数据库”，让各个行为节点都可以储存数据进去，供感兴趣的行为节点利用。（同时，在Unity3d的语境下，Database继承MonoBehavior，可以提供各种Component给节点使用。）</p><p>UML类图：</p><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/6-1-1-6.png"></p><h2 id="代码资源"><a href="#代码资源" class="headerlink" title="代码资源"></a><strong>代码资源</strong></h2><p>我们使用的框架的代码放在了Github：<a href="https://link.zhihu.com/?target=https://github.com/f15gdsy/BT-Framework">BT Framework</a>。它是用 C# 写的，但概念可以转换到任何语言。</p><p>我们的Demo例子是<a href="http://zhuanlan.zhihu.com/indiegamepixel/19890016">Part1</a>里提到的“贪生怕死的英雄”，Demo的代码可以在<a href="https://link.zhihu.com/?target=https://github.com/f15gdsy/BT-Test">这里</a>下载。Demo是用Unity3d写的。</p><h2 id="行为树的构建"><a href="#行为树的构建" class="headerlink" title="行为树的构建"></a><strong>行为树的构建</strong></h2><p>下面，我们会先从BT行为树框架的<strong>使用</strong>开始，然后再解释框架的实现。</p><p>BT行为树框架与外界的入口在BTTree，下面我们来看看BTTree的子类MoveAttackAI，我们在这里构建了一个行为树：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// MoveAttackAI.cs</span><br><span class="hljs-comment">// 一个继承于BT Tree的一个类</span><br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Init</span> ()</span> &#123;<br>   <span class="hljs-comment">// 初始化base class</span><br>   <span class="hljs-keyword">base</span>.Init();<br><br>   <span class="hljs-comment">// 创建根节点，根节点</span><br>   _root = <span class="hljs-keyword">new</span> BTPrioritySelector();<br>   <br>   <span class="hljs-comment">// ... 创建准入条件，如checkOrcInSight</span><br>   <span class="hljs-comment">// ... 创建行为／逻辑节点，如findDestination，run</span><br><br>   <span class="hljs-comment">// 搭建行为树</span><br>   <span class="hljs-comment">// Escape 节点</span><br>   BTParallel escape = <span class="hljs-keyword">new</span> BTParallel(BTParallel.ParallelFunction.Or, checkOrcInSight);<br>   &#123;<br>      escape.AddChild(findDestination);<br>      escape.AddChild(run);<br>   &#125;<br>   _root.AddChild(escape);<br><br>   <span class="hljs-comment">//... Fight 节点</span><br>   _root.AddChild(fight);<br><br>   <span class="hljs-comment">//... Idle 节点</span><br>   _root.AddChild(idle);<br>&#125;<br></code></pre></td></tr></table></figure><p>上图就是我们的行为树了！它基本对应了<a href="http://zhuanlan.zhihu.com/indiegamepixel/19890016">Part1</a>里面的图，不过有所修改。</p><p>\1. 在上面，我们创建Root节点，创建准入条件，和行为／逻辑节点，然后通过AddChild来搭建行为树。</p><p>\2. escape节点是一个Parallel逻辑节点，因为每次执行escape的时候我们都需要先找到逃跑的目的地，然后再跑。这时候可能有朋友会问，为什么不用Sequence呢？因为Sequence每次执行，都是按照行为A、行为B、行为C这样的顺序执行的，执行完行为C之后就结束。所以如果用Sequence，我们的目的地在跑到当前目的地之前就不能更新了。</p><p>\3. findDestination，和run这些行为都是继承于BTAction 。但是为什么我们要将选择目的地和跑这个动作分开呢？是为了更好地分离逻辑——Escape的跑和Fight的跑是一样的，但目的地选择不一样，Escape的目的地是半兽人的相反方向，Fight的目的地是哥布林的位置。</p><p>\4. 另外，在Part1的评论里面，</p><p><a href="https://www.zhihu.com/people/a44d48aa6a124b610a621bef6c16568f">@余冬冬</a></p><p>老师提到</p><blockquote><p>“为什么要有ROOT呢？ 直接prority selector不可以么。”</p></blockquote><p>在我们的例子里，Root的确就是一个Priority Selector！不过由于在base class——BTTree里面会对Root特别对待，所以在Part1里就特别提到它。</p><p>搭建一个行为树，最核心的就是上面的几行代码了，不难吧 :)</p><p>要在Unity3d里面的使用这一个行为树也很简单，在GameObject里面加入MoveAttackAI这个component就好（BTTree继承于MonoBehavior）。</p><p>如果在其他引擎当中使用，如Cocos2d-x，BTTree则应该拥有Update函数和自定义的初始化函数。</p><p>下面我们看看BT框架的实现。</p><h2 id="框架的实现"><a href="#框架的实现" class="headerlink" title="框架的实现"></a><strong>框架的实现</strong></h2><h2 id="BTNode和逻辑节点"><a href="#BTNode和逻辑节点" class="headerlink" title="BTNode和逻辑节点"></a>BTNode和逻辑节点</h2><p>BTNode提供了节点的最重要的接口：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// BTNode.cs</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BTNode</span> &#123;<br>   <span class="hljs-comment">//...</span><br><br>   <span class="hljs-comment">// 节点的准入条件</span><br>   <span class="hljs-keyword">public</span> BTPrecondition precondition;<br><br>   <span class="hljs-comment">// 黑板 </span><br>   <span class="hljs-keyword">public</span> Database database;<br><br>   <span class="hljs-comment">// 冷却功能</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> interval = <span class="hljs-number">0</span>;<br><br>   <span class="hljs-comment">// 当false的时候，节点不会执行</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> activated;<br>   <br><br>   <span class="hljs-comment">// 节点初始化的接口，Database可提供Unity3d中的Component给节点使用</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Activate</span> (<span class="hljs-params">Database database</span>)</span> &#123;<br>      <span class="hljs-comment">//...</span><br>   &#125;<br>   <br>   <span class="hljs-comment">// 检查节点能否执行，包括是否activated，是否冷却完成，是否通过准入条件，和个性化检查 (DoEvaluate)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">Evaluate</span> ()</span> &#123;<br>      <span class="hljs-built_in">bool</span> coolDownOK = CheckTimer();<br>      <span class="hljs-keyword">return</span> activated &amp;&amp; coolDownOK &amp;&amp; (precondition == <span class="hljs-literal">null</span> || precondition.Check()) &amp;&amp; DoEvaluate();<br>   &#125;<br><br>   <span class="hljs-comment">// 给子类提供个性化检查的接口</span><br>   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">DoEvaluate</span> ()</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<br><br>   <span class="hljs-comment">// 节点执行的接口，需要返回BTResult.Running，或者BTResult.Ended</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> BTResult <span class="hljs-title">Tick</span> ()</span> &#123;<span class="hljs-keyword">return</span> BTResult.Ended;&#125;<br><br>   <span class="hljs-comment">// 节点清零的接口</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Clear</span> ()</span> &#123;&#125;<br><br>   <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>BTNode提供给子类的接口中最重要的两个是DoEvaluate()和Tick()。</p><p><strong>DoEvaludate</strong>给子类提供个性化检查的接口（注意和<strong>Evaluate</strong>的不同），例如Sequence的检查和Priority Selector的检查是不一样的。例如Sequence和Priority Selector里都有节点A，B，C。第一次检查的时候，</p><p>Sequence只检查A就可以了，因为A不通过Evaluate，那么这个Sequence就没办法从头开始执行，所以Sequence的DoEvaludate也不通过。</p><p>而Priority Selector则先检查A，A不通过就检查B，如此类推，仅当所有的子结点都无法通过Evaluate的时候，才会不通过DoEvaludate。</p><p><strong>Tick</strong>是节点执行的接口，仅仅当Evaluate通过时，才会执行。子类需要重载Tick，才能达到所想要的逻辑。例如Sequence和Priority Selector，它们的Tick也是不一样的：</p><p>Sequence里当active child节点A Tick返回Ended时，Sequence就会将当前的active child设成节点B（如果有B的话），并返回Running。当Sequence最后的子结点N Tick返回Ended时，Sequence也返回Ended。</p><p>Priority Selector则是当目前的active child返回Ended的时候，它也返回Ended。Running的时候，它也返回Running。</p><p>正是通过重载DoEvaluate和Tick，BT框架实现了Sequence，PrioritySelector，Parallel，ParalleFlexible这几个逻辑节点。如果你有特殊的需求，也可以重载DoEvaluate和Tick来实现！</p><h2 id="BTAction"><a href="#BTAction" class="headerlink" title="BTAction"></a>BTAction</h2><p>BTAction是负责游戏逻辑的行为节点，也就是行为树里面的“行为”。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// BTAction.cs</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BTAction</span> : <span class="hljs-title">BTNode</span> &#123;<br>   <span class="hljs-keyword">private</span> BTActionStatus _status = BTActionStatus.Ready;<br>   <br>   <span class="hljs-comment">//...</span><br><br>   <span class="hljs-comment">// 第一次进入行为</span><br>   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Enter</span> ()</span> &#123;<span class="hljs-comment">//... Debug functionality&#125;</span><br>   <br>   <span class="hljs-comment">// 离开行为</span><br>   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Exit</span> ()</span> &#123;<span class="hljs-comment">//... Debug functionality&#125;</span><br><br>   <span class="hljs-comment">// 行为的执行，返回BTResult</span><br>   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> BTResult <span class="hljs-title">Execute</span> ()</span> &#123;<span class="hljs-comment">//...&#125;</span><br><br>   <span class="hljs-comment">// 重载BTNode的Tick，加入了Enter，Exit，Execute的概念</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> BTResult <span class="hljs-title">Tick</span> ()</span> &#123;<br>      BTResult result = BTResult.Ended;<br>      <span class="hljs-keyword">if</span> (_status == BTActionStatus.Ready) &#123;<br>         Enter();<br> _status = BTActionStatus.Running;<br>      &#125;<br>      <br>      <span class="hljs-comment">// not using else so that the status changes reflect instantly</span><br>      <span class="hljs-keyword">if</span> (_status == BTActionStatus.Running) &#123;<br>         result = Execute();<br>         <span class="hljs-keyword">if</span> (result != BTResult.Running) &#123;<br>            Exit();<br>    _status = BTActionStatus.Ready;<br> &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> result;<br>   &#125;<br><br>   <span class="hljs-comment">// 重载清零接口，因为外部没有办法调用Exit</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Clear</span> ()</span> &#123;<br>      <span class="hljs-comment">// not cleared yet</span><br>      <span class="hljs-keyword">if</span> (_status != BTActionStatus.Ready) &#123;<br>         Exit();<br> _status = BTActionStatus.Ready;<br>      &#125;<br>   &#125;<br><br>   <span class="hljs-comment">//...</span><br><br>   <span class="hljs-keyword">private</span> <span class="hljs-built_in">enum</span> BTActionStatus &#123;<br>      Ready = <span class="hljs-number">1</span>,<br>      Running = <span class="hljs-number">2</span>,<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>BTAction里面最重要的是Tick，它重载了BTNode的Tick，增加了对Enter，Exit，Execute的支持。如果大家对有限状态机比较熟悉，一个状态机里面的状态通常都会支持这三个方法，分别用来初始化，清零，和执行逻辑。在每一次行为节点的一个运行周期（不是生命周期）里，Enter仅在一开始被调用，Exit仅在最后被调用，Execute会在每一次Tick被调用。</p><p>例如我们可以这样实现DoRun：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// DoRun.cs</span><br><br><span class="hljs-comment">// 在某些简单的情况下，没有必要将动画和位移逻辑分开的话，可以这样写；</span><br><span class="hljs-comment">// 但通常为了更好的逻辑分离，我并不会将它们放在一起。而是分成两个不同的行为。</span><br><span class="hljs-comment">//   protected override void Enter () &#123;</span><br><span class="hljs-comment">//      database.GetComponent&lt;Animator&gt;().Play(&quot;Run&quot;);</span><br><span class="hljs-comment">//   &#125;</span><br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> BTResult <span class="hljs-title">Execute</span> ()</span> &#123;<br>   <span class="hljs-comment">//...</span><br><br>   <span class="hljs-keyword">if</span> (CheckArrived()) &#123;<br>      <span class="hljs-keyword">return</span> BTResult.Ended;   <span class="hljs-comment">// 告诉父节点我要结束了</span><br>   &#125;<br>   MoveToDestination();<br>   <span class="hljs-keyword">return</span> BTResult.Running;   <span class="hljs-comment">// 告诉父节点我还在运行</span><br>&#125;<br></code></pre></td></tr></table></figure><p>就是这么简单！</p><p>同时，我们可以看到DoRun并没有引用行为节点（也不应该引用），也就是说，它是一个逻辑上独立的行为节点，可以部署到行为树的任何位置。<strong>行为节点的逻辑独立，可以让我们写的每一个行为，都可以放到我们自己的逻辑库里面，给以后的项目调用！</strong></p><h2 id="Demo的局限和改进方法"><a href="#Demo的局限和改进方法" class="headerlink" title="Demo的局限和改进方法"></a><strong>Demo的局限和改进方法</strong></h2><p>如果你有耐心看到这里，你一定已经发现了Demo有一个bug——当半兽人和哥布林在同一方向（相对于英雄）的时候，英雄会先逃跑，然后在某一个点上迅速来回翻转。这是因为AI在Escape和Fight这两个分支上快速切换。</p><p>一个改进的方法是<strong>分等级的行为树（Hierarchical Behavior Tree）</strong>[1]：</p><p>有一个做决策的行为树A，和一个按照命令执行的行为树B。A根据游戏世界的情况做出决策，然后将命令放到Database里，然后B根据命令做出动作。由于两个行为树都放在一个Game Object里，所以Database是A、B共享的。通常，决策者A并不会每一帧都做出决策，而是设定一个冷却时间。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">// DecisionAI.cs<br><br>// 设定1.5秒的冷却时间<br>_root.interval = 1.5f;<br></code></pre></td></tr></table></figure><p>改进的Demo代码可以在<a href="https://zhuanlan.zhihu.com/p/BT-Test/tree/improved">这里</a>下载。</p><p>这样一个分等级的行为树有两个好处：</p><ol><li>让决策逻辑和执行逻辑分离。面对同样的决策，不同Game Object可能有不同的执行方法。</li><li>玩家控制的角色和AI控制的角色可以分享同一个执行逻辑——只需要负责玩家控制的代码将命令存放到Database里面供执行逻辑使用就可以了。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ul><li>我们从BT框架的使用为学习入口，解释了行为树框架的实现原理；</li><li>也了解了怎么去拓展出个性化的逻辑节点和行为节点来满足项目需求；</li><li>通过逻辑独立地拓展BTAction，我们能够积累自己的逻辑库！</li><li>最后我们提到了分等级的行为树，它可以帮助我们将决策逻辑和执行逻辑分开（并解决了demo里面的一个bug）。</li></ul><p>BT框架还可以怎样拓展？我的下一个目标就是将它打造成一个Unity3d的插件，可以通过GUI来搭建行为树，而不用通过代码——当然，行为节点还是得自己用代码写。</p><p><strong>转自知乎</strong>：</p><p><a href="https://zhuanlan.zhihu.com/p/19890016">游戏AI - 行为树Part1：简介 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/19891875">游戏AI - 行为树Part2：框架 - 知乎 (zhihu.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>游戏编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C# 之Yield Return语法的作用和好处</title>
    <link href="/2022/06/01/C%20Sharp%E4%B9%8BYield%20Return%E8%AF%AD%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%A5%BD%E5%A4%84/"/>
    <url>/2022/06/01/C%20Sharp%E4%B9%8BYield%20Return%E8%AF%AD%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%A5%BD%E5%A4%84/</url>
    
    <content type="html"><![CDATA[<p>首先我贴出平时正常输出偶数集合的办法</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  学习Yield Return 语法</span><br><span class="hljs-comment"> *  使用两个方法，显示1 - 100之间的全部偶数</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">YieldReturn</span>语法解析<br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>       <span class="hljs-keyword">static</span>  <span class="hljs-keyword">private</span> List&lt;<span class="hljs-built_in">int</span>&gt; _numArray; <span class="hljs-comment">//用来保存1-100 这100个整数</span><br><br>        Program() <span class="hljs-comment">//构造函数。我们可以通过这个构造函数往待测试集合中存入1-100这100个测试数据</span><br>        &#123;<br>            _numArray = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;(); <span class="hljs-comment">//给集合变量开始在堆内存上开内存，并且把内存首地址交给这个_numArray变量</span><br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; i++) <br>            &#123;<br>                _numArray.Add(i);  <span class="hljs-comment">//把1到100保存在集合当中方便操作</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">new</span> Program();<br><br>            TestMethod();<br><br><br>        &#125;<br><br>        <span class="hljs-comment">//测试求1到100之间的全部偶数</span><br>        <span class="hljs-function"><span class="hljs-keyword">static</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TestMethod</span>()</span><br>        &#123;<br>            <span class="hljs-keyword">foreach</span> (<span class="hljs-function"><span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> <span class="hljs-title">GetAllEvenNumber</span>())</span> <br>            &#123;<br>                Console.WriteLine(item); <span class="hljs-comment">//输出偶数测试</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//测试我们正常情况下拿到全部偶数的方法</span><br>       <span class="hljs-function"><span class="hljs-keyword">static</span>  IEnumerable&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-title">GetAllEvenNumber</span>()</span><br>        &#123;<br>            List&lt;<span class="hljs-built_in">int</span>&gt; result = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;(); <span class="hljs-comment">//开集合内存存偶数用</span><br><br>            <span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">int</span> num <span class="hljs-keyword">in</span> _numArray) <br>            &#123;<br>                <span class="hljs-keyword">if</span>(num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) <span class="hljs-comment">//判断是不是偶数</span><br>                &#123;<br>                    <span class="hljs-comment">//yield return num;</span><br>                    result.Add(num); <span class="hljs-comment">//存入集合</span><br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">//返回偶数集合变量   可能有人会觉得奇怪返回类型不是List&lt;int&gt;这样可以吗</span><br>            <span class="hljs-comment">//这个就要回到我们的里氏替换原则了，子类是可以替换父类的，也就是当父类用</span><br>            <span class="hljs-comment">//比如我这个方法是想得到IEnumerable&lt;int&gt; 类型变量，但是我给了List&lt;int&gt;类型变量</span><br>            <span class="hljs-comment">//注意List&lt;int&gt; 是继承 IEnumerable&lt;int&gt; 的，什么意思当我们把子类当父类使用，</span><br>            <span class="hljs-comment">//那么大才小用，因为子类很多都是继承父亲，你自身增加很多字段或者方法，这样就不能用了。</span><br>            <span class="hljs-keyword">return</span> result;  <br>            <span class="hljs-comment">//yield break;</span><br>        &#125;<br><br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>贴出使用Yiele Return办法输出耦合集合</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  学习Yield Return 语法</span><br><span class="hljs-comment"> *  使用两个方法，显示1 - 100之间的全部偶数</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">YieldReturn</span>语法解析<br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>       <span class="hljs-keyword">static</span>  <span class="hljs-keyword">private</span> List&lt;<span class="hljs-built_in">int</span>&gt; _numArray; <span class="hljs-comment">//用来保存1-100 这100个整数</span><br><br>        Program() <span class="hljs-comment">//构造函数。我们可以通过这个构造函数往待测试集合中存入1-100这100个测试数据</span><br>        &#123;<br>            _numArray = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;(); <span class="hljs-comment">//给集合变量开始在堆内存上开内存，并且把内存首地址交给这个_numArray变量</span><br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; i++) <br>            &#123;<br>                _numArray.Add(i);  <span class="hljs-comment">//把1到100保存在集合当中方便操作</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">new</span> Program();<br><br>            TestMethod();<br><br><br>        &#125;<br><br>        <span class="hljs-comment">//测试求1到100之间的全部偶数</span><br>        <span class="hljs-function"><span class="hljs-keyword">static</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TestMethod</span>()</span><br>        &#123;<br>            <span class="hljs-keyword">foreach</span> (<span class="hljs-function"><span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> <span class="hljs-title">GetAllEvenNumber</span>())</span> <br>            &#123;<br>                Console.WriteLine(item); <span class="hljs-comment">//输出偶数测试</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//测试我们使用Yield Return情况下拿到全部偶数的方法</span><br>       <span class="hljs-function"><span class="hljs-keyword">static</span>  IEnumerable&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-title">GetAllEvenNumber</span>()</span><br>        &#123;<br><br>            <span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">int</span> num <span class="hljs-keyword">in</span> _numArray) <br>            &#123;<br>                <span class="hljs-keyword">if</span>(num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) <span class="hljs-comment">//判断是不是偶数</span><br>                &#123;<br>                    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> num; <span class="hljs-comment">//返回当前偶数</span><br><br>                &#125;<br>            &#125;        <br>            <span class="hljs-keyword">yield</span> <span class="hljs-keyword">break</span>;  <span class="hljs-comment">//当前集合已经遍历完毕，我们就跳出当前函数，其实你不加也可以</span><br>            <span class="hljs-comment">//这个作用就是提前结束当前函数，就是说这个函数运行完毕了。</span><br>        &#125;<br><br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>​大家测试了2个代码结果没，是不是都可以正确拿到全部偶数集合，具体我需要你们测，这样进步快，才会真是学会。只看不练假把戏。</p><p>​现在我们说他们的区别：<br>​这个才是真正要学的地方<br>​我们需要下断点</p><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/5-31-1-1.png"></p><p>​我希望你是在断点调试，具体就贴太多，你会发现代码跑到Yield return num的时候，当前函数就会结束，并把这个num交给这里，我先上图</p><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/5-31-1-2.png"></p><p>​最终会给item变量。<br>​然后输出，然后在执行 GetAllEvenNumber（）方法，和上次得到偶数是一样。<br>​我们发现这个Yield Return是可以让当前函数的进程状态切换到阻塞状态，然后去选择了把cpu交给当前的出进程，这样就转而执行调用方函数。 （补充个小知识点其实我们写的程序加入到内存中，并不定就是一个进程，我们会根据情况分成几个子进程去干活，方便操作系统去管理以及多道程序运行在内存，提高计算机资源的利用率）<br>​这样有个好处，我们假如有1000000个数据，我们需要得到里面的耦合，当我们通过这个方法得到一个耦合会立马显示在控制台上。而不是等很久也就把全部偶数都查找到存入集合当中，然后在一一遍历输出。<br>​这个好处是很大的。比如我们用户可能就看数据开始肯定不是全部值需要部分就可以，看完这些在看后面的，这样数据会让觉得显示没有延迟。</p><p>​下面我们来断点调一般的查找偶数的函数</p><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/5-31-1-3.png"></p><p>​我们发现这个循环没有跑完是不会退出当前函数的，也就是必须要查找全部的偶数才可以。这样假如我们很多数据。就会一直等这个数据才可以拿到这个数据去显示给用户看。<br>这样就麻烦了。</p><p>​因此我们下个结论：Yield Return关键字的作用就是退出当前函数，并且会保存当前函数执行到什么地方，也就上下文。你发现没下次执行这个函数上次跑来的代码是不会重复执行的，</p><p>​但是你一般的return result 假如你在循环体提前return ,下面调这个函数是会从第一步开始重新执行的。不会记录上次执行的地方。</p><p>​<strong>转自CSDN :</strong> <a href="https://blog.csdn.net/qq_33060405/article/details/78484825">彻底搞懂C#之Yield Return语法的作用和好处_牛掰是怎么形成的的博客-CSDN博客_c# yield</a></p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C Sharp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C# 连接数据库</title>
    <link href="/2022/05/30/CSharp-%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2022/05/30/CSharp-%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="C-连接数据库"><a href="#C-连接数据库" class="headerlink" title="C# 连接数据库"></a>C# 连接数据库</h1><h2 id="c-连接数据库的步骤，和相关的方法调用"><a href="#c-连接数据库的步骤，和相关的方法调用" class="headerlink" title="c# 连接数据库的步骤，和相关的方法调用"></a>c# 连接数据库的步骤，和相关的方法调用</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//第一步：创建Connection 数据库连接对象</span><br>         SqlConnection conn = <span class="hljs-keyword">new</span> SqlConnection(<span class="hljs-string">&quot;server = . ; uid = sa ; pwd = jnos;database = JINGDONGDB&quot;</span>);<br>         <br><span class="hljs-comment">//第二步：打开连接数据库</span><br>         conn.Open();<br>         <br><span class="hljs-comment">//第三步：使用数据库，@符号表示可以换行，代码也连接在一起</span><br>         <span class="hljs-built_in">string</span> sql = <span class="hljs-string">$@&quot;select ProductNo, ProductName, ProductImage,</span><br><span class="hljs-string">        Price,password from Product where ProductNo=<span class="hljs-subst">&#123;_ProductNo&#125;</span>and</span><br><span class="hljs-string">         password=&#x27;<span class="hljs-subst">&#123;_password&#125;</span>&#x27;&quot;</span>;   <br>         <br>SqlCommand command = <span class="hljs-keyword">new</span> SqlCommand(sql,conn);<br>         SqlDataReader reader = command.ExecuteReader();<span class="hljs-comment">//</span><br><br><span class="hljs-comment">//在数据库里面是为  next（） 有数据为 true 没有数据为 flase</span><br>         <span class="hljs-keyword">if</span> (reader.Read())<br>         &#123;<br>             <span class="hljs-built_in">string</span> ProductNo = reader[<span class="hljs-string">&quot;ProductNo&quot;</span>].ToString();<br>             <span class="hljs-built_in">string</span> ProductName = reader[<span class="hljs-string">&quot;ProductName&quot;</span>].ToString();<br>             MessageBox.Show(<span class="hljs-string">$&quot;欢迎<span class="hljs-subst">&#123;ProductName&#125;</span>登录成功&quot;</span>);<br>         &#125;<br>         <span class="hljs-keyword">else</span><br>         &#123;<br>             MessageBox.Show(<span class="hljs-string">&quot;账号或密码错误，请重新输入！&quot;</span>);<br>         &#125;<br><br><br><br>         <span class="hljs-comment">//int resule = command.ExecuteNonQuery();//添加、删除、修改（返回行数受影响）接SqlCommand command = new SqlCommand(sql,conn);</span><br>                                                                 <span class="hljs-comment">//行 是添加删除修改的步骤</span><br>         <span class="hljs-comment">//object result = command.ExecuteScalar();//查询聚合函数用到</span><br>         <span class="hljs-comment">//if(resule &gt; 0)</span><br>         <span class="hljs-comment">//&#123;</span><br>         <span class="hljs-comment">//    MessageBox.Show(&quot;删除成功&quot;);</span><br>         <span class="hljs-comment">//&#125;</span><br>         <span class="hljs-comment">//else</span><br>         <span class="hljs-comment">//&#123;</span><br>         <span class="hljs-comment">//    MessageBox.Show(&quot;删除失败&quot;);</span><br>         <span class="hljs-comment">//&#125;</span><br>         <span class="hljs-comment">//第四步：关闭连接对象</span><br>         conn.Close();<br><br></code></pre></td></tr></table></figure><h3 id="相关的方法调用："><a href="#相关的方法调用：" class="headerlink" title="相关的方法调用："></a>相关的方法调用：</h3><p>command.ExecuteNonQuery：添加、删除、修改（返回行数受影响<br>command.ExecuteScalar：查询聚合函数<br>command.ExecuteReader：查询单列函数</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C# Array、ArrayList和List的区别</title>
    <link href="/2022/05/30/C%20Sharp%E4%B9%8BArray%E3%80%81ArrayList%E5%92%8CList%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/05/30/C%20Sharp%E4%B9%8BArray%E3%80%81ArrayList%E5%92%8CList%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="C-Array、ArrayList和List的区别"><a href="#C-Array、ArrayList和List的区别" class="headerlink" title="C#Array、ArrayList和List的区别"></a>C#Array、ArrayList和List的区别</h1><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><p>​<strong>Array</strong> 类是 C# 中所有数组的基类，它是在 System 命名空间中定义。Array 类提供了各种⽤于数组的属性和⽅法。<br>属性如： IsReadOnly数组只读。Length数组长度。<br>⽅法常⽤的如下： </p><ol><li><p><strong>Clear</strong><br>根据元素的类型，设置数组中某个范围的元素为零、为 false 或者为 null。 </p></li><li><p><strong>Copy(Array, Array, Int32)</strong><br>从数组的第⼀个元素开始复制某个范围的元素到另⼀个数组的第⼀个元素位置。长度由⼀个 32 位整数指定。 </p></li><li><p><strong>CopyTo(Array, Int32)</strong><br>从当前的⼀维数组中复制所有的元素到⼀个指定的⼀维数组的指定索引位置。索引由⼀个 32 位整数指定。 </p></li><li><p><strong>GetLength</strong><br>获取⼀个 32 位整数，该值表⽰指定维度的数组中的元素总数。 </p></li><li><p><strong>GetType</strong><br>获取当前实例的类型。从对象（Object）继承。 </p></li><li><p><strong>GetValue(Int32)</strong><br>获取⼀维数组中指定位置的值。索引由⼀个 32 位整数指定。 </p></li><li><p><strong>IndexOf(Array, Object)</strong><br>搜索指定的对象，返回整个⼀维数组中第⼀次出现的索引。 </p></li><li><p><strong>Reverse(Array)</strong><br>逆转整个⼀维数组中元素的顺序。 </p></li><li><p><strong>SetValue(Object, Int32)</strong><br>给⼀维数组中指定位置的元素设置值。索引由⼀个 32 位整数指定。</p></li><li><p><strong>Sort(Array)</strong><br>使⽤数组的每个元素的 IComparable 实现来排序整个⼀维数组中的元素。 </p></li><li><p><strong>ToString</strong><br>返回⼀个表⽰当前对象的字符串。从对象（Object）继承。</p></li></ol><p>使⽤⽅法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">int</span>[] nums = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span> &#125;;<br>Array.Sort(nums);<br></code></pre></td></tr></table></figure><hr><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>​<strong>ArrayList</strong>动态数组，是.Net Framework提供的⽤于数据存储和检索的专⽤类，它是命名空间System.Collections下的⼀部分。它的<br>⼤⼩是按照其中存储的数据来动态扩充与收缩的。所以，我们在声明ArrayList对象时并不需要指定它的长度。ArrayList继承了IList接⼝，<br>所以它可以很⽅便的进⾏数据的添加，插⼊和移除.比如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C#">ArrayList al = <span class="hljs-keyword">new</span> ArrayList();<br><span class="hljs-comment">//新增数据</span><br>al.Add(<span class="hljs-string">&quot;abc&quot;</span>); al.Add(<span class="hljs-number">123</span>);<br><span class="hljs-comment">//修改数据</span><br>al[<span class="hljs-number">2</span>] = <span class="hljs-number">345</span>;<br><span class="hljs-comment">//移除数据</span><br>al.RemoveAt(<span class="hljs-number">0</span>);<br><span class="hljs-comment">//插⼊数据</span><br>al.Insert(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;hello world&quot;</span>);<br></code></pre></td></tr></table></figure><hr><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>​在ArrayList中，我们不仅插⼊了字符串”abc”，⽽且⼜插⼊了数字123。这样在ArrayList中插⼊不同类型的数据是允许的。因为<br>ArrayList会把所有插⼊其中的数据都当作为object类型来处理。这样，在我们使⽤ArrayList中的数据来处理问题的时候，很可能会报类型<br>不匹配的错误，也就是说ArrayList不是类型安全的。既使我们保证在插⼊数据的时候都很小心，都有插⼊了同⼀类型的数据，但在使⽤的<br>时候，我们也需要将它们转化为对应的原类型来处理。这就存在了装箱与拆箱的操作，会带来很⼤的性能损耗。<br>　　正是因为ArrayList存在不安全类型与装箱拆箱的缺点，所以在C#2.0后出现了泛型的概念。⽽<strong>List</strong>类是ArrayList类的泛型等效类。它<br>的⼤部分⽤法都与ArrayList相似，因为List类也继承了IList接⼝。最关键的区别在于，在声明List集合时，我们同时需要为其声明List集合<br>内数据的对象类型。 比如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C#">List&lt;<span class="hljs-built_in">int</span>&gt; list = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;();<br><span class="hljs-comment">//新增数据</span><br> list.Add(<span class="hljs-number">123</span>);<br><span class="hljs-comment">//修改数据</span><br>list[<span class="hljs-number">0</span>] = <span class="hljs-number">345</span>;<br><span class="hljs-comment">//移除数据</span><br>list.RemoveAt(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>​上例中，如果我们往List泛型集合中插⼊string字符”hello world”，IDE就会报错，且不能通过编译。这样就避免了前⾯讲的类型安全问题与装箱拆箱的性能问题了。</p><p><strong>List泛型的好处：</strong><br>　　通过允许指定泛型类或⽅法操作的特定类型，泛型功能将类型安全的任务从您转移给了编译器。不需要编写代码来检测数据类型是否正确，因为会在编译时强制使⽤正确的数据类型。减少了类型强制转换的需要和运⾏时错误的可能性。泛型提供了类型安全但没有增加多个实现的开销。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p>三者都⽤来处理⼀组数据，继承了IEnumerable接⼝，可⽤于for循环处理。都可以通过索引下标进⾏获取和设置元素。</p></li><li><p>Array在内存中是连续的，长度固定，⽆法删除和增加新的元素。⽽ArrayList或List的容量可根据需要⾃动插⼊和删除元素。</p></li><li><p>Array可以具有多个维度，⽽ ArrayList或 List&lt; T&gt; 始终只具有⼀个维度。但是，您可以轻松创建数组列表或列表的列表。</p></li><li><p>特定类型（Object 除外）的数组 的性能优于 ArrayList的性能。 这是因为 ArrayList的元素属于 Object 类型；所以在存储或检索值类型时通常发⽣装箱和拆箱操作。不过，在不需要重新分配时（即最初的容量⼗分接近列表的最⼤容量），List&lt; T&gt; 的性能与同类型的数组⼗分相近。</p></li><li><p>在决定使⽤ List 还是使⽤ArrayList 类（两者具有类似的功能）时，记住List 类在⼤多数情况下执⾏得更好并且是类型安全的。如果对<br>List&lt; T&gt; 类的类型T 使⽤引⽤类型，则两个类的⾏为是完全相同的。但是，如果对类型T使⽤值类型，则需要考虑实现和装箱问题。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C Sharp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/05/29/hello-world/"/>
    <url>/2022/05/29/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
