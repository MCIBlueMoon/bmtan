

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Bmtan">
  <meta name="keywords" content="">
  
    <meta name="description" content="面试UnityDrawCall问题 什么是DrawCall?   DrawCall 是 Cpu准备好渲染的数据后告知GPU渲染的命令   DrawCall过高影响什么性能？   会造成很多额外的性能开销，且CPU会把大量时间花费再Draw Call 上，造成CPU过载。   如何降低DrawCall   小图合成大图，即多个小DrawCall变一次大DrawCall  拼面板时严格控制不同图集层级">
<meta property="og:type" content="article">
<meta property="og:title" content="Unity 客户端面试">
<meta property="og:url" content="http://bmtan.cc/2023/02/01/Unity%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%9D%A2%E8%AF%95/index.html">
<meta property="og:site_name" content="Bmtan">
<meta property="og:description" content="面试UnityDrawCall问题 什么是DrawCall?   DrawCall 是 Cpu准备好渲染的数据后告知GPU渲染的命令   DrawCall过高影响什么性能？   会造成很多额外的性能开销，且CPU会把大量时间花费再Draw Call 上，造成CPU过载。   如何降低DrawCall   小图合成大图，即多个小DrawCall变一次大DrawCall  拼面板时严格控制不同图集层级">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201202110747790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xMTExMX18=,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201201161048150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xMTExMX18=,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230201222507758.png">
<meta property="og:image" content="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230201222538994.png">
<meta property="og:image" content="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230201221201268.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/b99d714ae81d4ed08afb9a933e5df2ea.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/cdda4b5f61374524bf3082080d30c4fb.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210530224055792.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzeTc3Nzc3Nw==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210530224106137.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzeTc3Nzc3Nw==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/V2QJXN%25LGY17_GWQIJ%24%7D1W1.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/1daa0def8e454f61836f28a8d1cb2e0b.gif">
<meta property="og:image" content="https://img-blog.csdnimg.cn/15b1cfff79a049f0bef2dc98617d8d8d.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/d7de02f14c6c45f7ad9e75888ed6254b.gif">
<meta property="og:image" content="https://img-blog.csdnimg.cn/15b1cfff79a049f0bef2dc98617d8d8d.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/b72900449cb44c15999f8d89c286bb69.gif">
<meta property="og:image" content="https://img-blog.csdnimg.cn/5ca6790d2c4740ba86e8b956475dd2bd.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/5ff1f36a0e694cbc9ffd5f2e6089a821.gif">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2b6aaaf6b5914b2eb6efa5e559c18840.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/e33fa55d2e98407ea12bbc0b99221487.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/8f1362ccb2a043d98977410ba95406e2.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/5eaad2f07d4e400daff97217f6b7ab49.gif">
<meta property="og:image" content="https://img-blog.csdnimg.cn/0c66af0a2da0474d94384b06847ba235.gif">
<meta property="og:image" content="https://img-blog.csdnimg.cn/9fbfeab31f384aad9329a49fe345f678.gif">
<meta property="og:image" content="https://img-blog.csdnimg.cn/b7e8e42333e1432bb1a494d301c1c41e.gif">
<meta property="og:image" content="https://img-blog.csdnimg.cn/de00f05f30634bf3aa413803b3f35d4b.gif">
<meta property="og:image" content="https://img-blog.csdnimg.cn/49a4114d2323450792d15706511acdf4.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/842750f7516f4a62aa62e32a07190c1d.png">
<meta property="article:published_time" content="2023-02-01T14:44:00.000Z">
<meta property="article:modified_time" content="2023-02-01T16:58:24.538Z">
<meta property="article:author" content="Bmtan">
<meta property="article:tag" content="Unity">
<meta property="article:tag" content="C#">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="Lua">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20201202110747790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xMTExMX18=,size_16,color_FFFFFF,t_70">
  
  
  
  <title>Unity 客户端面试 - Bmtan</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"bmtan.cc","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Bmtan blog&#39;s</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Unity 客户端面试"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-02-01 22:44" pubdate>
          2023年2月1日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          17k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          140 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Unity 客户端面试</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h1><h2 id="Unity"><a href="#Unity" class="headerlink" title="Unity"></a>Unity</h2><h3 id="DrawCall问题"><a href="#DrawCall问题" class="headerlink" title="DrawCall问题"></a>DrawCall问题</h3><blockquote>
<p>什么是DrawCall?</p>
</blockquote>
<ul>
<li>DrawCall 是 Cpu准备好渲染的数据后告知GPU渲染的命令</li>
</ul>
<blockquote>
<p>DrawCall过高影响什么性能？</p>
</blockquote>
<ul>
<li>会造成很多额外的性能开销，且CPU会把大量时间花费再Draw Call 上，造成CPU过载。</li>
</ul>
<blockquote>
<p>如何降低DrawCall</p>
</blockquote>
<ol>
<li><p>小图合成大图，即多个小DrawCall变一次大DrawCall</p>
</li>
<li><p>拼面板时严格控制不同图集层级处理</p>
</li>
<li><p>静态批处理</p>
</li>
<li><p>动态批处理</p>
</li>
</ol>
<blockquote>
<p>静态批处理</p>
</blockquote>
<ul>
<li><p><img src="https://img-blog.csdnimg.cn/20201202110747790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xMTExMX18=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="img"></p>
<p> 只要勾选上Static并拥有相同材质的物体即可在运行时进行静态批处理<br> <strong>但是静态批处理会为每一个物体创建一个合并后的Combined Mesh，需要额外的内存空间来存储合并后的Combined Mesh，所以使用时要慎用(例如一片浓密的草地，如果使用静态批处理则会造成严重的内存开销)</strong></p>
</li>
</ul>
<blockquote>
<p>动态批处理 </p>
</blockquote>
<ul>
<li><p><img src="https://img-blog.csdnimg.cn/20201201161048150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xMTExMX18=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="img"></p>
<p> 动态批处理默认是关闭的，需要手动开启：Project Setting—Player—勾上Dynamic Batching</p>
</li>
</ul>
<p><font color = "red"><b>总结</b></font></p>
<p><font color = "red"><b>——静态批处理和动态批处理都能降低DrawCall，最主要的前提是物体使用同一个材质</b></font><br><font color = "red"><b>——静态批处理适用于场景中位置不会改变并且单对象不能太多的物体，像树林，草地这种用动态批处理更适合</b></font><br><font color = "red"><b>——动态批处理限制较多，顶点数要求，材质要求等等。静态批处理限制较少，是用内存换性能的方法，具体情况具体分析</b></font></p>
<h3 id="Unity中当一个细小高速物体撞击另一个较大物体时会出现什么情况？如何避免？"><a href="#Unity中当一个细小高速物体撞击另一个较大物体时会出现什么情况？如何避免？" class="headerlink" title="Unity中当一个细小高速物体撞击另一个较大物体时会出现什么情况？如何避免？"></a>Unity中当一个细小高速物体撞击另一个较大物体时会出现什么情况？如何避免？</h3><p>1.我们可以尽量用射线检测来替代细小物体的物理系统碰撞<br>因为传统的FPS游戏都是通过射线检测加模拟计算来判断伤害的<br>2.修改Rigidbody刚体中的Interpolate（插值）和CollisionDetection（碰撞检测）两个参数，来提高碰撞检测的准确性</p>
<h3 id="请简述一下Prefab（预制体）的本质是什么？"><a href="#请简述一下Prefab（预制体）的本质是什么？" class="headerlink" title="请简述一下Prefab（预制体）的本质是什么？"></a>请简述一下Prefab（预制体）的本质是什么？</h3><p>Prefab的本质就是一个配置文件<br>其中记录了一个GameObject对象上挂载的脚本信息<br>并且记录了脚本信息中的可配置的属性信息</p>
<h3 id="Unity是否支持写成多线程程序？如果支持的话需要注意什么？"><a href="#Unity是否支持写成多线程程序？如果支持的话需要注意什么？" class="headerlink" title="Unity是否支持写成多线程程序？如果支持的话需要注意什么？"></a>Unity是否支持写成多线程程序？如果支持的话需要注意什么？</h3><p>1.只能从主线程访问Unity相关组件、对象以及<br>UnityEngine命名空间中的绝大部分内容<br>2.如果多线程中要和Unity主线程同时修改一些数据<br>可以通过lock关键词加锁</p>
<h3 id="请简述一下对象池，在游戏开发中我们什么时候会用到它？"><a href="#请简述一下对象池，在游戏开发中我们什么时候会用到它？" class="headerlink" title="请简述一下对象池，在游戏开发中我们什么时候会用到它？"></a>请简述一下对象池，在游戏开发中我们什么时候会用到它？</h3><ol>
<li><p>对象池的主要作用是 <strong>避免大量创建对象再释放对象时造成的内存消耗，可以有效降低GC发生的频率</strong>。我们把不用的对象放入对象池中而不是让它直接变为垃圾，下次需要用到对象时再从对象池中获取，我们通过占用内存来避免更多的内存消耗和GC的发生</p>
</li>
<li><p>在游戏中频繁创建对象、实例化对象的地方，都可以用到对象池。<br>比如前端开发中，游戏中的子弹、伤害字体、特效等等<br>比如后端开发中线程池等等</p>
</li>
</ol>
<h3 id="Unity中点乘和叉乘对于我们来说的作用是什么？"><a href="#Unity中点乘和叉乘对于我们来说的作用是什么？" class="headerlink" title="Unity中点乘和叉乘对于我们来说的作用是什么？"></a>Unity中点乘和叉乘对于我们来说的作用是什么？</h3><p><strong>点乘作用</strong></p>
<ol>
<li><p>判断对象的方位</p>
</li>
<li><p>计算两向量之间的夹角</p>
</li>
</ol>
<p><strong>叉乘作用</strong></p>
<ol>
<li><p>获取一个平面的法向量</p>
</li>
<li><p>得到两向量之间的左右位置关系</p>
</li>
</ol>
<h3 id="Application-streamingAssetsPath-和-Application-persistentDataPath两个路径有何区别？对于我们的意义是什么？"><a href="#Application-streamingAssetsPath-和-Application-persistentDataPath两个路径有何区别？对于我们的意义是什么？" class="headerlink" title="Application.streamingAssetsPath 和 Application.persistentDataPath两个路径有何区别？对于我们的意义是什么？"></a>Application.streamingAssetsPath 和 Application.persistentDataPath两个路径有何区别？对于我们的意义是什么？</h3><p>Application.streamingAssetsPath   只读<br>Application.persistentDataPath      可读可写</p>
<p>Application.streamingAssetsPath   适合放置一些默认2进制配置文件<br>Application.persistentDataPath      用于处理数据持久化，或作为热更新下载内容的存放目录，因为它可读可写</p>
<h3 id="请简述Unity中协程的原理"><a href="#请简述Unity中协程的原理" class="headerlink" title="请简述Unity中协程的原理"></a>请简述Unity中协程的原理</h3><p>Unity中的协同程序分为<strong>两部分</strong></p>
<ol>
<li>协程函数本体（<strong>迭代器函数</strong>）</li>
<li>协程调度器（<strong>协程管理器</strong>）</li>
</ol>
<p>协程利用迭代器函数的分步执行的特点<br>加上<br>协程调度器对迭代器函数们进行统一管理<br>根据迭代器函数的返回值来决定下一次执行函数逻辑的时间点<br>从而实现逻辑分时分步执行的目的</p>
<h3 id="Unity中当一个细小高速物体撞击另一个较大物体时会出现什么情况？如何避免？-1"><a href="#Unity中当一个细小高速物体撞击另一个较大物体时会出现什么情况？如何避免？-1" class="headerlink" title="Unity中当一个细小高速物体撞击另一个较大物体时会出现什么情况？如何避免？"></a>Unity中当一个细小高速物体撞击另一个较大物体时会出现什么情况？如何避免？</h3><ol>
<li>我们可以尽量用射线检测来替代细小物体的物理系统碰撞<br>因为传统的FPS游戏都是通过射线检测加模拟计算来判断伤害的</li>
<li>修改Rigidbody刚体中的<strong>Interpolate（插值）</strong>和<strong>CollisionDetection（碰撞检测）</strong>两个参数，来提高碰撞检测的准确性</li>
</ol>
<table>
<thead>
<tr>
<th><strong>Interpolate</strong></th>
<th>仅当在刚体运动中看到急动时才尝试使用提供的选项之一。</th>
</tr>
</thead>
<tbody><tr>
<td>- <strong>None</strong></td>
<td>不应用插值。</td>
</tr>
<tr>
<td>- <strong>Interpolate</strong></td>
<td>根据前一帧的变换来平滑变换。</td>
</tr>
<tr>
<td>- <strong>Extrapolate</strong></td>
<td>根据下一帧的估计变换来平滑变换。</td>
</tr>
<tr>
<td><strong>Collision Detection</strong></td>
<td>用于防止快速移动的对象穿过其他对象而不检测碰撞。</td>
</tr>
<tr>
<td>- <strong>Discrete</strong></td>
<td>对场景中的所有其他碰撞体使用离散碰撞检测。其他碰撞体在测试碰撞时会使用离散碰撞检测。用于正常碰撞（这是默认值）。</td>
</tr>
<tr>
<td>- <strong>Continuous</strong></td>
<td>对动态碰撞体（具有刚体）使用离散碰撞检测，并对静态碰撞体（没有刚体）使用基于扫掠的连续碰撞检测。设置为__连续动态 (Continuous Dynamic)__ 的刚体将在测试与该刚体的碰撞时使用连续碰撞检测。其他刚体将使用离散碰撞检测。用于__连续动态 (Continuous Dynamic)__ 检测需要碰撞的对象。（此属性对物理性能有很大影响，如果没有快速对象的碰撞问题，请将其保留为 <strong>Discrete</strong> 设置）</td>
</tr>
<tr>
<td>- <strong>Continuous Dynamic</strong></td>
<td>对设置为__连续 (Continuous)__ 和__连续动态 (Continuous Dynamic)__ 碰撞的游戏对象使用基于扫掠的连续碰撞检测。还将对静态碰撞体（没有刚体）使用连续碰撞检测。对于所有其他碰撞体，使用离散碰撞检测。用于快速移动的对象。</td>
</tr>
<tr>
<td>- <strong>Continuous Speculative</strong></td>
<td>对刚体和碰撞体使用推测性连续碰撞检测。这也是可以设置运动物体的唯一 CCD 模式。该方法通常比基于扫掠的连续碰撞检测的成本更低。</td>
</tr>
</tbody></table>
<h3 id="Unity底层如何处理C-代码？"><a href="#Unity底层如何处理C-代码？" class="headerlink" title="Unity底层如何处理C#代码？"></a>Unity底层如何处理C#代码？</h3><p>两种方案<br><font color = "red"><b>Mono和IL2CPP</b></font></p>
<blockquote>
<p>Mono</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230201222507758.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>IL2CPP</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230201222538994.png" srcset="/img/loading.gif" lazyload></p>
<hr>
<h2 id="C"><a href="#C" class="headerlink" title="C#"></a>C#</h2><h3 id="请说说你认为C-中-x3D-x3D-和-Equals-的区别是什么？"><a href="#请说说你认为C-中-x3D-x3D-和-Equals-的区别是什么？" class="headerlink" title="请说说你认为C#中 &#x3D;&#x3D; 和 Equals 的区别是什么？"></a>请说说你认为C#中 &#x3D;&#x3D; 和 Equals 的区别是什么？</h3><ol>
<li>&#x3D;&#x3D; 是运算符，Equals是万物之父Object中的虚方法，子类可重写</li>
<li>Equals 一般在子类中重写后用于比较两个对象中内容是否相同<br> &#x3D;&#x3D;在没有运算符重载的前提下时<br> 引用类型用于比较地址；值类型用于比较值是否相同</li>
<li>运算效率不同，一般Equals没有&#x3D;&#x3D;效率高，因为一般Equals比较的内容比&#x3D;&#x3D;多</li>
</ol>
<h3 id="浅拷贝和深拷贝的区别？可以举例说明"><a href="#浅拷贝和深拷贝的区别？可以举例说明" class="headerlink" title="浅拷贝和深拷贝的区别？可以举例说明"></a>浅拷贝和深拷贝的区别？可以举例说明</h3><p><strong>浅拷贝：</strong><br>只复制对象的引用地址<br>两个对象指向同一内存地址，修改其中一个另一个也会随之变化</p>
<p><strong>深拷贝：</strong><br>将对象和值赋值过来，两个对象修改其中任意值都不会影响对方</p>
<p>举例：<br>比如引用对象A和引用对象B<br>让A &#x3D; B，就是浅拷贝，此时A、B的引用地址相同，改A中内容，B也变</p>
<p>如果想要深拷贝，简单处理就是new（包括对象中的成员）</p>
<h3 id="装箱和拆箱是指什么？"><a href="#装箱和拆箱是指什么？" class="headerlink" title="装箱和拆箱是指什么？"></a>装箱和拆箱是指什么？</h3><p>装箱——把栈中内容迁移到堆中去（值转引用）<br>拆箱——把堆中内容迁移到栈中去（引用转值）</p>
<p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230201221201268.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="值和引用类型在变量赋值时的区别是什么？"><a href="#值和引用类型在变量赋值时的区别是什么？" class="headerlink" title="值和引用类型在变量赋值时的区别是什么？"></a>值和引用类型在变量赋值时的区别是什么？</h3><p>在C#中<strong>值类型的变量直接存储数据</strong>，而<strong>引用类型的变量持有的是数据的引用，数据存储在数据堆中</strong>。</p>
<p><strong>值类型</strong>（value type）：byte，short，int，long，float，double，decimal，char，bool 和 struct 统称为值类型。值类型变量声明后，不管是否已经赋值，编译器为其分配内存。<br><img src="https://img-blog.csdnimg.cn/b99d714ae81d4ed08afb9a933e5df2ea.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br><strong>引用类型</strong>（reference type）：string 和 class统称为引用类型。当声明一个类时，只在栈中分配一小片内存用于容纳一个地址，而此时并没有为其分配堆上的内存空间。当使用 new 创建一个类的实例时，分配堆上的空间，并把堆上空间的地址保存到栈上分配的小片空间中。<br><img src="https://img-blog.csdnimg.cn/cdda4b5f61374524bf3082080d30c4fb.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>值类型的实例通常是在线程栈上分配的（静态分配），但是在某些情形下可以存储在堆中。引用类型的对象总是在进程堆中分配（动态分配)。</p>
<h3 id="委托和事件在使用上的区别是什么？"><a href="#委托和事件在使用上的区别是什么？" class="headerlink" title="委托和事件在使用上的区别是什么？"></a>委托和事件在使用上的区别是什么？</h3><p>事件相对委托来说，事件在外部使用时只能 +&#x3D;、-&#x3D;</p>
<h3 id="请说明C-中的List是如何扩容的"><a href="#请说明C-中的List是如何扩容的" class="headerlink" title="请说明C#中的List是如何扩容的"></a>请说明C#中的List是如何扩容的</h3><p>List的本质是数组</p>
<h3 id="C-中try-catch-finally的执行顺序"><a href="#C-中try-catch-finally的执行顺序" class="headerlink" title="C#中try catch finally的执行顺序"></a>C#中try catch finally的执行顺序</h3><p>1.首先明确一点，就是不管怎样，finally一定会执行，即使程序有异常，并且在catch中thorw 了 ，finally还是会被执行。</p>
<p>2.当try和catch中有return时，finally仍然执行。</p>
<p>3.finally是在return后面的表达式运算完之后执行的，在执行完return时 ，程序并没有跳出，而是进入到finally中继续执行，</p>
<p> 如果在finally如果对返回值进行了重新赋值，分为两种情况：</p>
<p>（1）当返回值是值类型（包括string类型，虽然是引用类型，这是特殊的个例）时，返回的值不受影响，</p>
<p>​    就是在trycatch时，返回的值已经确定了。</p>
<p>（2）当返回值是引用类型时，会影响到返回值，</p>
<p>eg:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span>[] <span class="hljs-title">TestYinYong</span>()</span><br>     &#123;<br>         <span class="hljs-built_in">string</span>[] arr = &#123; <span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span> &#125;;<br>         <span class="hljs-keyword">try</span><br>         &#123;<br>             <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception();<br>         &#125;<br>         <span class="hljs-keyword">catch</span> (Exception)<br>         &#123;<br>             <span class="hljs-keyword">return</span> arr;<br>         &#125;<br>         <span class="hljs-keyword">finally</span><br>         &#123;<br>             arr[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;three&quot;</span>;<br>         &#125;<br>     &#125;<br></code></pre></td></tr></table></figure>

<p>此时返回的值是：{ “one”, “three” };</p>
<p>4.finally中不能有return语句，编译都无法通过，提示：控制不能离开finally子句主体</p>
<hr>
<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP UDP"></a>TCP UDP</h3><p>TCP&#x2F;IP协议（一）网络基础知识 网络七层协议<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wanghuaijun/p/10092930.html">https://www.cnblogs.com/wanghuaijun/p/10092930.html</a></p>
<ul>
<li><strong>TCP</strong>(Transmission Control Protocol 传输控制协议)：<strong>是一种面向连接的、可靠的、基于字节流的传输层通信协议</strong>，使用三次握手协议建立连接、四次挥手断开连接。面向连接意味着两个使用TCP的应用(通常是一个客户端和一个服务器)在彼此交换数据包之前必须先建立一个TCP连接。在一个TCP连接中，仅有两方进行彼此通信，广播和多播不能用TCP。TCP 协议的作用是，保证数据通信的完整性和可靠性，防止丢包。TCP把连接作为最基本的对象，每一条TCP连接都有两个端点，这种端点我们叫作套接字(socket)，端口号拼接到IP地址即构成了套接字。</li>
<li><strong>UDP</strong>(User Datagram Protocol 用户数据报协议)：<strong>是OSI</strong>(Open System Interconnection 开放式系统互联)<strong>参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务</strong>。UDP协议的主要作用是将网络数据流量压缩成数据包的形式。</li>
<li>区别：<ul>
<li>TCP提供的是面向连接的、可靠的数据流传输；UDP提供的是非面向连接的、不可靠的数据流传输。</li>
<li>TCP提供可靠的服务，通过TCP连接传送的数据，无差错、不丢失、不重复，按序到达；UDP尽最大努力交付，即不保证可靠交付。</li>
<li>TCP面向字节流；UDP面向报文。</li>
<li>TCP连接只能是点到点的；UDP支持一对一、一对多、多对一和多对多的交互通信。</li>
<li>UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。</li>
<li>TCP对系统资源要求较多，UDP对系统资源要求较少。TCP首部有20字节；UDP的首部只有8个字节。</li>
<li>TCP的逻辑通信信道是全双工的可靠信道；UDP的逻辑通信信道是不可靠信道。</li>
<li>基于TCP的应用：HTTP、WebSocker、重要数据文件传输等常见</li>
<li>基于UDP的应用：QQ等部分实时通信软件、视频&#x2F;音频下载传输等。</li>
</ul>
</li>
</ul>
<h3 id="三次握手，4次挥手"><a href="#三次握手，4次挥手" class="headerlink" title="三次握手，4次挥手"></a>三次握手，4次挥手</h3><ul>
<li><strong>三次握手</strong><ul>
<li>第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 SYN_Send状态。</li>
<li>第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD的状态。</li>
<li>第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 establised状态。</li>
<li>服务器收到 ACK 报文之后，也处于 establised 状态，此时，双方以建立起了链接。</li>
</ul>
</li>
<li><strong>四次挥手</strong><ul>
<li>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于CLOSED_WAIT1状态。</li>
<li>第二次握手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT2状态。</li>
<li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK的状态。</li>
<li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态</li>
<li>服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</li>
</ul>
</li>
</ul>
<h3 id="状态同步-帧同步"><a href="#状态同步-帧同步" class="headerlink" title="状态同步,帧同步"></a>状态同步,帧同步</h3><p>帧同步和状态同步该怎么选（上）<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/104932624">https://zhuanlan.zhihu.com/p/104932624</a></p>
<p>帧同步和状态同步<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/33898014">https://zhuanlan.zhihu.com/p/33898014</a></p>
<h3 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h3><p>OSI（Open System Interconnection）是由国际标准化组织（ISO）制定的网络模型，该模型定义了不同计算机如何互相连接，是设计和描述计算机网络通信的基本框架。<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=OSI%E6%A8%A1%E5%9E%8B&spm=1001.2101.3001.7020">OSI模型</a>将网络通信分为7层：</p>
<p><img src="https://img-blog.csdnimg.cn/20210530224055792.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzeTc3Nzc3Nw==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p>OSI仅是一个理论上的模型，实际使用的是TCP&#x2F;IP网络模型，TCP&#x2F;IP模型将OSI模型的应用层，表示层和会话层合并为应用层：</p>
<p><img src="https://img-blog.csdnimg.cn/20210530224106137.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzeTc3Nzc3Nw==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="img"></p>
<hr>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problemset/all/">题库 - 力扣 (LeetCode) 全球极客挚爱的技术成长平台</a></p>
<p><strong>每日一题</strong></p>
<p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/V2QJXN%25LGY17_GWQIJ%24%7D1W1.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="十大排序算法"><a href="#十大排序算法" class="headerlink" title="十大排序算法"></a>十大排序算法</h3><h4 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h4><p><img src="https://img-blog.csdnimg.cn/1daa0def8e454f61836f28a8d1cb2e0b.gif" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p><strong>口诀：</strong></p>
<p>外层循环 n-1;内层循环 n-1-i;两两比较做互换；</p>
<blockquote>
<p>以下代码在控制台操作，输入数字以‘逗号’隔开</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BubbleSort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] array</span>)</span><br>&#123;<br>	<span class="hljs-built_in">bool</span> isSort = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; array.Length; ++i)<br>    &#123;<br>    	isSort = <span class="hljs-literal">false</span>;<br>    	<span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; array.Length - i - <span class="hljs-number">1</span>; ++j)<br>        &#123;<br>        	<span class="hljs-keyword">if</span> (array[j] &gt; array[j + <span class="hljs-number">1</span>])<br>            &#123;<br>            	isSort = <span class="hljs-literal">true</span>;<br><br>				array[j] ^= array[j + <span class="hljs-number">1</span>];<br>                array[j + <span class="hljs-number">1</span>] ^= array[j];<br>                array[j] ^= array[j + <span class="hljs-number">1</span>];<br><br>			&#125;<br>        &#125;<br>        <br>		  	<span class="hljs-keyword">if</span> (!isSort)<br>		  		<span class="hljs-keyword">break</span>;<br>                <br>     &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>程序执行结果：</p>
<p><img src="https://img-blog.csdnimg.cn/15b1cfff79a049f0bef2dc98617d8d8d.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h4 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2.插入排序"></a>2.插入排序</h4><p><img src="https://img-blog.csdnimg.cn/d7de02f14c6c45f7ad9e75888ed6254b.gif" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InsertSort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] array</span>)</span><br>&#123;<br>    <span class="hljs-built_in">int</span> noSortValue;<br>    <span class="hljs-built_in">int</span> sortIndex;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; array.Length; ++i)<br>    &#123;<br>        noSortValue = array[i];<br>        sortIndex = i - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (sortIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; array[sortIndex] &gt; noSortValue)<br>        &#123;<br>            array[sortIndex + <span class="hljs-number">1</span>] = array[sortIndex];<br>            --sortIndex;<br>        &#125;<br>        array[sortIndex + <span class="hljs-number">1</span>] = noSortValue;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>程序执行结果：</p>
<p><img src="https://img-blog.csdnimg.cn/15b1cfff79a049f0bef2dc98617d8d8d.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h4 id="3-选择排序"><a href="#3-选择排序" class="headerlink" title="3.选择排序"></a>3.选择排序</h4><p><img src="https://img-blog.csdnimg.cn/b72900449cb44c15999f8d89c286bb69.gif" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SelectionSort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] array</span>)</span><br>&#123;<br>    <span class="hljs-built_in">int</span> index;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; array.Length; i++)<br>    &#123;<br>        index = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = i + <span class="hljs-number">1</span>; j &lt; array.Length; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (array[index] &gt; array[j])<br>            &#123;<br>                index = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (index != i)<br>        &#123;<br>            array[i] ^= array[index];<br>            array[index] ^= array[i];<br>            array[i] ^= array[index];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<p>程序执行结果：</p>
<p><img src="https://img-blog.csdnimg.cn/5ca6790d2c4740ba86e8b956475dd2bd.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h4 id="4-快速排序"><a href="#4-快速排序" class="headerlink" title="4.快速排序"></a>4.快速排序</h4><p><img src="https://img-blog.csdnimg.cn/5ff1f36a0e694cbc9ffd5f2e6089a821.gif" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p>快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists)。</p>
<p><strong>步骤为：</strong></p>
<ol>
<li><p>从数列中挑出一个元素，称为 “基准”（pivot）。</p>
</li>
<li><p>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆放在基准的后面（相同的数可以到任一边）。在这个分割结束之后，该基准就处于数列的中间位置。这个称为分割（partition）操作。</p>
</li>
<li><p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p>
</li>
</ol>
<p>递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个演算法总会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.Linq;<br><span class="hljs-keyword">using</span> System.Text;<br><br><span class="hljs-keyword">namespace</span> 快速排序    <span class="hljs-comment">//***对相同元素, 不稳定的排序算法***</span><br>&#123;<br>    <span class="hljs-comment">//相对来说，快速排序数值越大速度越快 。  快速排序是所有排序里面最快的</span><br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            <span class="hljs-built_in">int</span>[] arr = &#123; <span class="hljs-number">15</span>, <span class="hljs-number">22</span>, <span class="hljs-number">35</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">33</span>, <span class="hljs-number">15</span>, <span class="hljs-number">23</span>, <span class="hljs-number">68</span>, <span class="hljs-number">1</span>, <span class="hljs-number">33</span>, <span class="hljs-number">25</span>, <span class="hljs-number">14</span> &#125;; <span class="hljs-comment">//待排序数组</span><br>            QuickSort(arr, <span class="hljs-number">0</span>, arr.Length - <span class="hljs-number">1</span>);  <span class="hljs-comment">//调用快速排序函数。传值(要排序数组，基准值位置，数组长度)</span><br><br>            <span class="hljs-comment">//控制台遍历输出</span><br>            Console.WriteLine(<span class="hljs-string">&quot;排序后的数列：&quot;</span>);<br>            <span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">int</span> item <span class="hljs-keyword">in</span> arr)<br>                Console.WriteLine(item);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">QuickSort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] arr, <span class="hljs-built_in">int</span> begin, <span class="hljs-built_in">int</span> end</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (begin &gt;= end) <span class="hljs-keyword">return</span>;   <span class="hljs-comment">//两个指针重合就返回，结束调用</span><br>            <span class="hljs-built_in">int</span> pivotIndex = QuickSort_Once(arr, begin, end);  <span class="hljs-comment">//会得到一个基准值下标</span><br><br>            QuickSort(arr, begin, pivotIndex - <span class="hljs-number">1</span>);  <span class="hljs-comment">//对基准的左端进行排序  递归</span><br>            QuickSort(arr, pivotIndex + <span class="hljs-number">1</span>, end);   <span class="hljs-comment">//对基准的右端进行排序  递归</span><br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">QuickSort_Once</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] arr, <span class="hljs-built_in">int</span> begin, <span class="hljs-built_in">int</span> end</span>)</span><br>        &#123;<br>            <span class="hljs-built_in">int</span> pivot = arr[begin];   <span class="hljs-comment">//将首元素作为基准</span><br>            <span class="hljs-built_in">int</span> i = begin;<br>            <span class="hljs-built_in">int</span> j = end;<br>            <span class="hljs-keyword">while</span> (i &lt; j)<br>            &#123;<br>                <span class="hljs-comment">//从右到左，寻找第一个小于基准pivot的元素</span><br>                <span class="hljs-keyword">while</span> (arr[j] &gt;= pivot &amp;&amp; i &lt; j) j--; <span class="hljs-comment">//指针向前移</span><br>                arr[i] = arr[j];  <span class="hljs-comment">//执行到此，j已指向从右端起第一个小于基准pivot的元素，执行替换</span><br><br>                <span class="hljs-comment">//从左到右，寻找首个大于基准pivot的元素</span><br>                <span class="hljs-keyword">while</span> (arr[i] &lt;= pivot &amp;&amp; i &lt; j) i++; <span class="hljs-comment">//指针向后移</span><br>                arr[j] = arr[i];  <span class="hljs-comment">//执行到此,i已指向从左端起首个大于基准pivot的元素，执行替换</span><br>            &#125;<br><br>            <span class="hljs-comment">//退出while循环,执行至此，必定是 i= j的情况（最后两个指针会碰头）</span><br>            <span class="hljs-comment">//i(或j)所指向的既是基准位置，定位该趟的基准并将该基准位置返回</span><br>            arr[i] = pivot;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="5-希尔排序"><a href="#5-希尔排序" class="headerlink" title="5.希尔排序"></a>5.希尔排序</h4><p>插入排序的升级</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>       &#123;<br>           <span class="hljs-built_in">int</span>[] numlist = &#123; <span class="hljs-number">33</span>, <span class="hljs-number">6</span>, <span class="hljs-number">89</span>, <span class="hljs-number">34</span>, <span class="hljs-number">63</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span> &#125;;<br>           Console.WriteLine(<span class="hljs-string">&quot;排序前数组:&quot;</span>);<br>           <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; numlist.Length; i++)<br>           &#123;<br>               Console.Write(<span class="hljs-string">&quot; &quot;</span>+numlist[i]);<br>           &#125;<br>           <span class="hljs-comment">// 将每组间隔为h的分组进行排序，刚开始h=数组长度的一半</span><br>           <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> h = numlist.Length/<span class="hljs-number">2</span>; h &gt;<span class="hljs-number">0</span>; h/=<span class="hljs-number">2</span>)<br>           &#123;<br>               <span class="hljs-comment">//对每组进行插入排序</span><br>               <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = h; i &lt; numlist.Length; i++)<br>               &#123;<br>                   <span class="hljs-comment">// 将numlist[i]插入到所在分组的正确位置上</span><br>                   insertI(numlist, h, i);<br>               &#125;<br>           &#125;<br>           Console.WriteLine(<span class="hljs-string">&quot;\r\n排序后结果:&quot;</span>);<br>           <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; numlist.Length; i++)<br>           &#123;<br>               Console.Write(<span class="hljs-string">&quot; &quot;</span>+numlist[i]);<br>           &#125;<br>           Console.ReadLine();<br>       &#125;<br>       <span class="hljs-comment">// 插入排序的方法</span><br>       <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertI</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] arr,<span class="hljs-built_in">int</span> h, <span class="hljs-built_in">int</span> i</span>)</span><br>       &#123;<br>           <span class="hljs-built_in">int</span> temp = arr[i];<br>           <span class="hljs-built_in">int</span> k;<br>           <span class="hljs-keyword">for</span> ( k= i-h; k&gt;=<span class="hljs-number">0</span> &amp;&amp; temp&lt;arr[k]; k-=h)<br>           &#123;<br>               arr[k + h] = arr[k];<br>           &#125;<br>           arr[k + h] = temp;<br>       &#125;<br></code></pre></td></tr></table></figure>


<p>​	</p>
<p>程序执行结果：</p>
<p><img src="https://img-blog.csdnimg.cn/2b6aaaf6b5914b2eb6efa5e559c18840.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h4 id="6-堆排序"><a href="#6-堆排序" class="headerlink" title="6.堆排序"></a>6.堆排序</h4><p>堆排序首先是构建最大堆或最小堆。最大堆是用来正序排序，最小堆是用来倒序排序。</p>
<p>最大堆是指二叉树中每个结点的值都比其左右子结点的值大。同理最小堆是指二叉树中每个结点的值都比其左右子结点的值小。</p>
<p>对于二叉树不了解，在这里可以只有一个印象就可以。二叉树就是一个结点最多只有两个左右子结点。至于什么是完全二叉树，这里就不在过多解释，以后有机会写数据结构的时候，会着重解释，但是有一点要知道，数列从上往下，从左往右，按照只有一个根结点，且每个结点有两个子结点这样构建二叉树，那么他就是一颗完全二叉树。</p>
<p>下面我用一张图，来表示上面的概念，并加深印象。</p>
<p><img src="https://img-blog.csdnimg.cn/e33fa55d2e98407ea12bbc0b99221487.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p>完全二叉树：<br>可以发现其实每个结点的下标和其左右子结点的下标是有一定关系的，即结点下标为n，左子结点下标为：2n+1，右子结点的下标为：2n+2。</p>
<p>最大堆：</p>
<p><img src="https://img-blog.csdnimg.cn/8f1362ccb2a043d98977410ba95406e2.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p>上图为第一次构建最大堆的结果</p>
<p>可以看出因为根结点要比左右子结点数值大，而且其左右子结点要比其孙子结点数值大，以此类推，此时的根结点即为数列的最大值。</p>
<p>那么我们如何把一个无序构建成一个最大堆。首先看最大堆的最大特点就是：父结点的数值一定比左右结点数值大，我们依照这个规则不断的调整结点使其满足条件即可。</p>
<p>再仔细观察堆我们发现，由一半以上的结点是没有孩子结点的，这部分结点就称为叶子结点，那么也就是说，这部分结点是不需要向下调整的。我们选择从(length&#x2F;2)-1的下标开始依次从0下标的方向进行调整。每次调整之后，调整的结点还要继续比较他的子结点看看是否仍然满足最大堆特点，一直调整到叶子结点。这样做的目的就是使数列的大值向上浮，小值向下沉。直到下标0结点（根结点）调整完成，此时就是一个最大堆。</p>
<p>此时根结点是一个最大值，我们把最大值排在无序数列最后，即把最大值与队尾交换位置。此时我们发现除了根结点，其他结点仍然是符合最大堆特点的（注意，从这个位置往后，我们讲述的情况都是排除了最后一个数，因为他已经排好了位置）。这时我们只用调整根结点就可以了，调整之后，就得到了数列的第二个最大值。依次调整，直到数列排好即可。</p>
<p><img src="https://img-blog.csdnimg.cn/5eaad2f07d4e400daff97217f6b7ab49.gif" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c#"> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HeapSort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] arr</span>)</span><br>&#123;<br>    <span class="hljs-built_in">int</span> length = arr.Length;<br>    <span class="hljs-keyword">if</span> (length &lt; <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//初次构建最大堆。从后往前第一个非叶子结点开始调整。</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = length / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>    &#123;<br>        AdjustHeap(arr, i, length);<br>    &#125;<br><br>    <span class="hljs-comment">//将堆顶最大值移动到数组末端，再次从根结点开始调整构建最大堆。</span><br>    <span class="hljs-comment">//注意长度要-1，因为队尾的元素已经是排好序的。</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; length <span class="hljs-number">-1</span>; i++)<br>    &#123;<br>        Swap(arr, <span class="hljs-number">0</span>, length - <span class="hljs-number">1</span> - i);<br>        AdjustHeap(arr, <span class="hljs-number">0</span>, length - i - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 构建最大堆</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;arr&quot;&gt;</span>需要构建的数组<span class="hljs-doctag">&lt;/param&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;index&quot;&gt;</span>需要开始调整的结点下标<span class="hljs-doctag">&lt;/param&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;length&quot;&gt;</span>需要构建的数组长度<span class="hljs-doctag">&lt;/param&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AdjustHeap</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] arr, <span class="hljs-built_in">int</span> index, <span class="hljs-built_in">int</span> length</span>)</span><br>&#123;<br>    <span class="hljs-built_in">int</span> leftIndex = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;              <span class="hljs-comment">//左孩子结点下标</span><br>    <span class="hljs-built_in">int</span> rightIndex = index * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;             <span class="hljs-comment">//右孩子结点下标</span><br>    <span class="hljs-comment">//如果左孩子下标大于等于数组长，则说明其为叶子结点，不需要调整</span><br>    <span class="hljs-keyword">if</span> (leftIndex &gt;= length)                    <br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//找到左右结点最大值的下标</span><br>    <span class="hljs-built_in">int</span> maxIndex = leftIndex;<br>    <span class="hljs-keyword">if</span> (rightIndex &lt; length)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (arr[leftIndex] &lt; arr[rightIndex])<br>        &#123;<br>            maxIndex = rightIndex;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//如果孩子结点的值要大于父结点，则交换两个结点的值，</span><br>    <span class="hljs-comment">//并且从交换后的子结点继续向下调整</span><br>    <span class="hljs-keyword">if</span> (arr[maxIndex] &gt; arr[index])<br>    &#123;<br>        Swap(arr, maxIndex, index);<br>        AdjustHeap(arr, maxIndex, length);<br>    &#125;<br><br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Swap</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] arr, <span class="hljs-built_in">int</span> index1, <span class="hljs-built_in">int</span> index2</span>)</span><br>&#123;<br>    <span class="hljs-built_in">int</span> length = arr.Length;<br>    <span class="hljs-keyword">if</span> (index1 &gt;= length || index2 &gt;= length)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">int</span> temp = arr[index1];<br>    arr[index1] = arr[index2];<br>    arr[index2] = temp;<br>&#125;<br><br></code></pre></td></tr></table></figure>


<h4 id="7-归并排序"><a href="#7-归并排序" class="headerlink" title="7.归并排序"></a>7.归并排序</h4><p>归并排序是建立在归并操作上的一种有效，稳定的排序算法，该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。 将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。 若将两个有序表合并成一个有序表，称为二路归并。</p>
<p>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p>
<ul>
<li><p>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；</p>
</li>
<li><p>自下而上的迭代；</p>
</li>
</ul>
<p><strong>算法步骤</strong></p>
<ol>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li>
<li>重复步骤 3 直到某一指针达到序列尾；</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/0c66af0a2da0474d94384b06847ba235.gif" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MergeSort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] array1</span>)</span><br>        &#123;<br>            <span class="hljs-built_in">int</span> low = <span class="hljs-number">0</span>, heigh = array1.Length - <span class="hljs-number">1</span>;<br>            Mergesort(array1, low,  heigh);<br>        &#125;<br>           <br>           <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">Mergesort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] array1,<span class="hljs-built_in">int</span> low,<span class="hljs-built_in">int</span> heigh</span>)</span><br>        &#123;<br>            <br>  <br>            <span class="hljs-keyword">if</span> (low &lt; heigh)<br>            &#123;<br>               <span class="hljs-built_in">int</span> mid = (low+heigh) / <span class="hljs-number">2</span>;<br>                Mergesort(array1,low,mid);<br>                Mergesort(array1, mid + <span class="hljs-number">1</span>, heigh);<br>                BinaryMerge(array1,low,mid,heigh);<br>            &#125;<br>           <br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BinaryMerge</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] array, <span class="hljs-built_in">int</span> low,<span class="hljs-built_in">int</span> mid,<span class="hljs-built_in">int</span> height</span>)</span><br>        &#123;<br>            <span class="hljs-built_in">int</span>[] temparray = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[array.Length];<br>            <span class="hljs-built_in">int</span> left, right,index;<br>            <span class="hljs-comment">//复制数组</span><br>            <span class="hljs-keyword">for</span> (index = low; index &lt;= height; index++)<br>            &#123;<br>                temparray[index] = array[index];<br>            &#125;<br>          <br>            <span class="hljs-comment">//二路归并</span><br>            <span class="hljs-keyword">for</span> ( index= left = low,right=mid+<span class="hljs-number">1</span>;left&lt;=mid&amp;&amp; right &lt;= height &amp;&amp; index &lt;=height; index++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (temparray[left] &lt;= temparray[right]) &#123; array[index] = temparray[left++]; &#125;<br>                <span class="hljs-keyword">else</span> &#123; array[index] = temparray[right++]; &#125;<br>            &#125;<br>            <span class="hljs-comment">//检查那个部分没拷贝完成，将temparray剩余的部分拷贝到array数组中</span><br>            <span class="hljs-keyword">while</span> (left&lt;=mid) array[index++] = temparray[left++];<br>            <span class="hljs-keyword">while</span>(right&lt;=height) array[index++]=temparray[right++];<br>        &#125;<br>      <br></code></pre></td></tr></table></figure>

<h4 id="8-计数排序"><a href="#8-计数排序" class="headerlink" title="8.计数排序"></a>8.计数排序</h4><p><img src="https://img-blog.csdnimg.cn/9fbfeab31f384aad9329a49fe345f678.gif" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p>计数排序是一种适合于最大值和最小值的差值不是不是很大的排序。例如 temp[i] &#x3D; m, 表示元素 i 一共出现了 m 次</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CountSort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] arr</span>)</span><br> &#123;<br>     <span class="hljs-comment">//1.得到数列的最大值 和 最小值</span><br>     <span class="hljs-built_in">int</span> Max = arr[<span class="hljs-number">0</span>];<br>     <span class="hljs-built_in">int</span> Min = arr[<span class="hljs-number">0</span>];<br> <br>     <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; arr.Length; i++)<br>     &#123;<br>         <span class="hljs-keyword">if</span> (arr[i] &gt; Max) Max = arr[i];<br>         <span class="hljs-keyword">if</span> (arr[i] &lt; Min) Min = arr[i];<br>     &#125;<br>     <span class="hljs-comment">//2.根据数列最大值确定统计数组的长度</span><br>     <span class="hljs-built_in">int</span>[] newArr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[Max -Min+ <span class="hljs-number">1</span>];<br>     <span class="hljs-comment">//3.遍历数列，填充统计数组 记得加上 偏移量Min</span><br>     <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.Length; i++)<br>     &#123;<br>         newArr[arr[i]-Min]++;<br>     &#125;<br>     <span class="hljs-comment">//4.遍历统计数组，输出结果 记得加上 偏移量Min</span><br>     <span class="hljs-built_in">int</span> Index = <span class="hljs-number">0</span>;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; newArr.Length; i++)<br>     &#123;<br>         <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; newArr[i]; j++)<br>         &#123;<br>             arr[Index++] = i+Min;<br>         &#125;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure>

<h4 id="9-桶排序"><a href="#9-桶排序" class="headerlink" title="9.桶排序"></a>9.桶排序</h4><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p>
<p><strong>算法步骤</strong></p>
<ol>
<li>设置一个定量的数组当作空桶；</li>
<li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li>
<li>对每个不是空的桶进行排序；</li>
<li>从不是空的桶里把排好序的数据拼接起来。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/b7e8e42333e1432bb1a494d301c1c41e.gif" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 桶排序</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span> &#123;<br>        <span class="hljs-built_in">double</span>[] array = &#123; <span class="hljs-number">0.43</span>, <span class="hljs-number">0.69</span>, <span class="hljs-number">0.11</span>, <span class="hljs-number">0.72</span>, <span class="hljs-number">0.28</span>, <span class="hljs-number">0.21</span>, <span class="hljs-number">0.56</span>, <span class="hljs-number">0.80</span>, <span class="hljs-number">0.48</span>, <span class="hljs-number">0.94</span>, <span class="hljs-number">0.32</span>, <span class="hljs-number">0.08</span> &#125;;<br><br>        BucketSort(array, <span class="hljs-number">10</span>);<br>        ShowSord(array);<br><br>        Console.ReadKey();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ShowSord</span>(<span class="hljs-params"><span class="hljs-built_in">double</span>[] array</span>)</span> &#123;<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> num <span class="hljs-keyword">in</span> array) &#123;<br>            Console.Write(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;num&#125;</span> &quot;</span>);<br>        &#125;<br>        Console.WriteLine();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BucketSort</span>(<span class="hljs-params"><span class="hljs-built_in">double</span>[] array, <span class="hljs-built_in">int</span> bucketNum</span>)</span> &#123;<br>        <span class="hljs-comment">//创建bucket时，在二维中增加一组标识位，其中bucket[x, 0]表示这一维所包含的数字的个数</span><br>        <span class="hljs-comment">//通过这样的技巧可以少写很多代码</span><br>        <span class="hljs-built_in">double</span>[,] bucket = <span class="hljs-keyword">new</span> <span class="hljs-built_in">double</span>[bucketNum, array.Length + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> num <span class="hljs-keyword">in</span> array) &#123;<br>            <span class="hljs-built_in">int</span> bit = (<span class="hljs-built_in">int</span>)(<span class="hljs-number">10</span> * num);<br>            bucket[bit, (<span class="hljs-built_in">int</span>)++bucket[bit, <span class="hljs-number">0</span>]] = num;<br>        &#125;<br>        <span class="hljs-comment">//为桶里的每一行使用插入排序</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; bucketNum; j++) &#123;<br>            <span class="hljs-comment">//为桶里的行创建新的数组后使用插入排序</span><br>            <span class="hljs-built_in">double</span>[] insertion = <span class="hljs-keyword">new</span> <span class="hljs-built_in">double</span>[(<span class="hljs-built_in">int</span>)bucket[j, <span class="hljs-number">0</span>]];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> k = <span class="hljs-number">0</span>; k &lt; insertion.Length; k++) &#123;<br>                insertion[k] = bucket[j, k + <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-comment">//插入排序</span><br>            StraightInsertionSort(insertion);<br>            <span class="hljs-comment">//把排好序的结果回写到桶里</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> k = <span class="hljs-number">0</span>; k &lt; insertion.Length; k++) &#123;<br>                bucket[j, k + <span class="hljs-number">1</span>] = insertion[k];<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//将所有桶里的数据回写到原数组中</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> count = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; j &lt; bucketNum; j++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> k = <span class="hljs-number">1</span>; k &lt;= bucket[j, <span class="hljs-number">0</span>]; k++) &#123;<br>                array[count++] = bucket[j, k];<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">StraightInsertionSort</span>(<span class="hljs-params"><span class="hljs-built_in">double</span>[] array</span>)</span> &#123;<br>        <span class="hljs-comment">//插入排序</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; array.Length; i++) &#123;<br>            <span class="hljs-built_in">double</span> sentinel = array[i];<br>            <span class="hljs-built_in">int</span> j = i - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; sentinel &lt; array[j]) &#123;<br>                array[j + <span class="hljs-number">1</span>] = array[j];<br>                j--;<br>            &#125;<br>            array[j + <span class="hljs-number">1</span>] = sentinel;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>


<h4 id="10-基数排序"><a href="#10-基数排序" class="headerlink" title="10.基数排序"></a>10.基数排序</h4><p>基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数；</p>
<p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</p>
<p>基数相对于其他排序，算法逻辑和代码都相对简单。<br>代码方面，也都是和另外两个排序的顺序一致。<br>与另外两个非比较排序不同的是：<br>计数排序和桶排序是基于数组索引来的，所以只能排序整数<br>但是基于数的计数而定，所以在改造后，理论上是也可以排序非整数</p>
<p><strong>算法步骤</strong></p>
<ol>
<li><p>求最值，取得数组中的最大数，并取得位数；</p>
</li>
<li><p>初新组，此处新组是指新桶，桶大小为10(因为基数只有0-10)；</p>
</li>
<li><p>正填充，将对应基数的数字放到对应的桶中</p>
</li>
<li><p>将桶中的数据反填充到array数组中</p>
</li>
</ol>
<blockquote>
<p>注：正反填充需要进行循环，循环次数为步骤一的位数 </p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/de00f05f30634bf3aa413803b3f35d4b.gif" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span>[] <span class="hljs-title">RadixSort2</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] array</span>)</span><br>&#123;<br>    <span class="hljs-comment">//求最(大)值</span><br>    <span class="hljs-built_in">int</span> max = array[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> array)<br>    &#123;<br>        max = item &gt; max ? item : max;<br>    &#125;<br><br>    <span class="hljs-built_in">int</span> maxDigit = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(max!=<span class="hljs-number">0</span>)<br>    &#123;<br>        max /= <span class="hljs-number">10</span>;maxDigit++;<br>    &#125;<br>    <span class="hljs-comment">//初新桶</span><br>    <span class="hljs-keyword">var</span> bucket = <span class="hljs-keyword">new</span> List&lt;List&lt;<span class="hljs-built_in">int</span>&gt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        bucket.Add(<span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;());<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; maxDigit; i++)<br>    &#123;<br>        <span class="hljs-comment">//正填充</span><br>        <span class="hljs-built_in">int</span> div = (<span class="hljs-built_in">int</span>)Math.Pow(<span class="hljs-number">10</span>, (i + <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> array)<br>        &#123;<br>            <span class="hljs-comment">//获取基数</span><br>            <span class="hljs-built_in">int</span> radix = (item % div) / (div / <span class="hljs-number">10</span>);<br>            bucket[radix].Add(item);<br>        &#125;<br>        <span class="hljs-comment">//反填充（//反填充要注意顺序）</span><br>        <span class="hljs-built_in">int</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> bucket)<br>        &#123;<br>            <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> it <span class="hljs-keyword">in</span> item)<br>            &#123;<br>                array[index++] = it;                        <br>            &#125;<br>            item.Clear();<span class="hljs-comment">//清除数据</span><br>        &#125;                <br>    &#125;<br>    <span class="hljs-keyword">return</span> array;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/49a4114d2323450792d15706511acdf4.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/842750f7516f4a62aa62e32a07190c1d.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a target="_blank" rel="noopener" href="https://raindust.blog.csdn.net/article/details/104127820">C#十大排序算法</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/weiios/p/3933994.html">C#快速排序详解</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e4d0990dd0bd">排序算法2|简单选择排序与堆排序（C#）</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/cdaniu/p/16370507.html">【C# 排序】归并排序 merge sort</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/liuyi89430/article/details/107612559">C#计数排序</a><br><a target="_blank" rel="noopener" href="https://bbs.huaweicloud.com/blogs/313568">【愚公系列】2021年11月 C#版 数据结构与算法解析(桶排序)</a><br><a target="_blank" rel="noopener" href="https://www.freesion.com/article/96281055419/">C# 算法之基数排序排序(非比较排序之三)</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E9%9D%A2%E8%AF%95/" class="category-chain-item">面试</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Unity/">#Unity</a>
      
        <a href="/tags/C/">#C#</a>
      
        <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">#计算机网络</a>
      
        <a href="/tags/Lua/">#Lua</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Unity 客户端面试</div>
      <div>http://bmtan.cc/2023/02/01/Unity客户端面试/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Bmtan</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年2月1日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/07/30/AssetBundle%20%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD/" title="AssetBundle包 同步异步加载">
                        <span class="hidden-mobile">AssetBundle包 同步异步加载</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
