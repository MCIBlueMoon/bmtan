

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Bmtan">
  <meta name="keywords" content="">
  
    <meta name="description" content="面试🌙UnityDrawCall问题 什么是DrawCall?   DrawCall 是 Cpu准备好渲染的数据后告知GPU渲染的命令   DrawCall过高影响什么性能？   会造成很多额外的性能开销，且CPU会把大量时间花费再Draw Call 上，造成CPU过载。   如何降低DrawCall   小图合成大图，即多个小DrawCall变一次大DrawCall  拼面板时严格控制不同图集">
<meta property="og:type" content="article">
<meta property="og:title" content="Unity 客户端面试">
<meta property="og:url" content="http://bmtan.cc/2023/02/01/Unity%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%9D%A2%E8%AF%95/index.html">
<meta property="og:site_name" content="Bmtan">
<meta property="og:description" content="面试🌙UnityDrawCall问题 什么是DrawCall?   DrawCall 是 Cpu准备好渲染的数据后告知GPU渲染的命令   DrawCall过高影响什么性能？   会造成很多额外的性能开销，且CPU会把大量时间花费再Draw Call 上，造成CPU过载。   如何降低DrawCall   小图合成大图，即多个小DrawCall变一次大DrawCall  拼面板时严格控制不同图集">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201202110747790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xMTExMX18=,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201201161048150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xMTExMX18=,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230201222507758.png">
<meta property="og:image" content="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230201222538994.png">
<meta property="og:image" content="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/DrawCallProblem1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/DrawCallProblem2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/AwakeOrder.png">
<meta property="og:image" content="https://pic2.zhimg.com/v2-35da80e428ca5750491ffd2770e187e1_b.webp">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-6a4e77fe8ead57f7384a1491d1c73ab0_720w.webp">
<meta property="og:image" content="https://pic1.zhimg.com/v2-5480232b0c74e8d236044529bd170834_b.webp">
<meta property="og:image" content="https://img-blog.csdn.net/20170311165114162?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQW5kcmV3RmFu/font/5a6L5L2T/fontsize/200/fill/I0JBQkFCMA==/dissolve/70/gravity/NorthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170311165659086?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQW5kcmV3RmFu/font/5a6L5L2T/fontsize/200/fill/I0JBQkFCMA==/dissolve/70/gravity/NorthEast">
<meta property="og:image" content="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230201221201268.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/b99d714ae81d4ed08afb9a933e5df2ea.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/cdda4b5f61374524bf3082080d30c4fb.png">
<meta property="og:image" content="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/addressProblem.png">
<meta property="og:image" content="https://img-blog.csdn.net/20160528132344296">
<meta property="og:image" content="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ListProblem.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210530224055792.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzeTc3Nzc3Nw==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210530224106137.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzeTc3Nzc3Nw==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/V2QJXN%25LGY17_GWQIJ%24%7D1W1.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/1daa0def8e454f61836f28a8d1cb2e0b.gif">
<meta property="og:image" content="https://img-blog.csdnimg.cn/15b1cfff79a049f0bef2dc98617d8d8d.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/d7de02f14c6c45f7ad9e75888ed6254b.gif">
<meta property="og:image" content="https://img-blog.csdnimg.cn/15b1cfff79a049f0bef2dc98617d8d8d.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/b72900449cb44c15999f8d89c286bb69.gif">
<meta property="og:image" content="https://img-blog.csdnimg.cn/5ca6790d2c4740ba86e8b956475dd2bd.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/5ff1f36a0e694cbc9ffd5f2e6089a821.gif">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2b6aaaf6b5914b2eb6efa5e559c18840.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/e33fa55d2e98407ea12bbc0b99221487.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/8f1362ccb2a043d98977410ba95406e2.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/5eaad2f07d4e400daff97217f6b7ab49.gif">
<meta property="og:image" content="https://img-blog.csdnimg.cn/0c66af0a2da0474d94384b06847ba235.gif">
<meta property="og:image" content="https://img-blog.csdnimg.cn/9fbfeab31f384aad9329a49fe345f678.gif">
<meta property="og:image" content="https://img-blog.csdnimg.cn/b7e8e42333e1432bb1a494d301c1c41e.gif">
<meta property="og:image" content="https://img-blog.csdnimg.cn/de00f05f30634bf3aa413803b3f35d4b.gif">
<meta property="og:image" content="https://img-blog.csdnimg.cn/49a4114d2323450792d15706511acdf4.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/842750f7516f4a62aa62e32a07190c1d.png">
<meta property="article:published_time" content="2023-02-01T14:44:00.000Z">
<meta property="article:modified_time" content="2023-02-03T09:54:00.655Z">
<meta property="article:author" content="Bmtan">
<meta property="article:tag" content="Unity">
<meta property="article:tag" content="C#">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="Lua">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20201202110747790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xMTExMX18=,size_16,color_FFFFFF,t_70">
  
  
  
  <title>Unity 客户端面试 - Bmtan</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"bmtan.cc","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Bmtan blog&#39;s</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Unity 客户端面试"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-02-01 22:44" pubdate>
          2023年2月1日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          26k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          219 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Unity 客户端面试</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h1><h2 id="🌙Unity"><a href="#🌙Unity" class="headerlink" title="🌙Unity"></a>🌙Unity</h2><h3 id="DrawCall问题"><a href="#DrawCall问题" class="headerlink" title="DrawCall问题"></a>DrawCall问题</h3><blockquote>
<p>什么是DrawCall?</p>
</blockquote>
<ul>
<li>DrawCall 是 Cpu准备好渲染的数据后告知GPU渲染的命令</li>
</ul>
<blockquote>
<p>DrawCall过高影响什么性能？</p>
</blockquote>
<ul>
<li>会造成很多额外的性能开销，且CPU会把大量时间花费再Draw Call 上，造成CPU过载。</li>
</ul>
<blockquote>
<p>如何降低DrawCall</p>
</blockquote>
<ol>
<li><p>小图合成大图，即多个小DrawCall变一次大DrawCall</p>
</li>
<li><p>拼面板时严格控制不同图集层级处理</p>
</li>
<li><p>静态批处理</p>
</li>
<li><p>动态批处理</p>
</li>
</ol>
<blockquote>
<p>静态批处理</p>
</blockquote>
<ul>
<li><p><img src="https://img-blog.csdnimg.cn/20201202110747790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xMTExMX18=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="img"></p>
<p> 只要勾选上Static并拥有相同材质的物体即可在运行时进行静态批处理<br> <strong>但是静态批处理会为每一个物体创建一个合并后的Combined Mesh，需要额外的内存空间来存储合并后的Combined Mesh，所以使用时要慎用(例如一片浓密的草地，如果使用静态批处理则会造成严重的内存开销)</strong></p>
</li>
</ul>
<blockquote>
<p>动态批处理 </p>
</blockquote>
<ul>
<li><p><img src="https://img-blog.csdnimg.cn/20201201161048150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xMTExMX18=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="img"></p>
<p> 动态批处理默认是关闭的，需要手动开启：Project Setting—Player—勾上Dynamic Batching（动态批处理）</p>
</li>
</ul>
<p><font color = "red"><b>总结</b></font></p>
<p><font color = "red"><b>——静态批处理和动态批处理都能降低DrawCall，最主要的前提是物体使用同一个材质</b></font><br><font color = "red"><b>——静态批处理适用于场景中位置不会改变并且单对象不能太多的物体，像树林，草地这种用动态批处理更适合</b></font><br><font color = "red"><b>——动态批处理限制较多，顶点数要求，材质要求等等。静态批处理限制较少，是用内存换性能的方法，具体情况具体分析</b></font></p>
<h3 id="请简述一下Prefab（预制体）的本质是什么？"><a href="#请简述一下Prefab（预制体）的本质是什么？" class="headerlink" title="请简述一下Prefab（预制体）的本质是什么？"></a>请简述一下Prefab（预制体）的本质是什么？</h3><p>Prefab的本质就是一个配置文件<br>其中记录了一个GameObject对象上挂载的脚本信息<br>并且记录了脚本信息中的可配置的属性信息</p>
<h3 id="Unity是否支持写成多线程程序？如果支持的话需要注意什么？"><a href="#Unity是否支持写成多线程程序？如果支持的话需要注意什么？" class="headerlink" title="Unity是否支持写成多线程程序？如果支持的话需要注意什么？"></a>Unity是否支持写成多线程程序？如果支持的话需要注意什么？</h3><p>1.只能从主线程访问Unity相关组件、对象以及<br>UnityEngine命名空间中的绝大部分内容<br>2.如果多线程中要和Unity主线程同时修改一些数据<br>可以通过lock关键词加锁</p>
<h3 id="请简述一下对象池，在游戏开发中我们什么时候会用到它？"><a href="#请简述一下对象池，在游戏开发中我们什么时候会用到它？" class="headerlink" title="请简述一下对象池，在游戏开发中我们什么时候会用到它？"></a>请简述一下对象池，在游戏开发中我们什么时候会用到它？</h3><ol>
<li><p>对象池的主要作用是 <strong>避免大量创建对象再释放对象时造成的内存消耗，可以有效降低GC发生的频率</strong>。我们把不用的对象放入对象池中而不是让它直接变为垃圾，下次需要用到对象时再从对象池中获取，我们通过占用内存来避免更多的内存消耗和GC的发生</p>
</li>
<li><p>在游戏中频繁创建对象、实例化对象的地方，都可以用到对象池。<br>比如前端开发中，游戏中的子弹、伤害字体、特效等等<br>比如后端开发中线程池等等</p>
</li>
</ol>
<h3 id="Unity中点乘和叉乘对于我们来说的作用是什么？"><a href="#Unity中点乘和叉乘对于我们来说的作用是什么？" class="headerlink" title="Unity中点乘和叉乘对于我们来说的作用是什么？"></a>Unity中点乘和叉乘对于我们来说的作用是什么？</h3><p><strong>点乘作用</strong></p>
<ol>
<li><p>判断对象的方位</p>
</li>
<li><p>计算两向量之间的夹角</p>
</li>
</ol>
<p><strong>叉乘作用</strong></p>
<ol>
<li><p>获取一个平面的法向量</p>
</li>
<li><p>得到两向量之间的左右位置关系</p>
</li>
</ol>
<h3 id="Application-streamingAssetsPath-和-Application-persistentDataPath两个路径有何区别？对于我们的意义是什么？"><a href="#Application-streamingAssetsPath-和-Application-persistentDataPath两个路径有何区别？对于我们的意义是什么？" class="headerlink" title="Application.streamingAssetsPath 和 Application.persistentDataPath两个路径有何区别？对于我们的意义是什么？"></a>Application.streamingAssetsPath 和 Application.persistentDataPath两个路径有何区别？对于我们的意义是什么？</h3><p>Application.streamingAssetsPath   只读<br>Application.persistentDataPath      可读可写</p>
<p>Application.streamingAssetsPath   适合放置一些默认2进制配置文件<br>Application.persistentDataPath      用于处理数据持久化，或作为热更新下载内容的存放目录，因为它可读可写</p>
<h3 id="请简述Unity中协程的原理"><a href="#请简述Unity中协程的原理" class="headerlink" title="请简述Unity中协程的原理"></a>请简述Unity中协程的原理</h3><p>Unity中的协同程序分为<strong>两部分</strong></p>
<ol>
<li>协程函数本体（<strong>迭代器函数</strong>）</li>
<li>协程调度器（<strong>协程管理器</strong>）</li>
</ol>
<p>协程利用迭代器函数的分步执行的特点<br>加上<br>协程调度器对迭代器函数们进行统一管理<br>根据迭代器函数的返回值来决定下一次执行函数逻辑的时间点<br>从而实现逻辑分时分步执行的目的</p>
<h3 id="Unity中当一个细小高速物体撞击另一个较大物体时会出现什么情况？如何避免？"><a href="#Unity中当一个细小高速物体撞击另一个较大物体时会出现什么情况？如何避免？" class="headerlink" title="Unity中当一个细小高速物体撞击另一个较大物体时会出现什么情况？如何避免？"></a>Unity中当一个细小高速物体撞击另一个较大物体时会出现什么情况？如何避免？</h3><ol>
<li>我们可以尽量用射线检测来替代细小物体的物理系统碰撞<br>因为传统的FPS游戏都是通过射线检测加模拟计算来判断伤害的</li>
<li>修改Rigidbody刚体中的<strong>Interpolate（插值）</strong>和<strong>CollisionDetection（碰撞检测）</strong>两个参数，来提高碰撞检测的准确性</li>
</ol>
<table>
<thead>
<tr>
<th><strong>Interpolate</strong></th>
<th>仅当在刚体运动中看到急动时才尝试使用提供的选项之一。</th>
</tr>
</thead>
<tbody><tr>
<td>- <strong>None</strong></td>
<td>不应用插值。</td>
</tr>
<tr>
<td>- <strong>Interpolate</strong></td>
<td>根据前一帧的变换来平滑变换。</td>
</tr>
<tr>
<td>- <strong>Extrapolate</strong></td>
<td>根据下一帧的估计变换来平滑变换。</td>
</tr>
<tr>
<td><strong>Collision Detection</strong></td>
<td>用于防止快速移动的对象穿过其他对象而不检测碰撞。</td>
</tr>
<tr>
<td>- <strong>Discrete</strong></td>
<td>对场景中的所有其他碰撞体使用离散碰撞检测。其他碰撞体在测试碰撞时会使用离散碰撞检测。用于正常碰撞（这是默认值）。</td>
</tr>
<tr>
<td>- <strong>Continuous</strong></td>
<td>对动态碰撞体（具有刚体）使用离散碰撞检测，并对静态碰撞体（没有刚体）使用基于扫掠的连续碰撞检测。设置为__连续动态 (Continuous Dynamic)__ 的刚体将在测试与该刚体的碰撞时使用连续碰撞检测。其他刚体将使用离散碰撞检测。用于__连续动态 (Continuous Dynamic)__ 检测需要碰撞的对象。（此属性对物理性能有很大影响，如果没有快速对象的碰撞问题，请将其保留为 <strong>Discrete</strong> 设置）</td>
</tr>
<tr>
<td>- <strong>Continuous Dynamic</strong></td>
<td>对设置为__连续 (Continuous)__ 和__连续动态 (Continuous Dynamic)__ 碰撞的游戏对象使用基于扫掠的连续碰撞检测。还将对静态碰撞体（没有刚体）使用连续碰撞检测。对于所有其他碰撞体，使用离散碰撞检测。用于快速移动的对象。</td>
</tr>
<tr>
<td>- <strong>Continuous Speculative</strong></td>
<td>对刚体和碰撞体使用推测性连续碰撞检测。这也是可以设置运动物体的唯一 CCD 模式。该方法通常比基于扫掠的连续碰撞检测的成本更低。</td>
</tr>
</tbody></table>
<h3 id="Unity底层如何处理C-代码？"><a href="#Unity底层如何处理C-代码？" class="headerlink" title="Unity底层如何处理C#代码？"></a>Unity底层如何处理C#代码？</h3><p>两种方案<br><font color = "red"><b>Mono和IL2CPP</b></font></p>
<blockquote>
<p>Mono</p>
</blockquote>
<p>C#代码——&gt;Mono C#编译器——&gt;IL中间代码——&gt; <font color = "red"><b>Mono VM——&gt;操作系统的原生代码</b></font></p>
<p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230201222507758.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>IL2CPP</p>
</blockquote>
<p>C#代码——&gt;Mono C#编译器——&gt;IL中间代码——&gt;<font color = "red"><b>IL2CPP——&gt;C++——&gt;C++编译器——&gt;原生汇编代码——&gt;IL2CPP VM</b></font></p>
<p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230201222538994.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>两者区别</p>
</blockquote>
<p><font color = "red"><b>IL2CPP效率高于Mono，跨平台也更好维护</b></font></p>
<p><font color = "red"><b>Mono是JIT即时编译，IL2CPP是AOT提前编译</b></font></p>
<p>建议使用效率更高的<strong>IL2CPP</strong></p>
<h3 id="Unity使用IL2CPP打包时，我们应该注意什么？如何避免（可以举例说明）"><a href="#Unity使用IL2CPP打包时，我们应该注意什么？如何避免（可以举例说明）" class="headerlink" title="Unity使用IL2CPP打包时，我们应该注意什么？如何避免（可以举例说明）"></a>Unity使用IL2CPP打包时，我们应该注意什么？如何避免（可以举例说明）</h3><p>使用IL2CPP打包时，<b>最可能出现的问题就是<font color = "red">代码裁剪</font></b>，IL2CPP会自动将它认为不会使用的代码裁剪掉，比如我们在使用Lua开发时，其实会用到很多UnityEngine或者我们自己写的C#代码，但是这些代码并不会在引擎中直接使用，都是在Lua中使用的，此时最容易出现的问题就是代码裁剪，导致打包后出现异常和报错。</p>
<p>要<strong>避免IL2CPP的裁剪有3种方式</strong>，我们可以组合使用</p>
<ol>
<li><strong>设置打包时的裁剪等级</strong></li>
<li><strong>通过xml文件配置明确规定哪些内容不裁剪</strong></li>
<li><strong>在静态方法中显示调用不想被裁剪的内容</strong></li>
</ol>
<h3 id="transform-forward和Vector3-forword的区别"><a href="#transform-forward和Vector3-forword的区别" class="headerlink" title="transform.forward和Vector3.forword的区别"></a>transform.forward和Vector3.forword的区别</h3><p>Vector3.forword始终时(0,0,1)<br>可以认为是世界坐标系的Z轴朝向</p>
<p>transform.forword是当前物体的局部坐标系的Z轴在世界坐标系下的朝向<br>可以认为是物体自己的Z轴朝向</p>
<h3 id="Unity中如何解决过多创建和删除对象带来的卡顿问题？"><a href="#Unity中如何解决过多创建和删除对象带来的卡顿问题？" class="headerlink" title="Unity中如何解决过多创建和删除对象带来的卡顿问题？"></a>Unity中如何解决过多创建和删除对象带来的卡顿问题？</h3><p>可以通过协同程序，分时分步创建或删除<br>原理是避免一帧中处理太多对象</p>
<h3 id="我们应该如何优化UI（基于UGUI）"><a href="#我们应该如何优化UI（基于UGUI）" class="headerlink" title="我们应该如何优化UI（基于UGUI）"></a>我们应该如何优化UI（基于UGUI）</h3><p><strong>性能上</strong></p>
<ol>
<li>打图集，将同一画面的图片放入一个图集中，目的是减少DrawCall</li>
<li>面板中的图片和文字尽量不要交叉，因为这样会产生多余的DrawCall</li>
<li>取消勾选在UI组件上的不必要的射线检测</li>
<li>减少透明图片的重叠使用<br>等等</li>
</ol>
<p><strong>内存上</strong></p>
<ol>
<li>大图尽量使用9宫格缩放，让美术设计UI面板底图时不要过于复杂<br>尽量是有规律的纹理和颜色变化</li>
<li>图片的RGBA通道分离<br>等等</li>
</ol>
<h3 id="第一次执行GameObject-Instantiate时可能出现明显的卡顿，如何解决该问题？"><a href="#第一次执行GameObject-Instantiate时可能出现明显的卡顿，如何解决该问题？" class="headerlink" title="第一次执行GameObject.Instantiate时可能出现明显的卡顿，如何解决该问题？"></a>第一次执行GameObject.Instantiate时可能出现明显的卡顿，如何解决该问题？</h3><p>我们可以通过<strong>Unity自带的性能分析工具Profiler分析</strong>实例化时造成卡顿的原因<br><strong>程序上</strong>，一般我们可以从以下3个方面去优化它</p>
<ol>
<li><p><strong>相关资源加载：</strong>如果是由于资源加载带来的卡顿，我们可以在进入场景时进行资源预加载，总体思路就是<strong>将较大资源提前或者分帧加载</strong></p>
</li>
<li><p><strong>脚本初始化：</strong>实例化对象时，会同步执行它身上挂载所有脚本的初始化工作，我们可以策略性的<strong>改变一些初始化逻辑，尽量不要再Awake和Start中做较复杂的逻辑，或者将复杂逻辑提前或者分帧处理</strong></p>
</li>
<li><p>对于会频繁使用的对象，我们可以<strong>使用缓存池</strong></p>
</li>
</ol>
<p><strong>美术上</strong><br>不能只追求好的美术效果，而不考虑资源的消耗，要根据项目的实际情况，来设定模型的骨骼数、面数以及贴图的数量和大小上限。<br>在制作粒子特效时，粒子数、粒子面积、贴图等都要尽量少和小。<br>美术上要遵循：用最少的资源做出做好的效果，不能一味的用性能去换效果，最终会得不偿失</p>
<h3 id="DrawCall渲染问题"><a href="#DrawCall渲染问题" class="headerlink" title="DrawCall渲染问题"></a>DrawCall渲染问题</h3><blockquote>
<p>图中的小球是否被渲染了？是否会产生DrawCall？</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/DrawCallProblem1.png" srcset="/img/loading.gif" lazyload></p>
<p>不会被渲染，不会产生DrawCall</p>
<p>Unity本身有摄像机视锥体剔除，也就是不会显示完全位于视锥体之外的游戏对象<br>那么小球就不会进行渲染，也不会提交数据给GPU，也就不会产生DrawCall</p>
<blockquote>
<p>在没有使用遮挡剔除的情况下，图中A和B都是默认标准材质，图中的小球最终是否会被渲染，是否会产生DrawCall</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/DrawCallProblem2.png" srcset="/img/loading.gif" lazyload></p>
<p>最终不会被渲染，标准材质存在深度测试，小球在立方体后方，不会通过深度测试，所以不会被渲染</p>
<p>会产生DrawCall，既然都深度测试了，那么肯定是存在DrawCall的<br>深度测试发生在片元着色器处理之后，GPU会对每个片元执行深度测试来决定遮挡关系，决定是否被渲染</p>
<h3 id="Unity引擎中哪些功能使用了C-的反射功能？至少说出一点"><a href="#Unity引擎中哪些功能使用了C-的反射功能？至少说出一点" class="headerlink" title="Unity引擎中哪些功能使用了C#的反射功能？至少说出一点"></a>Unity引擎中哪些功能使用了C#的反射功能？至少说出一点</h3><ol>
<li><p>Inspector窗口中显示的内容</p>
</li>
<li><p>预设体文件</p>
</li>
<li><p>场景文件</p>
</li>
<li><p>Unity中的各种特性</p>
<p>等等</p>
</li>
</ol>
<h3 id="Unity中如何调试排查Android上运行的项目问题"><a href="#Unity中如何调试排查Android上运行的项目问题" class="headerlink" title="Unity中如何调试排查Android上运行的项目问题"></a>Unity中如何调试排查Android上运行的项目问题</h3><ol>
<li><p><strong>如果需要进行断点调试</strong><br>通过数据线链接运行项目的Android设备<br>发布时开启了<br>Development Build 开发模式构建<br>Autoconnect Profiler 自动连接分析器<br>Script Debuggins 脚本调试<br>Wait For Managed Debugger 等待托管调试器<br>等选项<br>然后只需要Build and Run既可以<br>利用Unity的Profiler 性能剖析器窗口排查性能问题<br>并且还可以进行断点调试</p>
</li>
<li><p><strong>如果只是获取一些打印调试信息</strong><br>可以利用Unity2019.4及其以上版本提供的Android Logcat工具获取信息<br>Unity2019.4以下的版本，可以使用Android的ADB（安卓调试桥）工具</p>
</li>
<li><p><strong>如果需要获取设备输入信息</strong><br>可以利用Unity Remote来测试移动设备的输入相关逻辑</p>
</li>
</ol>
<h3 id="Unity中Awake和Start两个生命周期函数，分别在什么时候被调用？"><a href="#Unity中Awake和Start两个生命周期函数，分别在什么时候被调用？" class="headerlink" title="Unity中Awake和Start两个生命周期函数，分别在什么时候被调用？"></a>Unity中Awake和Start两个生命周期函数，分别在什么时候被调用？</h3><ul>
<li><strong>Awake：</strong>运行时<ol>
<li>当脚本被动态添加到对象上时立即被调用。</li>
<li>当对象被实例化时，依附它的脚本会立即调用Awake</li>
<li>它类似构造函数</li>
</ol>
</li>
<li><strong>Start：</strong>第一次Update之前被调用</li>
</ul>
<h3 id="Unity场景上有多个对象，都分别挂载了n个脚本。我们如何控制不同脚本间生命周期函数Awake的执行先后顺序？"><a href="#Unity场景上有多个对象，都分别挂载了n个脚本。我们如何控制不同脚本间生命周期函数Awake的执行先后顺序？" class="headerlink" title="Unity场景上有多个对象，都分别挂载了n个脚本。我们如何控制不同脚本间生命周期函数Awake的执行先后顺序？"></a>Unity场景上有多个对象，都分别挂载了n个脚本。我们如何控制不同脚本间生命周期函数Awake的执行先后顺序？</h3><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/AwakeOrder.png" srcset="/img/loading.gif" lazyload></p>
<ol>
<li>可以通过选中脚本文件，点击Inspector窗口右上角的Execution Order（执行顺序）按钮 </li>
<li>可以打开Project Setting窗口，选择Script Execution Order选项</li>
</ol>
<p>通过这两种方式我们可以打开脚本执行顺序窗口<br>在其中我们可以自己设置自定义脚本的执行顺序</p>
<h3 id="想要在Unity中使用指针我们需要进行哪些操作？"><a href="#想要在Unity中使用指针我们需要进行哪些操作？" class="headerlink" title="想要在Unity中使用指针我们需要进行哪些操作？"></a>想要在Unity中使用指针我们需要进行哪些操作？</h3><ol>
<li>需要在PlayerSetting中的OtherSettings中勾选  Allow ‘unsafe’ code 选项</li>
<li>使用指针时必须在unsafe修饰的代码块中</li>
</ol>
<h3 id="Unity中的协同程序中yield-return不同的内容，代表的含义不同"><a href="#Unity中的协同程序中yield-return不同的内容，代表的含义不同" class="headerlink" title="Unity中的协同程序中yield return不同的内容，代表的含义不同"></a>Unity中的协同程序中yield return不同的内容，代表的含义不同</h3><blockquote>
<p>请说明下面这些yield return的含义</p>
</blockquote>
<ol>
<li>yield return 数字;</li>
<li>yield return null;</li>
<li>yield return new WaitForSeconds(数字);</li>
<li>yield return new WaitForFixedUpdate();</li>
<li>yield return new WaitForEndOfFrame();</li>
<li>yield break;</li>
</ol>
<p><strong>答案：</strong></p>
<ol>
<li>yield return 数字; 下一帧执行</li>
<li>yield return null;  下一帧执行</li>
<li>yield return new WaitForSeconds(数字); 等待指定秒后执行</li>
<li>yield return new WaitForFixedUpdate(); 等待下一个固定物理帧更新时执行</li>
<li>yield return new WaitForEndOfFrame(); 等待摄像机和GUI渲染完成后执行</li>
<li>yield break; 跳出协程</li>
</ol>
<h3 id="使用Unity协同程序进行异步加载时，底层是否会使用多线程？"><a href="#使用Unity协同程序进行异步加载时，底层是否会使用多线程？" class="headerlink" title="使用Unity协同程序进行异步加载时，底层是否会使用多线程？"></a>使用Unity协同程序进行异步加载时，底层是否会使用多线程？</h3><p>可能会<br>协同程序的原理是分时分步完成指定逻辑<br>在其中的某一步骤中，是可以使用多线程来完成某些加载操作的，多线程加载完成后，再进入协同程序的下一步继续执行</p>
<h3 id="四元数与旋转和欧拉角与万向节死锁问题"><a href="#四元数与旋转和欧拉角与万向节死锁问题" class="headerlink" title="四元数与旋转和欧拉角与万向节死锁问题"></a>四元数与旋转和欧拉角与万向节死锁问题</h3><blockquote>
<p>两个四元数相乘有什么作用？</p>
</blockquote>
<p>四元数相乘：角度叠加</p>
<blockquote>
<p>四元数乘以向量有什么作用？</p>
</blockquote>
<p>四元数乘以向量：向量旋转</p>
<h4 id="四元数"><a href="#四元数" class="headerlink" title="四元数"></a>四元数</h4><p>简单来说，四元数本质上是一种高阶复数，是一个四维空间，相对于复数的二维空间。我们高中的时候应该都学过复数，一个复数由实部和虚部组成，即x &#x3D; a + bi，i是虚数单位，如果你还记得的话应该知道i^2 &#x3D; -1。而四元数其实和我们学到的这种是类似的，不同的是，它的虚部包含了三个虚数单位，i、j、k，即一个四元数可以表示为x &#x3D; a + bi + cj + dk。‘</p>
<h4 id="欧拉角"><a href="#欧拉角" class="headerlink" title="欧拉角"></a>欧拉角</h4><p>欧拉角用于表示刚体当前的姿态。</p>
<p><strong>思想</strong>：将刚体绕某一轴的一次旋转，分解为依次分别绕X、Y、Z轴的三次旋转。这三个轴分别旋转的转动角度，就是一组三个欧拉角。</p>
<p>图片中即为上述的三次旋转（而其实可以绕某一轴，一次旋转即可达到最终位置）</p>
<p><img src="https://pic2.zhimg.com/v2-35da80e428ca5750491ffd2770e187e1_b.webp" srcset="/img/loading.gif" lazyload alt="动图"></p>
<p>具体旋转过程举例，如图：</p>
<p><img src="https://pic1.zhimg.com/80/v2-6a4e77fe8ead57f7384a1491d1c73ab0_720w.webp" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>图中有两组坐标系，我们定义为：</p>
<ul>
<li>xyz ：世界坐标系（固定不动）</li>
<li>XYZ ：刚体坐标系（与刚体同步运动）</li>
</ul>
<p>具体旋转步骤为：</p>
<ul>
<li>1、绕<strong>世界系</strong>的 z 轴，旋转 α 角。</li>
<li>2、绕<strong>刚体系</strong>的 X 轴，旋转 β 角。</li>
<li>3、绕<strong>刚体系</strong>的 Z 轴，旋转 是 γ 角。</li>
</ul>
<p>下面有一个直观的动图展示。</p>
<p><img src="https://pic1.zhimg.com/v2-5480232b0c74e8d236044529bd170834_b.webp" srcset="/img/loading.gif" lazyload alt="动图"></p>
<p>动图旋转步骤为 z→Y→X ，按照顺序标记为 zYX，加上角度即为一个完整欧拉角：</p>
<p>zYX — （ψ，θ，Φ）</p>
<h4 id="万向节死锁"><a href="#万向节死锁" class="headerlink" title="万向节死锁"></a>万向节死锁</h4><p>万向节死锁发生在欧拉角形式下，是由欧拉旋转定义本身造成的。</p>
<p>这种围绕选旋转前固定轴的先Z、再X、再Y的旋转操作，与其最终所预期的三个轴向可以旋转的结果并非一定是一对一的映射。某些情况下是多对一的映射，造成一些旋转自由度的缺失，也就是“死锁”。</p>
<p><strong>陀螺仪中的万向节死锁</strong></p>
<p>现在看起来，这个陀螺仪一切正常，在船体发生任意方向摇晃都可以通过自身调节来应对。然而，真的是这样吗？</p>
<p>假如，船体发生了剧烈的变化，此时船首仰起了90度，此时的陀螺仪调节状态如下图：</p>
<p><img src="https://img-blog.csdn.net/20170311165114162?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQW5kcmV3RmFu/font/5a6L5L2T/fontsize/200/fill/I0JBQkFCMA==/dissolve/70/gravity/NorthEast" srcset="/img/loading.gif" lazyload alt="死锁开始"></p>
<p>此时，船体再次发生转动，沿着当前世界坐标的+Z轴（蓝色轴，应该正指向船底）进行转动</p>
<p><img src="https://img-blog.csdn.net/20170311165659086?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQW5kcmV3RmFu/font/5a6L5L2T/fontsize/200/fill/I0JBQkFCMA==/dissolve/70/gravity/NorthEast" srcset="/img/loading.gif" lazyload alt="死锁的陀螺仪"></p>
<p>现在，转子不平衡了，陀螺仪的三板斧不起作用了。它失去了自身的调节能力。<br>之前陀螺仪之所以能通过自身调节，保持平衡，是因为存在可以相对旋转的连接头。在这种情况下，已经不存在可以相对旋转的连接头了。<br>那么连接头呢？去了哪里？显然，它还是在那里，只不过是，连接头可以旋转的相对方向不是现在需要的按着+Z轴方向。从上图中，我们清楚地看到：</p>
<ul>
<li><p>红色连接头：可以给予一个相对俯仰的自由度。</p>
</li>
<li><p>绿色连接头：可以给予一个相对偏航的自由度。</p>
</li>
<li><p>蓝色连接头：可以给予一个相对偏航的自由度。</p>
</li>
</ul>
<p>没错，三个连接头，提供的自由度只对应了俯仰和偏航两个自由度，桶滚自由度丢失了。这就是<strong>陀螺仪上的“万向节死锁”问题</strong>。</p>
<h4 id="各种旋转优缺点"><a href="#各种旋转优缺点" class="headerlink" title="各种旋转优缺点"></a>各种旋转优缺点</h4><ul>
<li><p><strong>矩阵旋转</strong></p>
<ul>
<li><p><strong>优点：</strong></p>
<p>旋转轴可以是任意向量；</p>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li>旋转其实只需要知道一个向量+一个角度，一共4个值的信息，但矩阵法却使用了16个元素；</li>
<li>而且在做乘法操作时也会增加计算量，造成了空间和时间上的一些浪费；</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>欧拉旋转</strong></p>
<ul>
<li><p><strong>优点：</strong></p>
<ul>
<li>很容易理解，形象直观；</li>
<li>表示更方便，只需要3个值（分别对应x、y、z轴的旋转角度）；但按我的理解，它还是转换到了3个3*3的矩阵做变换，效率不如四元数；</li>
</ul>
</li>
<li><p><strong>缺点：</strong></p>
<ul>
<li>之前提到过这种方法是要按照一个固定的坐标轴的顺序旋转的，因此不同的顺序会造成不同的结果；</li>
<li>会造成万向节锁（Gimbal Lock）的现象。这种现象的发生就是由于上述固定坐标轴旋转顺序造成的。理论上，欧拉旋转可以靠这种顺序让一个物体指到任何一个想要的方向，但如果在旋转中不幸让某些坐标轴重合了就会发生万向节锁，这时就会丢失一个方向上的旋转能力，也就是说在这种状态下我们无论怎么旋转（当然还是要原先的顺序）都不可能得到某些想要的旋转效果，除非我们打破原先的旋转顺序或者同时旋转3个坐标轴。这里有个视频可以直观的理解下；</li>
<li>由于万向节锁的存在，欧拉旋转无法实现球面平滑插值；</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>四元数旋转</strong></p>
<ul>
<li><strong>优点：</strong><ul>
<li>可以避免万向节锁现象；</li>
<li>只需要一个4维的四元数就可以执行绕任意过原点的向量的旋转，方便快捷，在某些实现下比旋转矩阵效率更高；</li>
<li>可以提供平滑插值；</li>
</ul>
</li>
<li>缺点：<ul>
<li>比欧拉旋转稍微复杂了一点点，因为多了一个维度；</li>
<li>理解更困难，不直观；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="🌙C"><a href="#🌙C" class="headerlink" title="🌙C#"></a>🌙C#</h2><h3 id="C-Array、ArrayList和List的区别"><a href="#C-Array、ArrayList和List的区别" class="headerlink" title="C#Array、ArrayList和List的区别"></a>C#Array、ArrayList和List的区别</h3><blockquote>
<p>Array</p>
</blockquote>
<p><strong>Array</strong> 类是 C# 中所有数组的基类，它是在 System 命名空间中定义。Array 类提供了各种⽤于数组的属性和⽅法。 </p>
<p>使⽤⽅法如下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">int</span>[] nums = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span> &#125;;<br>Array.Sort(nums);<br></code></pre></td></tr></table></figure>



<blockquote>
<p>ArrayList</p>
</blockquote>
<p><strong>ArrayList</strong>动态数组，是.Net Framework提供的⽤于数据存储和检索的专⽤类，它是命名空间System.Collections下的⼀部分。它的大小是按照其中存储的数据来动态扩充与收缩的。所以，我们在声明ArrayList对象时并不需要指定它的长度。ArrayList继承了IList接⼝，所以它可以很⽅便的进行数据的添加，插⼊和移除.</p>
<p>比如：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C#">ArrayList al = <span class="hljs-keyword">new</span> ArrayList();<br><span class="hljs-comment">//新增数据</span><br>al.Add(<span class="hljs-string">&quot;abc&quot;</span>); al.Add(<span class="hljs-number">123</span>);<br><span class="hljs-comment">//修改数据</span><br>al[<span class="hljs-number">2</span>] = <span class="hljs-number">345</span>;<br><span class="hljs-comment">//移除数据</span><br>al.RemoveAt(<span class="hljs-number">0</span>);<br><span class="hljs-comment">//插⼊数据</span><br>al.Insert(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;hello world&quot;</span>);<br></code></pre></td></tr></table></figure>



<blockquote>
<p>List</p>
</blockquote>
<p><strong>List</strong>类是ArrayList类的泛型等效类。它的⼤部分⽤法都与ArrayList相似，因为List类也继承了IList接⼝。最关键的区别在于，在声明List集合时，我们同时需要为其声明List集合内数据的对象类型。</p>
<p> 比如：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C#">List&lt;<span class="hljs-built_in">int</span>&gt; list = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;();<br><span class="hljs-comment">//新增数据</span><br> list.Add(<span class="hljs-number">123</span>);<br><span class="hljs-comment">//修改数据</span><br>list[<span class="hljs-number">0</span>] = <span class="hljs-number">345</span>;<br><span class="hljs-comment">//移除数据</span><br>list.RemoveAt(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure>

<p>​		上例中，如果我们往List泛型集合中插⼊string字符”hello world”，IDE就会报错，且不能通过编译。这样就避免了前⾯讲的类型安全问题与装箱拆箱的性能问题了。</p>
<p><strong>List泛型的好处：</strong><br>　　通过允许指定泛型类或⽅法操作的特定类型，泛型功能将类型安全的任务从您转移给了编译器。不需要编写代码来检测数据类型是否正确，因为会在编译时强制使⽤正确的数据类型。减少了类型强制转换的需要和运⾏时错误的可能性。泛型提供了类型安全但没有增加多个实现的开销。</p>
<p><font color = "red"><b>总结</b></font></p>
<ol>
<li><p>三者都⽤来处理⼀组数据，继承了IEnumerable接⼝，可⽤于for循环处理。都可以通过索引下标进⾏获取和设置元素。</p>
</li>
<li><p>Array在内存中是连续的，长度固定，⽆法删除和增加新的元素。⽽ArrayList或List的容量可根据需要⾃动插⼊和删除元素。</p>
</li>
<li><p>Array可以具有多个维度，⽽ ArrayList或 List&lt; T&gt; 始终只具有⼀个维度。但是，您可以轻松创建数组列表或列表的列表。</p>
</li>
<li><p>特定类型（Object 除外）的数组 的性能优于 ArrayList的性能。 这是因为 ArrayList的元素属于 Object 类型；所以在存储或检索值类型时通常发⽣装箱和拆箱操作。不过，在不需要重新分配时（即最初的容量⼗分接近列表的最⼤容量），List&lt; T&gt; 的性能与同类型的数组⼗分相近。</p>
</li>
<li><p>在决定使⽤ List 还是使⽤ArrayList 类（两者具有类似的功能）时，记住List 类在⼤多数情况下执⾏得更好并且是类型安全的。如果对<br>List&lt; T&gt; 类的类型T 使⽤引⽤类型，则两个类的⾏为是完全相同的。但是，如果对类型T使⽤值类型，则需要考虑实现和装箱问题。</p>
</li>
</ol>
<h3 id="请说说你认为C-中-x3D-x3D-和-Equals-的区别是什么？"><a href="#请说说你认为C-中-x3D-x3D-和-Equals-的区别是什么？" class="headerlink" title="请说说你认为C#中 &#x3D;&#x3D; 和 Equals 的区别是什么？"></a>请说说你认为C#中 &#x3D;&#x3D; 和 Equals 的区别是什么？</h3><ol>
<li>&#x3D;&#x3D; 是运算符，Equals是万物之父Object中的虚方法，子类可重写</li>
<li>Equals 一般在子类中重写后用于比较两个对象中内容是否相同<br> &#x3D;&#x3D;在没有运算符重载的前提下时<br> 引用类型用于比较地址；值类型用于比较值是否相同</li>
<li>运算效率不同，一般Equals没有&#x3D;&#x3D;效率高，因为一般Equals比较的内容比&#x3D;&#x3D;多</li>
</ol>
<h3 id="浅拷贝和深拷贝的区别？可以举例说明"><a href="#浅拷贝和深拷贝的区别？可以举例说明" class="headerlink" title="浅拷贝和深拷贝的区别？可以举例说明"></a>浅拷贝和深拷贝的区别？可以举例说明</h3><p><strong>浅拷贝：</strong><br>只复制对象的引用地址<br>两个对象指向同一内存地址，修改其中一个另一个也会随之变化</p>
<p><strong>深拷贝：</strong><br>将对象和值赋值过来，两个对象修改其中任意值都不会影响对方</p>
<p>举例：<br>比如引用对象A和引用对象B<br>让A &#x3D; B，就是浅拷贝，此时A、B的引用地址相同，改A中内容，B也变</p>
<p>如果想要深拷贝，简单处理就是new（包括对象中的成员）</p>
<h3 id="装箱和拆箱是指什么？"><a href="#装箱和拆箱是指什么？" class="headerlink" title="装箱和拆箱是指什么？"></a>装箱和拆箱是指什么？</h3><p>装箱——把栈中内容迁移到堆中去（值转引用）<br>拆箱——把堆中内容迁移到栈中去（引用转值）</p>
<p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230201221201268.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="值和引用类型在变量赋值时的区别是什么？"><a href="#值和引用类型在变量赋值时的区别是什么？" class="headerlink" title="值和引用类型在变量赋值时的区别是什么？"></a>值和引用类型在变量赋值时的区别是什么？</h3><p>在C#中<strong>值类型的变量直接存储数据</strong>，而<strong>引用类型的变量持有的是数据的引用，数据存储在数据堆中</strong>。</p>
<p><strong>值类型</strong>（value type）：byte，short，int，long，float，double，decimal，char，bool 和 struct 统称为值类型。值类型变量声明后，不管是否已经赋值，编译器为其分配内存。<br><img src="https://img-blog.csdnimg.cn/b99d714ae81d4ed08afb9a933e5df2ea.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br><strong>引用类型</strong>（reference type）：string 和 class统称为引用类型。当声明一个类时，只在栈中分配一小片内存用于容纳一个地址，而此时并没有为其分配堆上的内存空间。当使用 new 创建一个类的实例时，分配堆上的空间，并把堆上空间的地址保存到栈上分配的小片空间中。<br><img src="https://img-blog.csdnimg.cn/cdda4b5f61374524bf3082080d30c4fb.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>值类型的实例通常是在线程栈上分配的（静态分配），但是在某些情形下可以存储在堆中。引用类型的对象总是在进程堆中分配（动态分配)。</p>
<h3 id="委托和事件在使用上的区别是什么？"><a href="#委托和事件在使用上的区别是什么？" class="headerlink" title="委托和事件在使用上的区别是什么？"></a>委托和事件在使用上的区别是什么？</h3><p>事件相对委托来说，事件在外部使用时只能 +&#x3D;、-&#x3D;</p>
<h3 id="请说明C-中的List是如何扩容的"><a href="#请说明C-中的List是如何扩容的" class="headerlink" title="请说明C#中的List是如何扩容的"></a>请说明C#中的List是如何扩容的</h3><p>List的本质是数组</p>
<h3 id="C-中try-catch-finally的执行顺序"><a href="#C-中try-catch-finally的执行顺序" class="headerlink" title="C#中try catch finally的执行顺序"></a>C#中try catch finally的执行顺序</h3><p>1.首先明确一点，就是不管怎样，finally一定会执行，即使程序有异常，并且在catch中thorw 了 ，finally还是会被执行。</p>
<p>2.当try和catch中有return时，finally仍然执行。</p>
<p>3.finally是在return后面的表达式运算完之后执行的，在执行完return时 ，程序并没有跳出，而是进入到finally中继续执行，</p>
<p> 如果在finally如果对返回值进行了重新赋值，分为两种情况：</p>
<p>（1）当返回值是值类型（包括string类型，虽然是引用类型，这是特殊的个例）时，返回的值不受影响，</p>
<p>​    就是在trycatch时，返回的值已经确定了。</p>
<p>（2）当返回值是引用类型时，会影响到返回值，</p>
<p>eg:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span>[] <span class="hljs-title">TestYinYong</span>()</span><br>     &#123;<br>         <span class="hljs-built_in">string</span>[] arr = &#123; <span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span> &#125;;<br>         <span class="hljs-keyword">try</span><br>         &#123;<br>             <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception();<br>         &#125;<br>         <span class="hljs-keyword">catch</span> (Exception)<br>         &#123;<br>             <span class="hljs-keyword">return</span> arr;<br>         &#125;<br>         <span class="hljs-keyword">finally</span><br>         &#123;<br>             arr[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;three&quot;</span>;<br>         &#125;<br>     &#125;<br></code></pre></td></tr></table></figure>

<p>此时返回的值是：{ “one”, “three” };</p>
<p>4.finally中不能有return语句，编译都无法通过，提示：控制不能离开finally子句主体</p>
<h3 id="泛型约束有几种"><a href="#泛型约束有几种" class="headerlink" title="泛型约束有几种"></a>泛型约束有几种</h3><ol>
<li>值类型约束 T:struct</li>
<li>引用类型约束 T:class</li>
<li>公共无参构造约束 T:new()</li>
<li>类约束 T:类名</li>
<li>接口约束 T:接口名</li>
<li>另一个泛型约束 T:U</li>
</ol>
<h3 id="什么是闭包？可以举例说明"><a href="#什么是闭包？可以举例说明" class="headerlink" title="什么是闭包？可以举例说明"></a>什么是闭包？可以举例说明</h3><p>闭包是指有权访问另一个函数作用域中的变量的函数<br>所以闭包一般都是指的一个函数<br>创建这种特殊闭包函数的方式往往是在一个函数中创建另一个函数</p>
<p><strong>闭包需要满足四个条件</strong></p>
<ol>
<li>有函数嵌套</li>
<li>内部函数引用外部作用域的变量参数</li>
<li>返回值是函数</li>
<li>创建一个对象函数，让其长期驻留</li>
</ol>
<p><strong>闭包的经典示例</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c#">    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>        &#123;<br>            Task.Run(() =&gt; Console.WriteLine(i));<br>        &#125;<br><br>        Console.ReadKey();<br>    &#125;<br><br>output:<br><span class="hljs-number">5</span><br><span class="hljs-number">5</span><br><span class="hljs-number">5</span><br><span class="hljs-number">5</span><br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>

<p>Task.Run中的委托其实就是我们的闭包，它把局部变量i捕获了，所以在执行这个闭包的时候可以使用到变量i，也就是闭包执行的时候i是多少，那么传入的参数就是多少。</p>
<p>但是按理说，i&#x3D;0时，也会执行闭包啊，为什么传入的不是0。<strong>猜测i&#x3D;0时，闭包并没有立马执行，包括i&#x3D;1,2,3,4等，只有在for循环结束了的时候（i&#x3D;5）时闭包才一起执行的，所以输出的都是5</strong>。我们可以把代码改为这样：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C#">        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>            &#123;<br>                Task task = Task.Run(() =&gt; Console.WriteLine(i));<br>                task.Wait();<br>            &#125;<br><br>            Console.ReadKey();<br>        &#125;<br>output:<br><span class="hljs-number">0</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br><br></code></pre></td></tr></table></figure>



<h3 id="内存泄漏问题"><a href="#内存泄漏问题" class="headerlink" title="内存泄漏问题"></a>内存泄漏问题</h3><blockquote>
<p>内存泄漏指什么？</p>
</blockquote>
<p>内存泄漏指的就是对象超过生命周期后而不能被GC回收，一般指不会再使用的引用对象由于某些操作而不能被GC垃圾回收，而一直占用着内存</p>
<p>更风趣通俗一点的说就是：没用的家伙没有被当成垃圾回收</p>
<blockquote>
<p>常见的内存泄漏有哪些？</p>
</blockquote>
<p>常见的内存泄漏有：</p>
<ol>
<li>静态引用</li>
<li>不使用的引用对象没有置null，一直被引用</li>
<li>文件操作时，没有使用using或者没有进行Dispose()</li>
<li>委托或事件注册后没有解除注册（有加就有减）<br>等等</li>
</ol>
<h3 id="序列化问题"><a href="#序列化问题" class="headerlink" title="序列化问题"></a>序列化问题</h3><blockquote>
<p>序列化是什么？</p>
</blockquote>
<p>序列化是将<strong>程序中数据对象转换为可以存储或传输的形式 的过程</strong>。</p>
<blockquote>
<p>常见的序列化方式有哪些？什么时候我们会用到序列化？</p>
</blockquote>
<p>我们常见的序列化方式 <strong>xml、Json、2进制等</strong>。就是将内存中的数据按照我们自己定义的规则进行序列化，序列化之后就可以用于存储和传输，当读取和接受数据时，只需要按照对应规则进行反序列化便可得到原始数据</p>
<p>所谓的存储读取和传输接受，其实一般指的就是<strong>数据持久化和网络通讯</strong><br>所以我们经常会在这两块知识点看到序列化反序列化这两个关键词</p>
<h3 id="值和地址问题"><a href="#值和地址问题" class="headerlink" title="值和地址问题"></a>值和地址问题</h3><p><strong>请问A、B、C 三处打印结果分别为多少？为什么？</strong></p>
<p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/addressProblem.png" srcset="/img/loading.gif" lazyload></p>
<p>A是10，B和C为100</p>
<p>Test1处参数传递进去后，函数内部的形参value是在栈上重新开辟的空间，将传入参数的值拷贝到了该空间中，和传入参数没有关系</p>
<p>Test2处参数是指针类型，指针是用于存储内存地址的变量，我们传入的是值得地址&amp;test2Value，在函数内部改变的是地址中存储的值，所以外部的test2Value会随之改变</p>
<p>Test3处ref关键字，底层逻辑中是将value作为test3Value的一个别名，他们指向的空间一致，所以value改变后，外部的test3Value也会改变</p>
<h3 id="字符串三种为空的不同写法的区别"><a href="#字符串三种为空的不同写法的区别" class="headerlink" title="字符串三种为空的不同写法的区别"></a>字符串三种为空的不同写法的区别</h3><p><strong>请说明字符串中三者的区别</strong></p>
<ul>
<li>string str &#x3D; null</li>
<li>string str &#x3D; “”</li>
<li>string str &#x3D; string.Empty</li>
</ul>
<p><strong>str &#x3D; null</strong> 在堆中没有分配内存地址<br><strong>str &#x3D; “”</strong> 和 <strong>string.Empty</strong> 一样都是在堆内存中分配了空间，里面存储的是空字符串<br>而<strong>string.Empty</strong>是一个静态只读变量</p>
<h3 id="C-重载运算符，重载-x3D-x3D-和-x3D-以及-万物之父Object基类中的虚方法-virtual-bool-Equals-Object-obj-对于我们的意义是什么？"><a href="#C-重载运算符，重载-x3D-x3D-和-x3D-以及-万物之父Object基类中的虚方法-virtual-bool-Equals-Object-obj-对于我们的意义是什么？" class="headerlink" title="C#重载运算符，重载 &#x3D;&#x3D; 和 !&#x3D; 以及 万物之父Object基类中的虚方法 virtual bool Equals(Object obj)对于我们的意义是什么？"></a>C#重载运算符，重载 &#x3D;&#x3D; 和 !&#x3D; 以及 万物之父Object基类中的虚方法 virtual bool Equals(Object obj)对于我们的意义是什么？</h3><p>为了判断两个对象的非引用地址相等<br>我们可以选择 使用 重载运算符 &#x3D;&#x3D; 和 !&#x3D; 或者<br>重写Equals方法，来自定义判断两个对象是否相等<br>如果想保留原有的引用地址相等判断，那么一般我们选择重写Equals方法</p>
<h3 id="在开发时，对string和StringBuilder我们应该如何选择"><a href="#在开发时，对string和StringBuilder我们应该如何选择" class="headerlink" title="在开发时，对string和StringBuilder我们应该如何选择"></a>在开发时，对string和StringBuilder我们应该如何选择</h3><p><strong>string</strong>在每次拼接时都会产生垃圾<br><strong>StringBuilder</strong>在拼接时，是在原空间中进行修改，不会产生垃圾，会自动帮助我们扩容<br>所以<strong>当字符串需要频繁修改拼接时，我们使用StringBuilder</strong></p>
<h3 id="请简要说明-Net跨语言原理"><a href="#请简要说明-Net跨语言原理" class="headerlink" title="请简要说明.Net跨语言原理"></a>请简要说明.Net跨语言原理</h3><p><strong>.Net制定了了CLI（公共语言架构）的规则</strong><br>只要是按照该规则设计的语言在进行.Net相关开发时<br><strong>编译器会将源代码（C#、VB等等）编译为CIL（公共中间语言）通用中间代码</strong>。<br>也就是说不管什么语言进行开发，最终都会统一规范变为中间代码<br>最终通过<strong>CLR（公共语言运行时或者称为.Net虚拟）将中间代码翻译为对应操作系统的原生代码（机器码）</strong>在操作系统（Windows）上运行</p>
<p><img src="https://img-blog.csdn.net/20160528132344296" srcset="/img/loading.gif" lazyload alt="img"></p>
<h3 id="List初始化效率问题"><a href="#List初始化效率问题" class="headerlink" title="List初始化效率问题"></a>List初始化效率问题</h3><p><strong>以下代码，谁的效率更高？为什么？</strong></p>
<p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ListProblem.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>代码2的效率更高</strong></p>
<p>因为List的本质是数组，在初始化时，如果不默认为其指明分配多少容量，它会不断扩容<br><strong>扩容会带来效率的降低和垃圾的产生</strong></p>
<ul>
<li><strong>效率的降低：</strong>从旧数组到新数组的搬家</li>
<li><strong>垃圾的产生：</strong>每次扩容时，就数组就变成了垃圾</li>
</ul>
<h3 id="数组和链表的区别是什么？"><a href="#数组和链表的区别是什么？" class="headerlink" title="数组和链表的区别是什么？"></a>数组和链表的区别是什么？</h3><ol>
<li><strong>存储结构不同</strong></li>
</ol>
<ul>
<li>数组是顺序存储结构，在内存中是连续存储的</li>
<li>链表是链式存储结构，在内存中是非连续存储的</li>
</ul>
<ol start="2">
<li><strong>访问效率不同</strong></li>
</ol>
<ul>
<li>数组由于是顺序存储，通过下标访问，访问效率高</li>
<li>链表由于是非连续存储，我们想要获取其中某一元素，需要从头或尾遍历，效率低</li>
</ul>
<ol start="3">
<li><strong>插入、删除效率不同</strong></li>
</ol>
<ul>
<li>数组由于是顺序存储，在插入和删除时，需要整体移动数组中的大部分元 素，效率低</li>
<li>链表由于是链式存储，在插入和删除时，效率高</li>
</ul>
<ol start="4">
<li><strong>越界问题</strong></li>
</ol>
<ul>
<li>数组由于是顺序存储，声明时容量是固定的，如果不处理扩容逻辑，存在越界风险</li>
<li>链表由于是链式存储，无越界风险</li>
</ul>
<h3 id="C-Action和Func问题"><a href="#C-Action和Func问题" class="headerlink" title="C#Action和Func问题"></a>C#Action和Func问题</h3><blockquote>
<p>C#中的Action和Func是什么？他们有什么区别？</p>
</blockquote>
<p>Action和Func是System命名空间下 C#为我们提供的两个写好的委托</p>
<ul>
<li><p><strong>Action</strong>本身是一个无参无返回值的委托<br>对应的Action&lt;&gt;泛型委托支持最多16个参数</p>
</li>
<li><p><strong>Func</strong>本身是一个无参有返回值的委托<br>对应的Func&lt;&gt;泛型委托支持最多16个参数，并且有返回值</p>
</li>
</ul>
<blockquote>
<p>Unity 中的UnityAction是什么？</p>
</blockquote>
<ol>
<li><p><strong>UnityAction</strong>是UnityEngine.Events命名空间下 <strong>Unity为我们提供的写好的委托</strong></p>
</li>
<li><p>UnityAction本身<strong>是一个无参无返回值的委托</strong><br>对应的UnityAction&lt;&gt;<strong>泛型委托支持最多4个参数</strong></p>
</li>
</ol>
<h3 id="网络游戏开发中，网络传输数据的基本流程是什么？"><a href="#网络游戏开发中，网络传输数据的基本流程是什么？" class="headerlink" title="网络游戏开发中，网络传输数据的基本流程是什么？"></a>网络游戏开发中，网络传输数据的基本流程是什么？</h3><p>客户端将自定义类对象数据序列化为2进制数据发送给服务端</p>
<p>服务端将收到的2进制数据反序列化为对应的类对象进行逻辑处理</p>
<p>如果是服务端发送给客户端的消息也是同理</p>
<h3 id="C-中如何让自定义容器类能够使用for循环遍历？（通过-类对象-索引-的形式遍历）"><a href="#C-中如何让自定义容器类能够使用for循环遍历？（通过-类对象-索引-的形式遍历）" class="headerlink" title="C#中如何让自定义容器类能够使用for循环遍历？（通过 类对象[索引] 的形式遍历）"></a>C#中如何让自定义容器类能够使用for循环遍历？（通过 类对象[索引] 的形式遍历）</h3><p>通过在类中实现索引器实现</p>
<h3 id="C-中如何让自定义容器类能够使用foreach循环遍历？"><a href="#C-中如何让自定义容器类能够使用foreach循环遍历？" class="headerlink" title="C#中如何让自定义容器类能够使用foreach循环遍历？"></a>C#中如何让自定义容器类能够使用foreach循环遍历？</h3><p>通过为该类实现迭代器可以让其使用foreach遍历<br>传统方式：<br>继承IEnumerator、IEnumerable两个接口<br>实现其中的<br>1.GetEnumerator方法<br>2.Current属性<br>3.MoveNext方法<br>语法糖方式：<br>利用yield return语法糖，实现GetEnumerator方法即可完成迭代器的实现</p>
<h3 id="C-中接口的作用是什么？说说你的理解"><a href="#C-中接口的作用是什么？说说你的理解" class="headerlink" title="C#中接口的作用是什么？说说你的理解"></a>C#中接口的作用是什么？说说你的理解</h3><p>用于建立行为的继承关系，而不是对象<br>不同对象，有相同行为时，我们可以利用接口对不同对象的行为进行整合</p>
<hr>
<h2 id="🌙Lua与热更新"><a href="#🌙Lua与热更新" class="headerlink" title="🌙Lua与热更新"></a>🌙Lua与热更新</h2><h3 id="Lua如何实现面向对象的三大特性？"><a href="#Lua如何实现面向对象的三大特性？" class="headerlink" title="Lua如何实现面向对象的三大特性？"></a>Lua如何实现面向对象的三大特性？</h3><p>面向对象三大特性</p>
<ul>
<li>封装：利用<strong>table进行封装</strong></li>
<li>继承：利用<strong>元表和_index</strong>模拟继承关系<br>       设置<strong>子类的元表为父类</strong>，<strong>父类的_index为父类自己</strong><br>       当<strong>子类</strong>身上<strong>找不到对应属性和方法</strong>时<br>       会<strong>查找元表的__index中的内容，也就是会查找父类中的内容</strong><br>       通过这种方式来模拟继承</li>
<li>多态：子类自己去实现带：的同名方法即可</li>
</ul>
<h3 id="请简述热更新的流程"><a href="#请简述热更新的流程" class="headerlink" title="请简述热更新的流程"></a>请简述热更新的流程</h3><p>本地存在资源对比文件和已有资源</p>
<ol>
<li><p>下载资源服务器中的对比文件</p>
</li>
<li><p>将下载下来的远端对比文件和本地的做对比</p>
<p>记录需要更新的资源和要移除的资源</p>
</li>
<li><p>根据第二步中记录的信息，进行资源下载和移除</p>
</li>
<li><p>更新本地对比文件，其内容和刚才下载的远端对比文件一致</p>
</li>
</ol>
<h3 id="如果不考虑IOS平台，只在Windows和Android平台上发布游戏，如何在不使用第三方热更新方案的前提下实现热更新功能"><a href="#如果不考虑IOS平台，只在Windows和Android平台上发布游戏，如何在不使用第三方热更新方案的前提下实现热更新功能" class="headerlink" title="如果不考虑IOS平台，只在Windows和Android平台上发布游戏，如何在不使用第三方热更新方案的前提下实现热更新功能"></a>如果不考虑IOS平台，只在Windows和Android平台上发布游戏，如何在不使用第三方热更新方案的前提下实现热更新功能</h3><p><strong>C#的反射</strong><br>可以通过热更DLL文件的形式，加载程序集（dll）<br>利用反射执行热更DLL包中的逻辑</p>
<hr>
<h2 id="🌙计算机网络"><a href="#🌙计算机网络" class="headerlink" title="🌙计算机网络"></a>🌙计算机网络</h2><h3 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP UDP"></a>TCP UDP</h3><p>TCP&#x2F;IP协议（一）网络基础知识 网络七层协议<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wanghuaijun/p/10092930.html">https://www.cnblogs.com/wanghuaijun/p/10092930.html</a></p>
<ul>
<li><strong>TCP</strong>(Transmission Control Protocol 传输控制协议)：<strong>是一种面向连接的、可靠的、基于字节流的传输层通信协议</strong>，使用三次握手协议建立连接、四次挥手断开连接。面向连接意味着两个使用TCP的应用(通常是一个客户端和一个服务器)在彼此交换数据包之前必须先建立一个TCP连接。在一个TCP连接中，仅有两方进行彼此通信，广播和多播不能用TCP。TCP 协议的作用是，保证数据通信的完整性和可靠性，防止丢包。TCP把连接作为最基本的对象，每一条TCP连接都有两个端点，这种端点我们叫作套接字(socket)，端口号拼接到IP地址即构成了套接字。</li>
<li><strong>UDP</strong>(User Datagram Protocol 用户数据报协议)：<strong>是OSI</strong>(Open System Interconnection 开放式系统互联)<strong>参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务</strong>。UDP协议的主要作用是将网络数据流量压缩成数据包的形式。</li>
<li>区别：<ul>
<li>TCP提供的是面向连接的、可靠的数据流传输；UDP提供的是非面向连接的、不可靠的数据流传输。</li>
<li>TCP提供可靠的服务，通过TCP连接传送的数据，无差错、不丢失、不重复，按序到达；UDP尽最大努力交付，即不保证可靠交付。</li>
<li>TCP面向字节流；UDP面向报文。</li>
<li>TCP连接只能是点到点的；UDP支持一对一、一对多、多对一和多对多的交互通信。</li>
<li>UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。</li>
<li>TCP对系统资源要求较多，UDP对系统资源要求较少。TCP首部有20字节；UDP的首部只有8个字节。</li>
<li>TCP的逻辑通信信道是全双工的可靠信道；UDP的逻辑通信信道是不可靠信道。</li>
<li>基于TCP的应用：HTTP、WebSocker、重要数据文件传输等常见</li>
<li>基于UDP的应用：QQ等部分实时通信软件、视频&#x2F;音频下载传输等。</li>
</ul>
</li>
</ul>
<h3 id="三次握手，4次挥手"><a href="#三次握手，4次挥手" class="headerlink" title="三次握手，4次挥手"></a>三次握手，4次挥手</h3><ul>
<li><strong>三次握手</strong><ul>
<li>第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 SYN_Send状态。</li>
<li>第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD的状态。</li>
<li>第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 establised状态。</li>
<li>服务器收到 ACK 报文之后，也处于 establised 状态，此时，双方以建立起了链接。</li>
</ul>
</li>
<li><strong>四次挥手</strong><ul>
<li>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于CLOSED_WAIT1状态。</li>
<li>第二次握手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT2状态。</li>
<li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK的状态。</li>
<li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态</li>
<li>服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</li>
</ul>
</li>
</ul>
<h3 id="状态同步-帧同步"><a href="#状态同步-帧同步" class="headerlink" title="状态同步,帧同步"></a>状态同步,帧同步</h3><p>帧同步和状态同步该怎么选（上）<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/104932624">https://zhuanlan.zhihu.com/p/104932624</a></p>
<p>帧同步和状态同步<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/33898014">https://zhuanlan.zhihu.com/p/33898014</a></p>
<h3 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h3><p>OSI（Open System Interconnection）是由国际标准化组织（ISO）制定的网络模型，该模型定义了不同计算机如何互相连接，是设计和描述计算机网络通信的基本框架。<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=OSI%E6%A8%A1%E5%9E%8B&spm=1001.2101.3001.7020">OSI模型</a>将网络通信分为7层：</p>
<p><img src="https://img-blog.csdnimg.cn/20210530224055792.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzeTc3Nzc3Nw==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p>OSI仅是一个理论上的模型，实际使用的是TCP&#x2F;IP网络模型，TCP&#x2F;IP模型将OSI模型的应用层，表示层和会话层合并为应用层：</p>
<p><img src="https://img-blog.csdnimg.cn/20210530224106137.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzeTc3Nzc3Nw==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="img"></p>
<hr>
<h2 id="🌙算法"><a href="#🌙算法" class="headerlink" title="🌙算法"></a>🌙算法</h2><h3 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problemset/all/">题库 - 力扣 (LeetCode) 全球极客挚爱的技术成长平台</a></p>
<p><strong>每日一题</strong></p>
<p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/V2QJXN%25LGY17_GWQIJ%24%7D1W1.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="十大排序算法"><a href="#十大排序算法" class="headerlink" title="十大排序算法"></a>十大排序算法</h3><h4 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h4><p><img src="https://img-blog.csdnimg.cn/1daa0def8e454f61836f28a8d1cb2e0b.gif" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p><strong>口诀：</strong></p>
<p>外层循环 n-1;内层循环 n-1-i;两两比较做互换；</p>
<blockquote>
<p>以下代码在控制台操作，输入数字以‘逗号’隔开</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BubbleSort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] array</span>)</span><br>&#123;<br>	<span class="hljs-built_in">bool</span> isSort = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; array.Length; ++i)<br>    &#123;<br>    	isSort = <span class="hljs-literal">false</span>;<br>    	<span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; array.Length - i - <span class="hljs-number">1</span>; ++j)<br>        &#123;<br>        	<span class="hljs-keyword">if</span> (array[j] &gt; array[j + <span class="hljs-number">1</span>])<br>            &#123;<br>            	isSort = <span class="hljs-literal">true</span>;<br><br>				array[j] ^= array[j + <span class="hljs-number">1</span>];<br>                array[j + <span class="hljs-number">1</span>] ^= array[j];<br>                array[j] ^= array[j + <span class="hljs-number">1</span>];<br><br>			&#125;<br>        &#125;<br>        <br>		  	<span class="hljs-keyword">if</span> (!isSort)<br>		  		<span class="hljs-keyword">break</span>;<br>                <br>     &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>程序执行结果：</p>
<p><img src="https://img-blog.csdnimg.cn/15b1cfff79a049f0bef2dc98617d8d8d.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h4 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2.插入排序"></a>2.插入排序</h4><p><img src="https://img-blog.csdnimg.cn/d7de02f14c6c45f7ad9e75888ed6254b.gif" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InsertSort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] array</span>)</span><br>&#123;<br>    <span class="hljs-built_in">int</span> noSortValue;<br>    <span class="hljs-built_in">int</span> sortIndex;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; array.Length; ++i)<br>    &#123;<br>        noSortValue = array[i];<br>        sortIndex = i - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (sortIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; array[sortIndex] &gt; noSortValue)<br>        &#123;<br>            array[sortIndex + <span class="hljs-number">1</span>] = array[sortIndex];<br>            --sortIndex;<br>        &#125;<br>        array[sortIndex + <span class="hljs-number">1</span>] = noSortValue;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>程序执行结果：</p>
<p><img src="https://img-blog.csdnimg.cn/15b1cfff79a049f0bef2dc98617d8d8d.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h4 id="3-选择排序"><a href="#3-选择排序" class="headerlink" title="3.选择排序"></a>3.选择排序</h4><p><img src="https://img-blog.csdnimg.cn/b72900449cb44c15999f8d89c286bb69.gif" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SelectionSort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] array</span>)</span><br>&#123;<br>    <span class="hljs-built_in">int</span> index;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; array.Length; i++)<br>    &#123;<br>        index = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = i + <span class="hljs-number">1</span>; j &lt; array.Length; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (array[index] &gt; array[j])<br>            &#123;<br>                index = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (index != i)<br>        &#123;<br>            array[i] ^= array[index];<br>            array[index] ^= array[i];<br>            array[i] ^= array[index];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<p>程序执行结果：</p>
<p><img src="https://img-blog.csdnimg.cn/5ca6790d2c4740ba86e8b956475dd2bd.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h4 id="4-快速排序"><a href="#4-快速排序" class="headerlink" title="4.快速排序"></a>4.快速排序</h4><p><img src="https://img-blog.csdnimg.cn/5ff1f36a0e694cbc9ffd5f2e6089a821.gif" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p>快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists)。</p>
<p><strong>步骤为：</strong></p>
<ol>
<li><p>从数列中挑出一个元素，称为 “基准”（pivot）。</p>
</li>
<li><p>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆放在基准的后面（相同的数可以到任一边）。在这个分割结束之后，该基准就处于数列的中间位置。这个称为分割（partition）操作。</p>
</li>
<li><p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p>
</li>
</ol>
<p>递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个演算法总会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.Linq;<br><span class="hljs-keyword">using</span> System.Text;<br><br><span class="hljs-keyword">namespace</span> 快速排序    <span class="hljs-comment">//***对相同元素, 不稳定的排序算法***</span><br>&#123;<br>    <span class="hljs-comment">//相对来说，快速排序数值越大速度越快 。  快速排序是所有排序里面最快的</span><br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            <span class="hljs-built_in">int</span>[] arr = &#123; <span class="hljs-number">15</span>, <span class="hljs-number">22</span>, <span class="hljs-number">35</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">33</span>, <span class="hljs-number">15</span>, <span class="hljs-number">23</span>, <span class="hljs-number">68</span>, <span class="hljs-number">1</span>, <span class="hljs-number">33</span>, <span class="hljs-number">25</span>, <span class="hljs-number">14</span> &#125;; <span class="hljs-comment">//待排序数组</span><br>            QuickSort(arr, <span class="hljs-number">0</span>, arr.Length - <span class="hljs-number">1</span>);  <span class="hljs-comment">//调用快速排序函数。传值(要排序数组，基准值位置，数组长度)</span><br><br>            <span class="hljs-comment">//控制台遍历输出</span><br>            Console.WriteLine(<span class="hljs-string">&quot;排序后的数列：&quot;</span>);<br>            <span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">int</span> item <span class="hljs-keyword">in</span> arr)<br>                Console.WriteLine(item);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">QuickSort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] arr, <span class="hljs-built_in">int</span> begin, <span class="hljs-built_in">int</span> end</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (begin &gt;= end) <span class="hljs-keyword">return</span>;   <span class="hljs-comment">//两个指针重合就返回，结束调用</span><br>            <span class="hljs-built_in">int</span> pivotIndex = QuickSort_Once(arr, begin, end);  <span class="hljs-comment">//会得到一个基准值下标</span><br><br>            QuickSort(arr, begin, pivotIndex - <span class="hljs-number">1</span>);  <span class="hljs-comment">//对基准的左端进行排序  递归</span><br>            QuickSort(arr, pivotIndex + <span class="hljs-number">1</span>, end);   <span class="hljs-comment">//对基准的右端进行排序  递归</span><br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">QuickSort_Once</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] arr, <span class="hljs-built_in">int</span> begin, <span class="hljs-built_in">int</span> end</span>)</span><br>        &#123;<br>            <span class="hljs-built_in">int</span> pivot = arr[begin];   <span class="hljs-comment">//将首元素作为基准</span><br>            <span class="hljs-built_in">int</span> i = begin;<br>            <span class="hljs-built_in">int</span> j = end;<br>            <span class="hljs-keyword">while</span> (i &lt; j)<br>            &#123;<br>                <span class="hljs-comment">//从右到左，寻找第一个小于基准pivot的元素</span><br>                <span class="hljs-keyword">while</span> (arr[j] &gt;= pivot &amp;&amp; i &lt; j) j--; <span class="hljs-comment">//指针向前移</span><br>                arr[i] = arr[j];  <span class="hljs-comment">//执行到此，j已指向从右端起第一个小于基准pivot的元素，执行替换</span><br><br>                <span class="hljs-comment">//从左到右，寻找首个大于基准pivot的元素</span><br>                <span class="hljs-keyword">while</span> (arr[i] &lt;= pivot &amp;&amp; i &lt; j) i++; <span class="hljs-comment">//指针向后移</span><br>                arr[j] = arr[i];  <span class="hljs-comment">//执行到此,i已指向从左端起首个大于基准pivot的元素，执行替换</span><br>            &#125;<br><br>            <span class="hljs-comment">//退出while循环,执行至此，必定是 i= j的情况（最后两个指针会碰头）</span><br>            <span class="hljs-comment">//i(或j)所指向的既是基准位置，定位该趟的基准并将该基准位置返回</span><br>            arr[i] = pivot;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="5-希尔排序"><a href="#5-希尔排序" class="headerlink" title="5.希尔排序"></a>5.希尔排序</h4><p>插入排序的升级</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>       &#123;<br>           <span class="hljs-built_in">int</span>[] numlist = &#123; <span class="hljs-number">33</span>, <span class="hljs-number">6</span>, <span class="hljs-number">89</span>, <span class="hljs-number">34</span>, <span class="hljs-number">63</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span> &#125;;<br>           Console.WriteLine(<span class="hljs-string">&quot;排序前数组:&quot;</span>);<br>           <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; numlist.Length; i++)<br>           &#123;<br>               Console.Write(<span class="hljs-string">&quot; &quot;</span>+numlist[i]);<br>           &#125;<br>           <span class="hljs-comment">// 将每组间隔为h的分组进行排序，刚开始h=数组长度的一半</span><br>           <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> h = numlist.Length/<span class="hljs-number">2</span>; h &gt;<span class="hljs-number">0</span>; h/=<span class="hljs-number">2</span>)<br>           &#123;<br>               <span class="hljs-comment">//对每组进行插入排序</span><br>               <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = h; i &lt; numlist.Length; i++)<br>               &#123;<br>                   <span class="hljs-comment">// 将numlist[i]插入到所在分组的正确位置上</span><br>                   insertI(numlist, h, i);<br>               &#125;<br>           &#125;<br>           Console.WriteLine(<span class="hljs-string">&quot;\r\n排序后结果:&quot;</span>);<br>           <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; numlist.Length; i++)<br>           &#123;<br>               Console.Write(<span class="hljs-string">&quot; &quot;</span>+numlist[i]);<br>           &#125;<br>           Console.ReadLine();<br>       &#125;<br>       <span class="hljs-comment">// 插入排序的方法</span><br>       <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertI</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] arr,<span class="hljs-built_in">int</span> h, <span class="hljs-built_in">int</span> i</span>)</span><br>       &#123;<br>           <span class="hljs-built_in">int</span> temp = arr[i];<br>           <span class="hljs-built_in">int</span> k;<br>           <span class="hljs-keyword">for</span> ( k= i-h; k&gt;=<span class="hljs-number">0</span> &amp;&amp; temp&lt;arr[k]; k-=h)<br>           &#123;<br>               arr[k + h] = arr[k];<br>           &#125;<br>           arr[k + h] = temp;<br>       &#125;<br></code></pre></td></tr></table></figure>


<p>​	</p>
<p>程序执行结果：</p>
<p><img src="https://img-blog.csdnimg.cn/2b6aaaf6b5914b2eb6efa5e559c18840.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h4 id="6-堆排序"><a href="#6-堆排序" class="headerlink" title="6.堆排序"></a>6.堆排序</h4><p>堆排序首先是构建最大堆或最小堆。最大堆是用来正序排序，最小堆是用来倒序排序。</p>
<p>最大堆是指二叉树中每个结点的值都比其左右子结点的值大。同理最小堆是指二叉树中每个结点的值都比其左右子结点的值小。</p>
<p>对于二叉树不了解，在这里可以只有一个印象就可以。二叉树就是一个结点最多只有两个左右子结点。至于什么是完全二叉树，这里就不在过多解释，以后有机会写数据结构的时候，会着重解释，但是有一点要知道，数列从上往下，从左往右，按照只有一个根结点，且每个结点有两个子结点这样构建二叉树，那么他就是一颗完全二叉树。</p>
<p>下面我用一张图，来表示上面的概念，并加深印象。</p>
<p><img src="https://img-blog.csdnimg.cn/e33fa55d2e98407ea12bbc0b99221487.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p>完全二叉树：<br>可以发现其实每个结点的下标和其左右子结点的下标是有一定关系的，即结点下标为n，左子结点下标为：2n+1，右子结点的下标为：2n+2。</p>
<p>最大堆：</p>
<p><img src="https://img-blog.csdnimg.cn/8f1362ccb2a043d98977410ba95406e2.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p>上图为第一次构建最大堆的结果</p>
<p>可以看出因为根结点要比左右子结点数值大，而且其左右子结点要比其孙子结点数值大，以此类推，此时的根结点即为数列的最大值。</p>
<p>那么我们如何把一个无序构建成一个最大堆。首先看最大堆的最大特点就是：父结点的数值一定比左右结点数值大，我们依照这个规则不断的调整结点使其满足条件即可。</p>
<p>再仔细观察堆我们发现，由一半以上的结点是没有孩子结点的，这部分结点就称为叶子结点，那么也就是说，这部分结点是不需要向下调整的。我们选择从(length&#x2F;2)-1的下标开始依次从0下标的方向进行调整。每次调整之后，调整的结点还要继续比较他的子结点看看是否仍然满足最大堆特点，一直调整到叶子结点。这样做的目的就是使数列的大值向上浮，小值向下沉。直到下标0结点（根结点）调整完成，此时就是一个最大堆。</p>
<p>此时根结点是一个最大值，我们把最大值排在无序数列最后，即把最大值与队尾交换位置。此时我们发现除了根结点，其他结点仍然是符合最大堆特点的（注意，从这个位置往后，我们讲述的情况都是排除了最后一个数，因为他已经排好了位置）。这时我们只用调整根结点就可以了，调整之后，就得到了数列的第二个最大值。依次调整，直到数列排好即可。</p>
<p><img src="https://img-blog.csdnimg.cn/5eaad2f07d4e400daff97217f6b7ab49.gif" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c#"> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HeapSort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] arr</span>)</span><br>&#123;<br>    <span class="hljs-built_in">int</span> length = arr.Length;<br>    <span class="hljs-keyword">if</span> (length &lt; <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//初次构建最大堆。从后往前第一个非叶子结点开始调整。</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = length / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>    &#123;<br>        AdjustHeap(arr, i, length);<br>    &#125;<br><br>    <span class="hljs-comment">//将堆顶最大值移动到数组末端，再次从根结点开始调整构建最大堆。</span><br>    <span class="hljs-comment">//注意长度要-1，因为队尾的元素已经是排好序的。</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; length <span class="hljs-number">-1</span>; i++)<br>    &#123;<br>        Swap(arr, <span class="hljs-number">0</span>, length - <span class="hljs-number">1</span> - i);<br>        AdjustHeap(arr, <span class="hljs-number">0</span>, length - i - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 构建最大堆</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;arr&quot;&gt;</span>需要构建的数组<span class="hljs-doctag">&lt;/param&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;index&quot;&gt;</span>需要开始调整的结点下标<span class="hljs-doctag">&lt;/param&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;length&quot;&gt;</span>需要构建的数组长度<span class="hljs-doctag">&lt;/param&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AdjustHeap</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] arr, <span class="hljs-built_in">int</span> index, <span class="hljs-built_in">int</span> length</span>)</span><br>&#123;<br>    <span class="hljs-built_in">int</span> leftIndex = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;              <span class="hljs-comment">//左孩子结点下标</span><br>    <span class="hljs-built_in">int</span> rightIndex = index * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;             <span class="hljs-comment">//右孩子结点下标</span><br>    <span class="hljs-comment">//如果左孩子下标大于等于数组长，则说明其为叶子结点，不需要调整</span><br>    <span class="hljs-keyword">if</span> (leftIndex &gt;= length)                    <br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//找到左右结点最大值的下标</span><br>    <span class="hljs-built_in">int</span> maxIndex = leftIndex;<br>    <span class="hljs-keyword">if</span> (rightIndex &lt; length)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (arr[leftIndex] &lt; arr[rightIndex])<br>        &#123;<br>            maxIndex = rightIndex;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//如果孩子结点的值要大于父结点，则交换两个结点的值，</span><br>    <span class="hljs-comment">//并且从交换后的子结点继续向下调整</span><br>    <span class="hljs-keyword">if</span> (arr[maxIndex] &gt; arr[index])<br>    &#123;<br>        Swap(arr, maxIndex, index);<br>        AdjustHeap(arr, maxIndex, length);<br>    &#125;<br><br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Swap</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] arr, <span class="hljs-built_in">int</span> index1, <span class="hljs-built_in">int</span> index2</span>)</span><br>&#123;<br>    <span class="hljs-built_in">int</span> length = arr.Length;<br>    <span class="hljs-keyword">if</span> (index1 &gt;= length || index2 &gt;= length)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">int</span> temp = arr[index1];<br>    arr[index1] = arr[index2];<br>    arr[index2] = temp;<br>&#125;<br><br></code></pre></td></tr></table></figure>


<h4 id="7-归并排序"><a href="#7-归并排序" class="headerlink" title="7.归并排序"></a>7.归并排序</h4><p>归并排序是建立在归并操作上的一种有效，稳定的排序算法，该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。 将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。 若将两个有序表合并成一个有序表，称为二路归并。</p>
<p>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p>
<ul>
<li><p>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；</p>
</li>
<li><p>自下而上的迭代；</p>
</li>
</ul>
<p><strong>算法步骤</strong></p>
<ol>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li>
<li>重复步骤 3 直到某一指针达到序列尾；</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/0c66af0a2da0474d94384b06847ba235.gif" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MergeSort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] array1</span>)</span><br>        &#123;<br>            <span class="hljs-built_in">int</span> low = <span class="hljs-number">0</span>, heigh = array1.Length - <span class="hljs-number">1</span>;<br>            Mergesort(array1, low,  heigh);<br>        &#125;<br>           <br>           <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">Mergesort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] array1,<span class="hljs-built_in">int</span> low,<span class="hljs-built_in">int</span> heigh</span>)</span><br>        &#123;<br>            <br>  <br>            <span class="hljs-keyword">if</span> (low &lt; heigh)<br>            &#123;<br>               <span class="hljs-built_in">int</span> mid = (low+heigh) / <span class="hljs-number">2</span>;<br>                Mergesort(array1,low,mid);<br>                Mergesort(array1, mid + <span class="hljs-number">1</span>, heigh);<br>                BinaryMerge(array1,low,mid,heigh);<br>            &#125;<br>           <br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BinaryMerge</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] array, <span class="hljs-built_in">int</span> low,<span class="hljs-built_in">int</span> mid,<span class="hljs-built_in">int</span> height</span>)</span><br>        &#123;<br>            <span class="hljs-built_in">int</span>[] temparray = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[array.Length];<br>            <span class="hljs-built_in">int</span> left, right,index;<br>            <span class="hljs-comment">//复制数组</span><br>            <span class="hljs-keyword">for</span> (index = low; index &lt;= height; index++)<br>            &#123;<br>                temparray[index] = array[index];<br>            &#125;<br>          <br>            <span class="hljs-comment">//二路归并</span><br>            <span class="hljs-keyword">for</span> ( index= left = low,right=mid+<span class="hljs-number">1</span>;left&lt;=mid&amp;&amp; right &lt;= height &amp;&amp; index &lt;=height; index++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (temparray[left] &lt;= temparray[right]) &#123; array[index] = temparray[left++]; &#125;<br>                <span class="hljs-keyword">else</span> &#123; array[index] = temparray[right++]; &#125;<br>            &#125;<br>            <span class="hljs-comment">//检查那个部分没拷贝完成，将temparray剩余的部分拷贝到array数组中</span><br>            <span class="hljs-keyword">while</span> (left&lt;=mid) array[index++] = temparray[left++];<br>            <span class="hljs-keyword">while</span>(right&lt;=height) array[index++]=temparray[right++];<br>        &#125;<br>      <br></code></pre></td></tr></table></figure>

<h4 id="8-计数排序"><a href="#8-计数排序" class="headerlink" title="8.计数排序"></a>8.计数排序</h4><p><img src="https://img-blog.csdnimg.cn/9fbfeab31f384aad9329a49fe345f678.gif" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p>计数排序是一种适合于最大值和最小值的差值不是不是很大的排序。例如 temp[i] &#x3D; m, 表示元素 i 一共出现了 m 次</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CountSort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] arr</span>)</span><br> &#123;<br>     <span class="hljs-comment">//1.得到数列的最大值 和 最小值</span><br>     <span class="hljs-built_in">int</span> Max = arr[<span class="hljs-number">0</span>];<br>     <span class="hljs-built_in">int</span> Min = arr[<span class="hljs-number">0</span>];<br> <br>     <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; arr.Length; i++)<br>     &#123;<br>         <span class="hljs-keyword">if</span> (arr[i] &gt; Max) Max = arr[i];<br>         <span class="hljs-keyword">if</span> (arr[i] &lt; Min) Min = arr[i];<br>     &#125;<br>     <span class="hljs-comment">//2.根据数列最大值确定统计数组的长度</span><br>     <span class="hljs-built_in">int</span>[] newArr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[Max -Min+ <span class="hljs-number">1</span>];<br>     <span class="hljs-comment">//3.遍历数列，填充统计数组 记得加上 偏移量Min</span><br>     <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.Length; i++)<br>     &#123;<br>         newArr[arr[i]-Min]++;<br>     &#125;<br>     <span class="hljs-comment">//4.遍历统计数组，输出结果 记得加上 偏移量Min</span><br>     <span class="hljs-built_in">int</span> Index = <span class="hljs-number">0</span>;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; newArr.Length; i++)<br>     &#123;<br>         <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; newArr[i]; j++)<br>         &#123;<br>             arr[Index++] = i+Min;<br>         &#125;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure>

<h4 id="9-桶排序"><a href="#9-桶排序" class="headerlink" title="9.桶排序"></a>9.桶排序</h4><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p>
<p><strong>算法步骤</strong></p>
<ol>
<li>设置一个定量的数组当作空桶；</li>
<li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li>
<li>对每个不是空的桶进行排序；</li>
<li>从不是空的桶里把排好序的数据拼接起来。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/b7e8e42333e1432bb1a494d301c1c41e.gif" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 桶排序</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span> &#123;<br>        <span class="hljs-built_in">double</span>[] array = &#123; <span class="hljs-number">0.43</span>, <span class="hljs-number">0.69</span>, <span class="hljs-number">0.11</span>, <span class="hljs-number">0.72</span>, <span class="hljs-number">0.28</span>, <span class="hljs-number">0.21</span>, <span class="hljs-number">0.56</span>, <span class="hljs-number">0.80</span>, <span class="hljs-number">0.48</span>, <span class="hljs-number">0.94</span>, <span class="hljs-number">0.32</span>, <span class="hljs-number">0.08</span> &#125;;<br><br>        BucketSort(array, <span class="hljs-number">10</span>);<br>        ShowSord(array);<br><br>        Console.ReadKey();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ShowSord</span>(<span class="hljs-params"><span class="hljs-built_in">double</span>[] array</span>)</span> &#123;<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> num <span class="hljs-keyword">in</span> array) &#123;<br>            Console.Write(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;num&#125;</span> &quot;</span>);<br>        &#125;<br>        Console.WriteLine();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BucketSort</span>(<span class="hljs-params"><span class="hljs-built_in">double</span>[] array, <span class="hljs-built_in">int</span> bucketNum</span>)</span> &#123;<br>        <span class="hljs-comment">//创建bucket时，在二维中增加一组标识位，其中bucket[x, 0]表示这一维所包含的数字的个数</span><br>        <span class="hljs-comment">//通过这样的技巧可以少写很多代码</span><br>        <span class="hljs-built_in">double</span>[,] bucket = <span class="hljs-keyword">new</span> <span class="hljs-built_in">double</span>[bucketNum, array.Length + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> num <span class="hljs-keyword">in</span> array) &#123;<br>            <span class="hljs-built_in">int</span> bit = (<span class="hljs-built_in">int</span>)(<span class="hljs-number">10</span> * num);<br>            bucket[bit, (<span class="hljs-built_in">int</span>)++bucket[bit, <span class="hljs-number">0</span>]] = num;<br>        &#125;<br>        <span class="hljs-comment">//为桶里的每一行使用插入排序</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; bucketNum; j++) &#123;<br>            <span class="hljs-comment">//为桶里的行创建新的数组后使用插入排序</span><br>            <span class="hljs-built_in">double</span>[] insertion = <span class="hljs-keyword">new</span> <span class="hljs-built_in">double</span>[(<span class="hljs-built_in">int</span>)bucket[j, <span class="hljs-number">0</span>]];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> k = <span class="hljs-number">0</span>; k &lt; insertion.Length; k++) &#123;<br>                insertion[k] = bucket[j, k + <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-comment">//插入排序</span><br>            StraightInsertionSort(insertion);<br>            <span class="hljs-comment">//把排好序的结果回写到桶里</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> k = <span class="hljs-number">0</span>; k &lt; insertion.Length; k++) &#123;<br>                bucket[j, k + <span class="hljs-number">1</span>] = insertion[k];<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//将所有桶里的数据回写到原数组中</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> count = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; j &lt; bucketNum; j++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> k = <span class="hljs-number">1</span>; k &lt;= bucket[j, <span class="hljs-number">0</span>]; k++) &#123;<br>                array[count++] = bucket[j, k];<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">StraightInsertionSort</span>(<span class="hljs-params"><span class="hljs-built_in">double</span>[] array</span>)</span> &#123;<br>        <span class="hljs-comment">//插入排序</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; array.Length; i++) &#123;<br>            <span class="hljs-built_in">double</span> sentinel = array[i];<br>            <span class="hljs-built_in">int</span> j = i - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; sentinel &lt; array[j]) &#123;<br>                array[j + <span class="hljs-number">1</span>] = array[j];<br>                j--;<br>            &#125;<br>            array[j + <span class="hljs-number">1</span>] = sentinel;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>


<h4 id="10-基数排序"><a href="#10-基数排序" class="headerlink" title="10.基数排序"></a>10.基数排序</h4><p>基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数；</p>
<p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</p>
<p>基数相对于其他排序，算法逻辑和代码都相对简单。<br>代码方面，也都是和另外两个排序的顺序一致。<br>与另外两个非比较排序不同的是：<br>计数排序和桶排序是基于数组索引来的，所以只能排序整数<br>但是基于数的计数而定，所以在改造后，理论上是也可以排序非整数</p>
<p><strong>算法步骤</strong></p>
<ol>
<li><p>求最值，取得数组中的最大数，并取得位数；</p>
</li>
<li><p>初新组，此处新组是指新桶，桶大小为10(因为基数只有0-10)；</p>
</li>
<li><p>正填充，将对应基数的数字放到对应的桶中</p>
</li>
<li><p>将桶中的数据反填充到array数组中</p>
</li>
</ol>
<blockquote>
<p>注：正反填充需要进行循环，循环次数为步骤一的位数 </p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/de00f05f30634bf3aa413803b3f35d4b.gif" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span>[] <span class="hljs-title">RadixSort2</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] array</span>)</span><br>&#123;<br>    <span class="hljs-comment">//求最(大)值</span><br>    <span class="hljs-built_in">int</span> max = array[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> array)<br>    &#123;<br>        max = item &gt; max ? item : max;<br>    &#125;<br><br>    <span class="hljs-built_in">int</span> maxDigit = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(max!=<span class="hljs-number">0</span>)<br>    &#123;<br>        max /= <span class="hljs-number">10</span>;maxDigit++;<br>    &#125;<br>    <span class="hljs-comment">//初新桶</span><br>    <span class="hljs-keyword">var</span> bucket = <span class="hljs-keyword">new</span> List&lt;List&lt;<span class="hljs-built_in">int</span>&gt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        bucket.Add(<span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;());<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; maxDigit; i++)<br>    &#123;<br>        <span class="hljs-comment">//正填充</span><br>        <span class="hljs-built_in">int</span> div = (<span class="hljs-built_in">int</span>)Math.Pow(<span class="hljs-number">10</span>, (i + <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> array)<br>        &#123;<br>            <span class="hljs-comment">//获取基数</span><br>            <span class="hljs-built_in">int</span> radix = (item % div) / (div / <span class="hljs-number">10</span>);<br>            bucket[radix].Add(item);<br>        &#125;<br>        <span class="hljs-comment">//反填充（//反填充要注意顺序）</span><br>        <span class="hljs-built_in">int</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> bucket)<br>        &#123;<br>            <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> it <span class="hljs-keyword">in</span> item)<br>            &#123;<br>                array[index++] = it;                        <br>            &#125;<br>            item.Clear();<span class="hljs-comment">//清除数据</span><br>        &#125;                <br>    &#125;<br>    <span class="hljs-keyword">return</span> array;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/49a4114d2323450792d15706511acdf4.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/842750f7516f4a62aa62e32a07190c1d.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a target="_blank" rel="noopener" href="https://raindust.blog.csdn.net/article/details/104127820">C#十大排序算法</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/weiios/p/3933994.html">C#快速排序详解</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e4d0990dd0bd">排序算法2|简单选择排序与堆排序（C#）</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/cdaniu/p/16370507.html">【C# 排序】归并排序 merge sort</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/liuyi89430/article/details/107612559">C#计数排序</a><br><a target="_blank" rel="noopener" href="https://bbs.huaweicloud.com/blogs/313568">【愚公系列】2021年11月 C#版 数据结构与算法解析(桶排序)</a><br><a target="_blank" rel="noopener" href="https://www.freesion.com/article/96281055419/">C# 算法之基数排序排序(非比较排序之三)</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E9%9D%A2%E8%AF%95/" class="category-chain-item">面试</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Unity/">#Unity</a>
      
        <a href="/tags/C/">#C#</a>
      
        <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">#计算机网络</a>
      
        <a href="/tags/Lua/">#Lua</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Unity 客户端面试</div>
      <div>http://bmtan.cc/2023/02/01/Unity客户端面试/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Bmtan</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年2月1日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/07/30/AssetBundle%20%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD/" title="AssetBundle包 同步异步加载">
                        <span class="hidden-mobile">AssetBundle包 同步异步加载</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
