

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Bmtan">
  <meta name="keywords" content="">
  
    <meta name="description" content="设计模式设计模式概述设计模式共23种。主要分为三部分：创建型模式、机构型模式、行为型模式。 创建型模式：所有的模式都涉及到创建对象实例的方式。 结构型模式：如何组合类和对象以获得更大的结构。 行为型模式：通常和对象之间的通信有关。 创建型模式：简单工厂模式、工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式 工厂方法：提供了一个简单的决策类，它根据提供的数据返回一个抽象基类的多个子类中的一">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式">
<meta property="og:url" content="http://bmtan.cc/2022/06/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.html">
<meta property="og:site_name" content="Bmtan">
<meta property="og:description" content="设计模式设计模式概述设计模式共23种。主要分为三部分：创建型模式、机构型模式、行为型模式。 创建型模式：所有的模式都涉及到创建对象实例的方式。 结构型模式：如何组合类和对象以获得更大的结构。 行为型模式：通常和对象之间的通信有关。 创建型模式：简单工厂模式、工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式 工厂方法：提供了一个简单的决策类，它根据提供的数据返回一个抽象基类的多个子类中的一">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/UML%E4%BD%BF%E7%94%A8.png">
<meta property="og:image" content="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82UML.png">
<meta property="og:image" content="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95UML.png">
<meta property="og:image" content="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E7%BB%93%E6%9E%84%E5%9B%BE.png">
<meta property="og:image" content="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82Uml.png">
<meta property="og:image" content="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E7%BB%93%E6%9E%84%E5%9B%BE.png">
<meta property="og:image" content="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png">
<meta property="og:image" content="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png">
<meta property="og:image" content="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%B7%B1%E6%8B%B7%E8%B4%9D.png">
<meta property="og:image" content="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E7%BB%93%E6%9E%84%E5%9B%BE.png">
<meta property="article:published_time" content="2022-06-30T13:38:47.000Z">
<meta property="article:modified_time" content="2022-06-30T13:51:06.213Z">
<meta property="article:author" content="Bmtan">
<meta property="article:tag" content="C#">
<meta property="article:tag" content="设计模式">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/UML%E4%BD%BF%E7%94%A8.png">
  
  
  
  <title>设计模式 - Bmtan</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"bmtan.cc","root":"/","version":"1.9.0","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Bmtan blog&#39;s</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="设计模式"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-06-30 21:38" pubdate>
          2022年6月30日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          16k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          134 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">设计模式</h1>
            
            <div class="markdown-body">
              
              <h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="设计模式概述"><a href="#设计模式概述" class="headerlink" title="设计模式概述"></a>设计模式概述</h2><p>设计模式共<strong>23</strong>种。主要分为三部分：创建型模式、机构型模式、行为型模式。</p>
<p><strong>创建型模式：</strong>所有的模式都涉及到创建对象实例的方式。</p>
<p><strong>结构型模式：</strong>如何组合类和对象以获得更大的结构。</p>
<p><strong>行为型模式：</strong>通常和对象之间的通信有关。</p>
<p><strong>创建型模式：简单工厂模式、工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式</strong></p>
<p>工厂方法：提供了一个简单的决策类，它根据提供的数据返回一个抽象基类的多个子类中的一个。</p>
<p>抽象工厂：提供了一个创建并返回一些列相关对象的接口。</p>
<p>单例：某个类只能有一个实例。它提供了一个访问该实例的全局访问点。</p>
<p>建造者：将一个复杂的构建与它的表示分开，这样就能根据程序的需要创建不同的表现形式。</p>
<p>原型：先实例化一个类，然后拷贝或克隆该类来创建新的实例，可以用公有方法进一步修改这些实例。</p>
<p><strong>结构型模式：适配器模式、桥接模式、组合模式、装饰模式、外观模式、享元模式、代理模式</strong></p>
<p>适配器：将一个类的接口传换成另一个类的接口。</p>
<p>桥接：可以将一个类的接口与它的实现分离，这样可以不用修改客户端代码就能改变或替换实现过程。</p>
<p>组合：是一个对象的集合，其中的任何一个对象既可以是一个组合，也可以只是一个叶子对象。</p>
<p>装饰：用一个类包装给定的类，并为它添加新的功能，将所有未改动的方法传递给下面的类。</p>
<p>外观：将一系列复杂的对象放在一起，并提供一个新的、更简单的访问这些数据的接口。</p>
<p>享元：把一部分的类数据移到类外部，在执行方法时将数据传递进来，通过这种方式限制那些又小又相似的实例的增加数量。</p>
<p>代理：为一个比较复杂的对象提供一个简单的占位对象，实例化该复杂对象，在某种程度上比较浪费时间或代价较高。</p>
<p><strong>行为型模式：职责链、命令模式、（解释器模式？）、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、模板方法模式、访问者模式</strong></p>
<p>职责链：把请求从链中的一个对象传递到下一个对象，直到请求被响应为止。通过这种方式在对象之间去除耦合。</p>
<p>命令：用简单的对象表示软件命令的执行，支持登陆和取消操作。</p>
<p>解释器：提供一个如何把语言元素包含在程序中的定义。</p>
<p>迭代器：提供了一种顺序访问一个类中的一系列数据的方式。</p>
<p>中介者：定义了如何用一个对象简化对象之间的通信，是对象之间不必相互了解。</p>
<p>备忘录：定义了如何保存一个类实例的内容以便以后能恢复它。</p>
<p>观察者：定义了一种把改动通知给多个对象的方式。</p>
<p>状态：允许一个对象在其内部状态改变时修改它的行为。</p>
<p>策略：将算法封装到类里。</p>
<p>模板方法：提供了算法的抽象定义。</p>
<p>访问者：在不改变类的前提下，为一个类添加多种操作。</p>
<hr>
<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/UML%E4%BD%BF%E7%94%A8.png" srcset="/img/loading.gif" lazyload></p>
<p><strong><font color="FF0000">注意:</font></strong></p>
<p><strong><font color="ff0000">“+”表示public，”-“表示private，”#”表示protected</font></strong></p>
<p><strong><font color="FF0000">空心三角形+实线表示实现继承</font></strong></p>
<p><strong><font color="FF0000">空心三角形+虚线表示实现接口</font></strong></p>
<p><strong><font color="FF0000">关联关系用实线箭头</font></strong></p>
<p><strong><font color="FF0000">聚合关系用空心菱形+实线箭头</font></strong></p>
<p><strong><font color="FF0000">依赖关系用虚线箭头</font></strong></p>
<hr>
<h2 id="一、创建型设计模式"><a href="#一、创建型设计模式" class="headerlink" title="一、创建型设计模式"></a>一、创建型设计模式</h2><h3 id="①-简单工厂模式"><a href="#①-简单工厂模式" class="headerlink" title="① 简单工厂模式"></a>① 简单工厂模式</h3><h4 id="1、引言"><a href="#1、引言" class="headerlink" title="1、引言"></a>1、引言</h4><p>　　这个系列也是自己对设计模式的一些学习笔记,希望对一些初学设计模式的人有所帮助的,在上一个专题中介绍了单例模式,在这个专题中继续为大家介绍一个比较容易理解的模式——简单工厂模式。</p>
<h4 id="2、简单工厂模式的介绍"><a href="#2、简单工厂模式的介绍" class="headerlink" title="2、简单工厂模式的介绍"></a>2、简单工厂模式的介绍</h4><p>　　说到简单工厂，自然的第一个疑问当然就是什么是简单工厂模式了？ 在现实生活中工厂是负责生产产品的,同样在设计模式中,简单工厂模式我们也可以理解为负责<strong>生产对象的一个类</strong>, 我们平常编程中，当使用”new”关键字创建一个对象时，此时该类就依赖与这个对象，也就是他们之间的耦合度高，当需求变化时，我们就不得不去修改此类的源码，此时我们可以运用面向对象（OO）的很重要的原则去解决这一的问题，该原则就是——<font color="#FF0000">封装改变，既然要封装改变，自然也就要找到改变的代码，然后把改变的代码用类来封装</font>，这样的一种思路也就是我们简单工厂模式的实现方式了。下面通过一个现实生活中的例子来引出简单工厂模式。</p>
<h4 id="3、实现"><a href="#3、实现" class="headerlink" title="3、实现"></a>3、实现</h4><p><strong>简单工厂类：</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c#"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">OperationFactory</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Operation <span class="hljs-title">createOperate</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> operate</span>)</span><br>    &#123;<br>     	Operation oper=<span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">switch</span>(operate)<br>        &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span>:<br>                oper = <span class="hljs-keyword">new</span> OperationAdd();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span>:<br>                oper = <span class="hljs-keyword">new</span> OpeationSub();<br>            	<span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*&quot;</span>:<br>                oper = <span class="hljs-keyword">new</span> OperationMul();<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/&quot;</span>:<br>                oper = <span class="hljs-keyword">new</span> OperationDiv();<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> oper;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82UML.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="4、优点与缺点"><a href="#4、优点与缺点" class="headerlink" title="4、优点与缺点"></a>4、优点与缺点</h4><p>​	<strong>1.主要优点</strong></p>
<p>​    简单工厂模式的主要优点如下：</p>
<p>​    (1) 工厂类包含必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的职责，而仅仅“消费”产品，简单工厂模式实现了对象创建和使用的分离。</p>
<p>​    (2) 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以在一定程度减少使用者的记忆量。</p>
<p>​    (3) 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。</p>
<p>​     <strong>2. 主要缺点</strong></p>
<p>​    简单工厂模式的主要缺点如下：</p>
<p>​    (1) 由于工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响。</p>
<p>​    (2) 使用简单工厂模式势必会增加系统中类的个数（引入了新的工厂类），增加了系统的复杂度和理解难度。</p>
<p>​    (3) 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。</p>
<p>​    (4) 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。</p>
<hr>
<h3 id="②-工厂方法模式"><a href="#②-工厂方法模式" class="headerlink" title="② 工厂方法模式"></a>② 工厂方法模式</h3><h4 id="1、引言-1"><a href="#1、引言-1" class="headerlink" title="1、引言"></a>1、引言</h4><p>　　<strong>工厂方法模式(Factory Method Pattern)：</strong>定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。工厂方法模式又简称为工厂模式(Factory Pattern)，又可称作虚拟构造器模式(Virtual Constructor Pattern)或多态工厂模式(Polymorphic Factory Pattern)。工厂方法模式是一种类创建型模式。</p>
<h4 id="2、工厂方法模式的介绍"><a href="#2、工厂方法模式的介绍" class="headerlink" title="2、工厂方法模式的介绍"></a>2、工厂方法模式的介绍</h4><p>　　工厂方法模式之所以可以解决简单工厂的模式，是因为它的实现把具体产品的创建推迟到子类中，此时工厂类不再负责所有产品的创建，而只是给出具体工厂必须实现的接口，这样工厂方法模式就可以允许系统不修改工厂类逻辑的情况下来添加新产品，这样也就克服了简单工厂模式中缺点。</p>
<h4 id="3、实现-1"><a href="#3、实现-1" class="headerlink" title="3、实现"></a>3、实现</h4><div align="center"><b>工厂方法UML</b></div>


<p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95UML.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>&#x2F;&#x2F;工厂接口</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">interface</span> <span class="hljs-title">IFactory</span><br>&#123;<br>    <span class="hljs-function">Operation <span class="hljs-title">CreateOperation</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>加减乘除各间一个具体工厂去实现这个接口</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">AddFactory</span>:<span class="hljs-title">IFactory</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Operation <span class="hljs-title">CreateOperation</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> OperationAdd();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">SubFactory</span>:<span class="hljs-title">IFactory</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Operation <span class="hljs-title">CreateOperation</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> OperationSub();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">MulFactory</span>:<span class="hljs-title">IFactory</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Operation <span class="hljs-title">CreateOperation</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> OperationMul();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">DivFactory</span>:<span class="hljs-title">IFactory</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Operation <span class="hljs-title">CreateOperation</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> OperationDiv();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>客户端实现</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C#">IFactory operFactory=<span class="hljs-keyword">new</span> AddFactory();<br>Operation oper=operFactory.CreatOperation();<br>oper.NumberA=<span class="hljs-number">1</span>;<br>oper.NumberB=<span class="hljs-number">2</span>;<br><span class="hljs-built_in">double</span> result=oper.GetResult;<br></code></pre></td></tr></table></figure>

<div align="center"><b>工厂方法结构图</b></div>


<p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E7%BB%93%E6%9E%84%E5%9B%BE.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="4、优点与缺点-1"><a href="#4、优点与缺点-1" class="headerlink" title="4、优点与缺点"></a>4、优点与缺点</h4><p>​	<strong>1.主要优点</strong></p>
<p>​    工厂方法模式的主要优点如下：</p>
<p>​    (1) 在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。</p>
<p>​    (2) 基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够让工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，就正是因为所有的具体工厂类都具有同一抽象父类。</p>
<p>​    (3) 使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改<strong>抽象工厂</strong>和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了，这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。</p>
<p>​	<strong>2.主要缺点</strong></p>
<p>   工厂方法模式的主要缺点如下：</p>
<p>   (1) 在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。</p>
<p>   (2) 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。</p>
<h4 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h4><p><strong>工厂方法模式(Factory Method)</strong>,定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。</p>
<hr>
<h3 id="③-抽象工厂模式"><a href="#③-抽象工厂模式" class="headerlink" title="③ 抽象工厂模式"></a>③ 抽象工厂模式</h3><h4 id="1、引言-2"><a href="#1、引言-2" class="headerlink" title="1、引言"></a>1、引言</h4><p>​		工厂方法模式是为了克服简单工厂模式的缺点而设计出来的,简单工厂模式的工厂类随着产品类的增加需要增加额外的代码），而工厂方法模式每个具体工厂类只完成单个实例的创建,所以它具有很好的可扩展性。但是在现实生活中，一个工厂只创建单个产品这样的例子很少，因为现在的工厂都多元化了，一个工厂创建一系列的产品，如果我们要设计这样的系统时，工厂方法模式显然在这里不适用，然后抽象工厂模式却可以很好地解决一系列产品创建的问题</p>
<h4 id="2、抽象工厂模式的介绍"><a href="#2、抽象工厂模式的介绍" class="headerlink" title="2、抽象工厂模式的介绍"></a>2、抽象工厂模式的介绍</h4><p>​		抽象工厂模式：<strong>提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，它是一种对象创建型模式。</strong></p>
<h4 id="3、实现-2"><a href="#3、实现-2" class="headerlink" title="3、实现"></a>3、实现</h4><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82Uml.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>IDepartment接口，用于客户端访问，解除与具体数据库访问的耦合</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">interface</span> <span class="hljs-title">IDepartment</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span>(<span class="hljs-params">Department department</span>)</span>;<br>    <br>    <span class="hljs-function">Department <span class="hljs-title">GetDepartment</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> id</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>SqlseverDepartment类，用于访问SQL sever的Department</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlserverDepartment</span> : <span class="hljs-title">Ideparment</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span>(<span class="hljs-params">Department department</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;在Sql server中给Department 表增加一条记录&quot;</span>)<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Department <span class="hljs-title">GetDepartment</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> id</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;在Sql sever中根据Id得到Department 表一条记录&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>AccessDeapartment类，用于访问Acces的Department.</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">AccessDepartment</span> :<span class="hljs-title">IDepartment</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span>(<span class="hljs-params">Department department</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;在Acess中给Department 表增加一条记录&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Department <span class="hljs-title">GetDepartment</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> id</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;在Acess中根据Id得到Department 表一条记录&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>IFactory接口，定义一个创建访问User表对象的抽象的工厂接口</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">interface</span> <span class="hljs-title">IFactory</span><br>&#123;<br>    <span class="hljs-function">IUser <span class="hljs-title">CreateUser</span>()</span>;<br>    <span class="hljs-function">IDepartment <span class="hljs-title">CreateDepartment</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>SqlSeverFactory类，实现IFactory接口，实现SqlseverUser和SqlserverDepartment</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlseverFactory</span>:<span class="hljs-title">IFactory</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IUser <span class="hljs-title">CreateUser</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SqlseverUser();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IDepartment <span class="hljs-title">CreateDepartment</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SqlseverDepartment();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>AccessFactory类，实现IFactory接口，实现AccessrUser和AccessDepartment</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">AccessFactory</span>:<span class="hljs-title">IFactory</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IUser <span class="hljs-title">CreateUser</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AccessrUser();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IDepartment <span class="hljs-title">CreateDepartment</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AccessDepartment();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>客户端代码</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&#123;<br>    User user = <span class="hljs-keyword">new</span> User();<br>    Department dept=<span class="hljs-keyword">new</span> Department();<br>    <span class="hljs-comment">//IFactory factory= new SqlseverFactory();</span><br>    IFactory factory= <span class="hljs-keyword">new</span> AccessFactory();<br>    <br>    IUser iu=factory.CreateUser();<br>    <br>    iu.Insert(user);<br>    iu.GetUser(dept);<br>    id.GetDepartment(<span class="hljs-number">1</span>);<br>    <br>    Console.Read();<br>&#125;<br></code></pre></td></tr></table></figure>


<p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E7%BB%93%E6%9E%84%E5%9B%BE.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="4、优点与缺点-2"><a href="#4、优点与缺点-2" class="headerlink" title="4、优点与缺点"></a>4、优点与缺点</h4><p>​	<strong>1.主要优点</strong></p>
<p>​    抽象工厂模式的主要优点如下：</p>
<p>​    (1) 抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易，所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。</p>
<p>​    (2) 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。</p>
<p>​    (3) 增加新的产品族很方便，无须修改已有系统，符合“开闭原则”。</p>
<p>​    <strong>2. 主要缺点</strong></p>
<p>​    抽象工厂模式的主要缺点如下：</p>
<p>​    增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了“开闭原则”。</p>
<h4 id="5、总结-1"><a href="#5、总结-1" class="headerlink" title="5、总结"></a>5、总结</h4><p><strong>抽象工厂模式</strong>，提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。</p>
<hr>
<h3 id="④单例设计模式"><a href="#④单例设计模式" class="headerlink" title="④单例设计模式"></a>④单例设计模式</h3><h4 id="1、引言-3"><a href="#1、引言-3" class="headerlink" title="1、引言"></a>1、引言</h4><p>​		单例”字面意思上理解为——一个类只有一个实例，所以单例模式也就是<font color="FF0000"><strong>保证一个类只有一个实例的一种实现方法</strong></font>，单例模式的一个官方定义：<strong>确保一个类只有一个实例,并提供一个全局访问点。</strong></p>
<h4 id="2、单例设计模式介绍"><a href="#2、单例设计模式介绍" class="headerlink" title="2、单例设计模式介绍"></a>2、单例设计模式介绍</h4><p>​		<strong>单例模式（Singleton）</strong>，保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<p>​		“通常我们可以让一个全局变量是的一个对象被访问，但它不能防止你实例化多个对象。一个最好办法就是，让类自身负责保存它的唯一实例。这个类可以保证有没有其他实例可以被创建，并且它可以提供一个访问该实例的方法。</p>
<p>​		<strong>单例模式因为Singleton类封装它的唯一实例，这样它可以严格控制客户怎样访问它以及何时访问它。简单地说就是对唯一实例的受控访问。</strong></p>
<h4 id="3、实现-3"><a href="#3、实现-3" class="headerlink" title="3、实现"></a>3、实现</h4><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>Singleton类，定义一个GetInstance操作，允许客户访问它的唯一实例。GetInstance 是一个静态方法，主要负责创建自己的唯一实例。</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span>()</span><br>    &#123;<br>        <span class="hljs-comment">//构造方法让其private,这就毒死了外界利用new创建此类实例的可能</span><br>    &#125;<br>    <br>    <span class="hljs-comment">//此方法是获得本类实例的唯一全局访问点</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">GetInstance</span>()</span><br>    &#123;<br>        <span class="hljs-comment">//若实例不存在，则new一个新实例，否则返回已有的实例</span><br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)<br>        &#123;<br>            instance = <span class="hljs-keyword">new</span> Sington();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instacne;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>客户端代码</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&#123;<br>    Singleton s1 = Singleton.GetInstance();<br>    Singleton s2 = Singleton.GetInstance();<br>    <br>    <span class="hljs-keyword">if</span>(s1==s2)<br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;两个对象是相同的实例&quot;</span>);<br>    &#125;<br>    Console.Read();<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="4、多线程使用单例模式所引发的问题"><a href="#4、多线程使用单例模式所引发的问题" class="headerlink" title="4、多线程使用单例模式所引发的问题"></a>4、多线程使用单例模式所引发的问题</h4><p>上面的单例模式的实现在单线程下确实是完美的,然而在多线程的情况下会得到多个Singleton实例,因为在两个线程同时运行GetInstance方法时，此时两个线程判断(uniqueInstance &#x3D;&#x3D;null)这个条件时都返回真，此时两个线程就都会创建Singleton的实例，这样就违背了我们单例模式初衷了，既然上面的实现会运行多个线程执行，那<strong>我们对于多线程的解决方案自然就是使GetInstance方法在同一时间只运行一个线程运行就好了</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span><br>    &#123;<br>        <span class="hljs-comment">// 定义一个静态变量来保存类的实例</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;<br><br>        <span class="hljs-comment">// 定义一个标识确保线程同步</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">object</span> locker = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>();<br><br>        <span class="hljs-comment">// 定义私有构造函数，使外界不能创建该类实例</span><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span>()</span><br>        &#123;<br>        &#125;<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 定义公有方法提供一个全局访问点,同时你也可以定义公有属性来提供全局访问点</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>       <br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">GetInstance</span>()</span><br>        &#123;<br>            <span class="hljs-comment">// 当第一个线程运行到这里时，此时会对locker对象 &quot;加锁&quot;，</span><br>            <span class="hljs-comment">// 当第二个线程运行该方法时，首先检测到locker对象为&quot;加锁&quot;状态，该线程就会挂起等待第一个线程解锁</span><br>            <span class="hljs-comment">// lock语句运行完之后（即线程运行完之后）会对该对象&quot;解锁&quot;</span><br>            <span class="hljs-keyword">lock</span> (locker)<br>            &#123;<br>                <span class="hljs-comment">// 如果类的实例不存在则创建，否则直接返回</span><br>                <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>)<br>                &#123;<br>                    uniqueInstance = <span class="hljs-keyword">new</span> Singleton();<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> uniqueInstance;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>上面这种解决方案确实可以解决多线程的问题,但是**上面代码对于每个线程都会对线程辅助对象locker加锁之后再判断实例是否存在，对于这个操作完全没有必要的，因为当第一个线程创建了该类的实例之后，后面的线程此时只需要直接判断（uniqueInstance&#x3D;&#x3D;null）为假，此时完全没必要对线程辅助对象加锁之后再去判断，所以上面的实现方式增加了额外的开销，损失了性能，为了改进上面实现方式的缺陷，我们只需要在lock语句前面加一句（uniqueInstance&#x3D;&#x3D;null）的判断就可以避免锁所增加的额外开销，这种实现方式我们就叫它 <font color="FF0000">“双重锁定”</font>**，下面具体看看实现代码的：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span><br>   &#123;<br>       <span class="hljs-comment">// 定义一个静态变量来保存类的实例</span><br>       <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;<br><br>       <span class="hljs-comment">// 定义一个标识确保线程同步</span><br>       <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">object</span> locker = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>();<br><br>       <span class="hljs-comment">// 定义私有构造函数，使外界不能创建该类实例</span><br>       <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span>()</span><br>       &#123;<br>       &#125;<br><br>       <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>       <span class="hljs-comment"><span class="hljs-doctag">///</span> 定义公有方法提供一个全局访问点,同时你也可以定义公有属性来提供全局访问点</span><br>       <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">GetInstance</span>()</span><br>       &#123;<br>           <span class="hljs-comment">// 当第一个线程运行到这里时，此时会对locker对象 &quot;加锁&quot;，</span><br>           <span class="hljs-comment">// 当第二个线程运行该方法时，首先检测到locker对象为&quot;加锁&quot;状态，该线程就会挂起等待第一个线程解锁</span><br>           <span class="hljs-comment">// lock语句运行完之后（即线程运行完之后）会对该对象&quot;解锁&quot;</span><br>           <span class="hljs-comment">// 双重锁定只需要一句判断就可以了</span><br>           <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>)<br>           &#123;<br>               <span class="hljs-keyword">lock</span> (locker)<br>               &#123;<br>                   <span class="hljs-comment">// 如果类的实例不存在则创建，否则直接返回</span><br>                   <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>)<br>                   &#123;<br>                       uniqueInstance = <span class="hljs-keyword">new</span> Singleton();<br>                   &#125;<br>               &#125;<br>           &#125;<br>           <span class="hljs-keyword">return</span> uniqueInstance;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>

<h4 id="5、C-中实现了单例模式的类"><a href="#5、C-中实现了单例模式的类" class="headerlink" title="5、C#中实现了单例模式的类"></a>5、C#中实现了单例模式的类</h4><p>经过查看，.NET类库中确实存在单例模式的实现类，不过该类不是公开的，下面就具体看看该类的一个实现的(该类具体存在于System.dll程序集，命名空间为System,可以用反射工具Reflector去查看源码的):</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SR</span><br>    &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SR loader;<br>        <span class="hljs-function"><span class="hljs-keyword">internal</span> <span class="hljs-title">SR</span>()</span><br>        &#123;<br>        &#125;<br>        <span class="hljs-comment">// 主要是因为该类不是公有，所以这个全部访问点也定义为私有的了</span><br>        <span class="hljs-comment">// 但是思想还是用到了单例模式的思想的</span><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SR <span class="hljs-title">GetLoader</span>()</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (loader == <span class="hljs-literal">null</span>)<br>            &#123;<br>                SR sr = <span class="hljs-keyword">new</span> SR();<br>                Interlocked.CompareExchange&lt;SR&gt;(<span class="hljs-keyword">ref</span> loader, sr, <span class="hljs-literal">null</span>);<br>            &#125;<br>            <span class="hljs-keyword">return</span> loader;<br>        &#125;<br><br>        <span class="hljs-comment">// 这个公有方法中调用了GetLoader方法的</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">object</span> <span class="hljs-title">GetObject</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span><br>        &#123;<br>            SR loader = GetLoader();<br>            <span class="hljs-keyword">if</span> (loader == <span class="hljs-literal">null</span>)<br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> loader.resources.GetObject(name, Culture);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<h4 id="6、总结"><a href="#6、总结" class="headerlink" title="6、总结"></a>6、总结</h4><p><strong>单例模式（Singleton）</strong>，保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<hr>
<h3 id="⑤原型设计模式"><a href="#⑤原型设计模式" class="headerlink" title="⑤原型设计模式"></a>⑤原型设计模式</h3><h4 id="1、引言-4"><a href="#1、引言-4" class="headerlink" title="1、引言"></a>1、引言</h4><p>​		在软件系统中，当创建一个类的实例的过程很昂贵或很复杂，并且我们需要创建多个这样类的实例时，如果我们用new操作符去创建这样的类实例，这未免会增加创建类的复杂度和耗费更多的内存空间，因为这样在内存中分配了多个一样的类实例对象，然后如果采用工厂模式来创建这样的系统的话，随着产品类的不断增加，导致子类的数量不断增多，反而增加了系统复杂程度，所以在这里使用工厂模式来封装类创建过程并不合适，然而原型模式可以很好地解决这个问题，因为每个类实例都是相同的，当我们需要多个相同的类实例时，没必要每次都使用new运算符去创建相同的类实例对象，此时我们一般思路就是想——只创建一个类实例对象，如果后面需要更多这样的实例，可以通过对原来对象拷贝一份来完成创建，这样在内存中不需要创建多个相同的类实例，从而减少内存的消耗和达到类实例的复用。然而这个思路正是<strong>原型模式</strong>的实现方式。</p>
<h4 id="2、原型设计模式介绍"><a href="#2、原型设计模式介绍" class="headerlink" title="2、原型设计模式介绍"></a>2、原型设计模式介绍</h4><p><strong>原型模式（prototype）</strong>，用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象</p>
<p>在现实生活中，也有很多原型设计模式的例子，例如，细胞分裂的过程，一个细胞的有丝分裂产生两个相同的细胞；还有西游记中孙悟空变出后孙的本领和火影忍者中鸣人的隐分身忍术，写多份简历等。</p>
<h4 id="3、实现-4"><a href="#3、实现-4" class="headerlink" title="3、实现"></a>3、实现</h4><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>原型类</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Prototype</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> id;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Prototype</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> id</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.id=id;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Id<br>    &#123;<br>        <span class="hljs-keyword">get</span>&#123;<span class="hljs-keyword">return</span> id;&#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">//抽象类的关键就是有这样一个Clone方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Prototype <span class="hljs-title">Clone</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>具体原型类</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcretePrototype</span> : <span class="hljs-title">Prototype</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcretePrototype</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> id</span>):<span class="hljs-title">base</span>(<span class="hljs-params">id</span>)</span><br>    &#123;<br>        <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> Prototype <span class="hljs-title">clone</span>()</span><br>    &#123;<br>        <span class="hljs-comment">//创建当前对象的浅表副本。方法时创建一个新对象，然后将当前对象的非静态字段复制到该新对象。如果字段时值类型的，则对该字段执行逐位复制。如果字段是引用类型，则复制引用但不复制引用的对象；因此，原始对象及其副本引用同一对象</span><br>        <span class="hljs-keyword">return</span> (Prototype)<span class="hljs-keyword">this</span>.MemberWiseClone();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>客户端代码</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&#123;<br>    ConcretePrototype p1= <span class="hljs-keyword">new</span> ConcretePrototype(<span class="hljs-string">&quot;I&quot;</span>);<br>    <span class="hljs-comment">//克隆类ConcretePrototype的对象p1就能得到新得实例c1</span><br>    ConcretePrototype c1= <span class="hljs-keyword">new</span> (ConcretePrototype)p1.Clone();<br>    Console.WriteLine(<span class="hljs-string">&quot;Clonded:&#123;0&#125;&quot;</span>,c1.Id);<br>    Console.Read();<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="4、浅拷贝和深拷贝"><a href="#4、浅拷贝和深拷贝" class="headerlink" title="4、浅拷贝和深拷贝"></a>4、浅拷贝和深拷贝</h4><p><strong>MemberwiseClone</strong>方法创建一个<strong>浅表副本</strong>，方法是创建一个新对象，然后将当前对象的非静态字段复制到该新对象。如果字段是<strong>值类型的，则对该字段执行逐位复制</strong>。如果字段是<strong>引用类型，则复制引用单不复制引用的对象</strong>；因此原始对象及其副本引用同一对象。</p>
<p>例如，考虑引用对象A和B的被称为X的对象。对象B依次引用对象C。X的浅表副本创建一个新对象X2，该对象也引用对象A和B。相比而言，X的深层副本创建一个新对象X2，该对象引用新对象A2和B2（人别为A和B的副本）。B2有引用新对象C2，C2是C的副本。该实例阐释了千层和深层复制操作之间的区别。</p>
<p>有很多方法可以实现深层复制操作，前提是浅表赋值操作有MemberwiseClone方法执行但不符合您的要求。这些要求包括：</p>
<ul>
<li>调用要复制的对象的构造函数以创建含有从第一个对象中提出的属性值的第二个对象。这假定对象的值完全由类构造函数定义。</li>
<li>调用MemberwiseClone方法创建的对象的浅表副本，然后将指定新的对象，其值均相同，院士对象的任何属性或字段的值是引用类型。该实例中的DeepCopy方法阐释了这种方法。</li>
<li>序列化要深层复制的对象，然后将序列化的数据还原到另一个对象变量。</li>
<li>使用带递归的反射执行的深层复制操作。</li>
</ul>
<p>下面的实力掩饰MemberwiseClone方法。它定义了ShallowCopy方法，该方法通过调用MemberwiseClone方法来在Person对象上执行浅表复制操作。他还定义了在Person对象上执行深层复制操作的DeepCopy方法。</p>
<p><strong>深拷贝</strong>把引用对象的变量指向复制过的新对象，而不是原有的被引用的对象。</p>
<div align="center"><b>简历的深拷贝复制实现</b></div>

<p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%B7%B1%E6%8B%B7%E8%B4%9D.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>工作经历类</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//让工作经历实现ICloneable接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">WorkExperinece</span>:<span class="hljs-title">ICloneable</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> workDate;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> WorkDate<br>    &#123;<br>        <span class="hljs-keyword">get</span>;<br>        <span class="hljs-keyword">set</span>;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> company;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Company<br>    &#123;<br>        <span class="hljs-keyword">get</span>;<br>        <span class="hljs-keyword">set</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">Clone</span>()</span><br>    &#123;<br>        <span class="hljs-comment">//&quot;工作经历&quot;类实现克隆方法</span><br>        <span class="hljs-keyword">return</span> (Object)<span class="hljs-keyword">this</span>.MemberwiseColne();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>简历类</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">Resume</span> : <span class="hljs-title">Icloneable</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> sex;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> age;<br>    <span class="hljs-keyword">private</span> Workexperience work;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Resume</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.name=name;<br>        work=<span class="hljs-keyword">new</span> WorkExperience();<br>    &#125;<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Resume</span>(<span class="hljs-params">WorkExperience work</span>)</span><br>    &#123;<br>        <span class="hljs-comment">//提供Clone方法调用的私有构造函数，以便克隆&quot;工作经历&quot;的数据</span><br>        <span class="hljs-keyword">this</span>.work=(WorkExperience)work.Clone();<br>    &#125;<br>    <span class="hljs-comment">//设置个人信息</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetPersonalInfo</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> sex,<span class="hljs-built_in">string</span> age</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.sex=sex;<br>        <span class="hljs-keyword">this</span>.age=age;<br>    &#125;<br>    <span class="hljs-comment">//设置工作经历</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetWorkExperience</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> workDate,<span class="hljs-built_in">string</span> company</span>)</span><br>    &#123;<br>        work.WorkDate=workDate;<br>        work.Company=company<br>    &#125;<br>    <span class="hljs-comment">//显示</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Display</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;&#123;0&#125;&#123;1&#125;&#123;2&#125;&quot;</span>,name,sex,gae);<br>        Console.WriteLine(<span class="hljs-string">&quot;工作经历：&#123;0&#125;&#123;1&#125;&quot;</span>,work.WorkDate,work.Company);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//调用私有的构造方法，让“工作经历”克隆完成，然后再给这个“简历”对象的相关字段赋值，最终返回一个深拷贝的简历对象</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">Clone</span>()</span><br>&#123;<br>    Resume obj=<span class="hljs-keyword">new</span> Resume(<span class="hljs-keyword">this</span>.work);<br>    obj.name=<span class="hljs-keyword">this</span>.name;<br>    obj.sex=<span class="hljs-keyword">this</span>.sex;<br>    obj.age=<span class="hljs-keyword">this</span>.age;<br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure>





<h4 id="5、优点和缺点"><a href="#5、优点和缺点" class="headerlink" title="5、优点和缺点"></a>5、优点和缺点</h4><p><strong>原型模式的优点有：</strong></p>
<ol>
<li>原型模式向客户隐藏了创建新实例的复杂性</li>
<li>原型模式允许动态增加或较少产品类。</li>
<li>原型模式简化了实例的创建结构，工厂方法模式需要有一个与产品类等级结构相同的等级结构，而原型模式不需要这样。</li>
<li>产品类不需要事先确定产品的等级结构，因为原型模式适用于任何的等级结构</li>
</ol>
<p><strong>原型模式的缺点有：</strong></p>
<ol>
<li>每个类必须配备一个克隆方法</li>
<li>配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。</li>
</ol>
<h4 id="6、总结-1"><a href="#6、总结-1" class="headerlink" title="6、总结"></a>6、总结</h4><p><strong>原型模式（prototype）</strong>，用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象</p>
<hr>
<h3 id="⑥建造者设计模式"><a href="#⑥建造者设计模式" class="headerlink" title="⑥建造者设计模式"></a>⑥建造者设计模式</h3><h4 id="1、引言-5"><a href="#1、引言-5" class="headerlink" title="1、引言"></a>1、引言</h4><p>​		在软件系统中，有时需要创建一个复杂对象，并且这个复杂对象由其各部分子对象通过一定的步骤组合而成。例如一个采购系统中，如果需要采购员去采购一批电脑时，在这个实际需求中，电脑就是一个复杂的对象，它是由CPU、主板、硬盘、显卡、机箱等组装而成的，如果此时让采购员一台一台电脑去组装的话真是要累死采购员了，这里就可以采用建造者模式来解决这个问题，我们可以把电脑的各个组件的组装过程封装到一个建造者类对象里，建造者只要负责返还给客户端全部组件都建造完毕的产品对象就可以了。然而现实生活中也是如此的，如果公司要采购一批电脑，此时采购员不可能自己去买各个组件并把它们组织起来，此时采购员只需要像电脑城的老板说自己要采购什么样的电脑就可以了，电脑城老板自然会把组装好的电脑送到公司。</p>
<h4 id="2、建造者设计模式介绍"><a href="#2、建造者设计模式介绍" class="headerlink" title="2、建造者设计模式介绍"></a>2、建造者设计模式介绍</h4><p>​		如果需要<strong>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</strong>的意图的时候，我们需要应用于一个设计模式，‘<strong>建造者（Builder）模式</strong>’，又称叫生成器模式叫生成器模式。建造者模式可以将一个产品的内部表象与产品的生成过程分割开来，从而可以使一个建造过程生成具有不同的内部表象的产品对象。<strong>如果我们用了建造者模式，那么用户就只需指定需要建造的类型就可以得到它们，而具体建造的过程和细节就不需知道了</strong>。</p>
<p>​		<strong>建造者模式是在当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方法时适用的模式</strong></p>
<h4 id="3、实现-5"><a href="#3、实现-5" class="headerlink" title="3、实现"></a>3、实现</h4><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E7%BB%93%E6%9E%84%E5%9B%BE.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>Product类——产品类，由多个部件组成</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">Product</span><br>&#123;<br>    IList&lt;<span class="hljs-built_in">string</span>&gt; parts=<span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">string</span>&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> part</span>)</span><br>    &#123;<br>    	parts.Add(part);    <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Show</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;\n 产品 创建 ——&quot;</span>);<br>        <span class="hljs-keyword">foreach</span>(<span class="hljs-built_in">string</span> part <span class="hljs-keyword">in</span> parts)<br>        &#123;<br>            Console.WriteLine(part);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>Bulider类——抽象建造者类，确定产品由两个部件PartA和PartB组成，并声明一个得到产品建造后结果的方法GetResult</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPartA</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BulidPartB</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Product <span class="hljs-title">GetResult</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>ConcreteBuilder类——具体建造者类</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteBuilder</span> :<span class="hljs-title">Builder</span><br>&#123;<br>    <span class="hljs-keyword">private</span> Product porduct =<span class="hljs-keyword">new</span> Product();<br>    <br>    <span class="hljs-comment">//建造具体的两个部件A和B</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPartA</span>()</span><br>    &#123;<br>        product.Add(<span class="hljs-string">&quot;部件A&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPartB</span>()</span><br>    &#123;<br>        product.Add(<span class="hljs-string">&quot;部件B&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> Product <span class="hljs-title">GetResult</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> product;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>ConcreteBuilder2类——具体建造者类</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteBuilder2</span> :<span class="hljs-title">Builder</span><br>&#123;<br>    <span class="hljs-keyword">private</span> Product porduct =<span class="hljs-keyword">new</span> Product();<br>    <br>    <span class="hljs-comment">//建造具体的两个部件A和B</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPartA</span>()</span><br>    &#123;<br>        product.Add(<span class="hljs-string">&quot;部件X&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPartB</span>()</span><br>    &#123;<br>        product.Add(<span class="hljs-string">&quot;部件Y&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> Product <span class="hljs-title">GetResult</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> product;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>Director类——指挥者类</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">Director</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Coonstruct</span>(<span class="hljs-params">Builder builder</span>)</span><br>    &#123;<br>        <span class="hljs-comment">//用来指挥建造过程</span><br>        builder.BuildPartA();<br>        builder.BuildPartB();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>客户端代码，客户不需知道具体的建造过程</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&#123;<br>    Director dircetor =<span class="hljs-keyword">new</span> Dircetor();<br>    Builder b1 = <span class="hljs-keyword">new</span> ConcreteBuilder1();<br>    Builder b2 = <span class="hljs-keyword">new</span> ConcreteBuilder2();<br>    <br>    <span class="hljs-comment">//指挥者用ConcreteBuilder1和ConcreteBuilder2的方法来建造产品</span><br>    director.Construct(b1);<br>    Product p1 = b1.GetResult();<br>    p1.Show();<br>    <br>    director.Construct(b2);<br>    Product p2 = b2.GetResult();<br>    p2.Show();<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h4><p><strong>建造者（Builder）模式</strong>，将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</p>
<hr>
<h2 id="二、结构型设计模式"><a href="#二、结构型设计模式" class="headerlink" title="二、结构型设计模式"></a>二、结构型设计模式</h2><h2 id="三、行为型设计模式"><a href="#三、行为型设计模式" class="headerlink" title="三、行为型设计模式"></a>三、行为型设计模式</h2>
              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" class="category-chain-item">编程语言</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/C/">#C#</a>
      
        <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">#设计模式</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>设计模式</div>
      <div>http://bmtan.cc/2022/06/30/设计模式/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Bmtan</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年6月30日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/06/05/Unity%E8%84%9A%E6%9C%AC%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" title="Unity 生命周期">
                        <span class="hidden-mobile">Unity 生命周期</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>






  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
