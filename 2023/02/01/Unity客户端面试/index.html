

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Bmtan">
  <meta name="keywords" content="">
  
    <meta name="description" content="面试🌙Unity生命周期问题 Awake 当一个脚本实例被载入时Awake被调用。我们大多在这个类中完成成员变量的初始化  OnEnable 当对象变为可用或激活状态时此函数被调用。  Start 仅在Update函数第一次被调用前调用。因为它是在Awake之后被调用的，我们可以把一些需要依赖Awake的变量放在Start里面初始化。 同时我们还大多在这个类中执行StartCoroutine进行">
<meta property="og:type" content="article">
<meta property="og:title" content="Unity 客户端面试">
<meta property="og:url" content="http://bmtan.cc/2023/02/01/Unity%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%9D%A2%E8%AF%95/index.html">
<meta property="og:site_name" content="Bmtan">
<meta property="og:description" content="面试🌙Unity生命周期问题 Awake 当一个脚本实例被载入时Awake被调用。我们大多在这个类中完成成员变量的初始化  OnEnable 当对象变为可用或激活状态时此函数被调用。  Start 仅在Update函数第一次被调用前调用。因为它是在Awake之后被调用的，我们可以把一些需要依赖Awake的变量放在Start里面初始化。 同时我们还大多在这个类中执行StartCoroutine进行">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/06-05/Unity%E8%84%9A%E6%9C%AC%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201202110747790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xMTExMX18=,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201201161048150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xMTExMX18=,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/DrawCallProblem1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/DrawCallProblem2.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210414152912571.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3podXl1cWlhbmcxMjM4,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210414152951987.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3podXl1cWlhbmcxMjM4,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2021041415304878.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210414153138772.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3podXl1cWlhbmcxMjM4,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210414153317781.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3podXl1cWlhbmcxMjM4,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210414153422968.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3podXl1cWlhbmcxMjM4,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://pic2.zhimg.com/v2-35da80e428ca5750491ffd2770e187e1_b.webp">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-6a4e77fe8ead57f7384a1491d1c73ab0_720w.webp">
<meta property="og:image" content="https://pic1.zhimg.com/v2-5480232b0c74e8d236044529bd170834_b.webp">
<meta property="og:image" content="https://img-blog.csdn.net/20170311165114162?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQW5kcmV3RmFu/font/5a6L5L2T/fontsize/200/fill/I0JBQkFCMA==/dissolve/70/gravity/NorthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170311165659086?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQW5kcmV3RmFu/font/5a6L5L2T/fontsize/200/fill/I0JBQkFCMA==/dissolve/70/gravity/NorthEast">
<meta property="og:image" content="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230201222507758.png">
<meta property="og:image" content="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230201222538994.png">
<meta property="og:image" content="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/AwakeOrder.png">
<meta property="og:image" content="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230201221201268.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/b99d714ae81d4ed08afb9a933e5df2ea.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/cdda4b5f61374524bf3082080d30c4fb.png">
<meta property="og:image" content="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ListProblem.png">
<meta property="og:image" content="https://img2022.cnblogs.com/blog/708460/202205/708460-20220514185149561-1170153985.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210117205128952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNDA3NTIz,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/addressProblem.png">
<meta property="og:image" content="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%85%83%E7%BB%84.png">
<meta property="og:image" content="https://img-blog.csdn.net/20160528132344296">
<meta property="og:image" content="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Lua%E5%8D%8F%E7%A8%8B.png">
<meta property="og:image" content="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/TCP%26UDP.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210530224055792.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzeTc3Nzc3Nw==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210530224106137.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzeTc3Nzc3Nw==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/V2QJXN%25LGY17_GWQIJ%24%7D1W1.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/1daa0def8e454f61836f28a8d1cb2e0b.gif">
<meta property="og:image" content="https://img-blog.csdnimg.cn/15b1cfff79a049f0bef2dc98617d8d8d.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/d7de02f14c6c45f7ad9e75888ed6254b.gif">
<meta property="og:image" content="https://img-blog.csdnimg.cn/15b1cfff79a049f0bef2dc98617d8d8d.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/b72900449cb44c15999f8d89c286bb69.gif">
<meta property="og:image" content="https://img-blog.csdnimg.cn/5ca6790d2c4740ba86e8b956475dd2bd.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/5ff1f36a0e694cbc9ffd5f2e6089a821.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/640.gif">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2b6aaaf6b5914b2eb6efa5e559c18840.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/e33fa55d2e98407ea12bbc0b99221487.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/8f1362ccb2a043d98977410ba95406e2.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/5eaad2f07d4e400daff97217f6b7ab49.gif">
<meta property="og:image" content="https://img-blog.csdnimg.cn/0c66af0a2da0474d94384b06847ba235.gif">
<meta property="og:image" content="https://img-blog.csdnimg.cn/9fbfeab31f384aad9329a49fe345f678.gif">
<meta property="og:image" content="https://img-blog.csdnimg.cn/b7e8e42333e1432bb1a494d301c1c41e.gif">
<meta property="og:image" content="https://img-blog.csdnimg.cn/de00f05f30634bf3aa413803b3f35d4b.gif">
<meta property="og:image" content="https://img-blog.csdnimg.cn/49a4114d2323450792d15706511acdf4.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/842750f7516f4a62aa62e32a07190c1d.png">
<meta property="article:published_time" content="2023-02-01T14:44:00.000Z">
<meta property="article:modified_time" content="2023-05-25T03:52:26.178Z">
<meta property="article:author" content="Bmtan">
<meta property="article:tag" content="Unity">
<meta property="article:tag" content="C#">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="Lua">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/06-05/Unity%E8%84%9A%E6%9C%AC%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png">
  
  
  
  <title>Unity 客户端面试 - Bmtan</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"bmtan.cc","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Bmtan blog&#39;s</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Unity 客户端面试"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-02-01 22:44" pubdate>
          2023年2月1日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          67k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          562 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Unity 客户端面试</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h1><h2 id="🌙Unity"><a href="#🌙Unity" class="headerlink" title="🌙Unity"></a>🌙Unity</h2><h3 id="生命周期问题"><a href="#生命周期问题" class="headerlink" title="生命周期问题"></a>生命周期问题</h3><ul>
<li><p><strong>Awake</strong></p>
<p>当一个脚本实例被载入时Awake被调用。我们大多在这个类中完成成员变量的初始化</p>
</li>
<li><p><strong>OnEnable</strong></p>
<p>当对象变为可用或激活状态时此函数被调用。</p>
</li>
<li><p><strong>Start</strong></p>
<p>仅在Update函数第一次被调用前调用。因为它是在Awake之后被调用的，我们可以把一些需要依赖Awake的变量放在Start里面初始化。 同时我们还大多在这个类中执行StartCoroutine进行一些协程的触发。要注意在用C#写脚本时，必须使用StartCoroutine开始一个协程。</p>
</li>
<li><p><strong>Update</strong></p>
<p>当MonoBehaviour启用时，其Update在每一帧被调用。</p>
</li>
<li><p><strong>FixedUpdate</strong></p>
<p>当MonoBehaviour启用时，其 FixedUpdate 在每一固定帧被调用。</p>
</li>
<li><p><strong>LateUpdate</strong> </p>
<p>是在所有Update函数调用后被调用。这可用于调整脚本执行顺序。例如:当物体在Update里移动时，跟随物体的相机可以在LateUpdate里实现</p>
</li>
<li><p><strong>OnGUI</strong> </p>
<p>渲染和处理GUI事件时调用 这里不是 没帧都调用哦</p>
</li>
<li><p><strong>OnDisable</strong></p>
<p>当对象变为不可用或非激活状态时此函数被调用。</p>
</li>
<li><p><strong>OnDestroy</strong></p>
<p>当MonoBehaviour将被销毁时，这个函数被调用。</p>
</li>
</ul>
<blockquote>
<p>物理更新一般放在哪个系统函数里？</p>
</blockquote>
<p><strong>FixedUpdate</strong>，每固定帧绘制时执行一次，和Update不同的是FixedUpdate是渲染帧执行，如果你的渲染效率低下的时候FixedUpdate调用次数就会跟着下降。<strong>FixedUpdate比较适用于物理引擎的计算，因为是跟每帧渲染有关。Update就比较适合做控制。</strong></p>
<blockquote>
<p>Unity中Awake和Start两个生命周期函数，分别在什么时候被调用？</p>
</blockquote>
<ul>
<li><strong>Awake：</strong>运行时<ol>
<li>当脚本被动态添加到对象上时立即被调用。</li>
<li>当对象被实例化时，依附它的脚本会立即调用Awake</li>
<li>它类似构造函数</li>
</ol>
</li>
<li><strong>Start：</strong>第一次Update之前被调用</li>
</ul>
<blockquote>
<p>Unity3d脚本从唤醒到销毁有着一套比较完整的生命周期，请列出系统自带的几个重要的方法。</p>
</blockquote>
<p>Awake——&gt;OnEnable–&gt;Start——&gt;Update——&gt;FixedUpdate——&gt;LateUpdate——&gt;OnGUI——&gt;OnDisable——&gt;OnDestroy</p>
<p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/06-05/Unity%E8%84%9A%E6%9C%AC%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<blockquote>
<p>Unity中鼠标、键盘、触屏、手柄等输入事件会在Update 之前、还是之后、还是同时执行？</p>
</blockquote>
<p>之前</p>
<h3 id="DrawCall问题"><a href="#DrawCall问题" class="headerlink" title="DrawCall问题"></a>DrawCall问题</h3><blockquote>
<p>什么是DrawCall?</p>
</blockquote>
<ul>
<li>DrawCall 是 Cpu准备好渲染的数据后告知GPU渲染的命令</li>
</ul>
<blockquote>
<p>DrawCall过高影响什么性能？</p>
</blockquote>
<ul>
<li>会造成很多额外的性能开销，且CPU会把大量时间花费再Draw Call 上，造成CPU过载。</li>
</ul>
<blockquote>
<p>如何降低DrawCall</p>
</blockquote>
<ol>
<li><p>小图合成大图，即多个小DrawCall变一次大DrawCall</p>
</li>
<li><p>拼面板时严格控制不同图集层级处理</p>
</li>
<li><p>静态批处理</p>
</li>
<li><p>动态批处理</p>
</li>
</ol>
<blockquote>
<p>静态批处理</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20201202110747790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xMTExMX18=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><strong>静态批处理自由度很高，限制很少，缺点可能会占用更多的内存，而且经过静态批处理后的所有物体都不可以再移动了</strong></p>
<p>只要勾选上Static并拥有相同材质的物体即可在运行时进行静态批处理<br><strong>但是静态批处理会为每一个物体创建一个合并后的Combined Mesh，需要额外的内存空间来存储合并后的Combined Mesh，所以使用时要慎用(例如一片浓密的草地，如果使用静态批处理则会造成严重的内存开销)</strong></p>
<blockquote>
<p>动态批处理 </p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20201201161048150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xMTExMX18=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><strong>动态批处理一切都是自动的，不需要做任何操作，而且物体是可以移动的，但是限制很多。</strong></p>
<p>动态批处理默认是关闭的，需要手动开启：Project Setting—Player—勾上Dynamic Batching（动态批处理）</p>
<p><font color = "red"><b>总结</b></font></p>
<p><font color = "red"><b>——静态批处理和动态批处理都能降低DrawCall，最主要的前提是物体使用同一个材质</b></font><br><font color = "red"><b>——静态批处理适用于场景中位置不会改变并且单对象不能太多的物体，像树林，草地这种用动态批处理更适合</b></font><br><font color = "red"><b>——动态批处理限制较多，顶点数要求，材质要求等等。静态批处理限制较少，是用内存换性能的方法，具体情况具体分析</b></font></p>
<blockquote>
<p><strong>DrawCall渲染问题</strong></p>
</blockquote>
<blockquote>
<p>图中的小球是否被渲染了？是否会产生DrawCall？</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/DrawCallProblem1.png" srcset="/img/loading.gif" lazyload></p>
<p>不会被渲染，不会产生DrawCall</p>
<p>Unity本身有摄像机视锥体剔除，也就是不会显示完全位于视锥体之外的游戏对象<br>那么小球就不会进行渲染，也不会提交数据给GPU，也就不会产生DrawCall</p>
<blockquote>
<p>在没有使用遮挡剔除的情况下，图中A和B都是默认标准材质，图中的小球最终是否会被渲染，是否会产生DrawCall</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/DrawCallProblem2.png" srcset="/img/loading.gif" lazyload></p>
<p>最终不会被渲染，标准材质存在深度测试，小球在立方体后方，不会通过深度测试，所以不会被渲染</p>
<p>会产生DrawCall，既然都深度测试了，那么肯定是存在DrawCall的<br>深度测试发生在片元着色器处理之后，GPU会对每个片元执行深度测试来决定遮挡关系，决定是否被渲染</p>
<h3 id="图集问题"><a href="#图集问题" class="headerlink" title="图集问题"></a>图集问题</h3><blockquote>
<p>什么是图集</p>
</blockquote>
<p>我们可以将其理解为将一系列小图合并为一张大图，目的是为了降低DrawCall</p>
<blockquote>
<p>Unity打包图集的方式</p>
</blockquote>
<p><strong>（1）一种是使用系统自带的打包工具SpritePacker；</strong></p>
<p><strong>（2）使用SpriteAtlas进行打包图集</strong></p>
<p><strong>（3）使用TexturePacker打包图片并使用；</strong></p>
<h4 id="SpritePacker使用"><a href="#SpritePacker使用" class="headerlink" title="SpritePacker使用"></a>SpritePacker使用</h4><ol>
<li><p>将所需要的图片导入Unity中，注意不能放在Resources文件夹下(图片将不能被打包成图集)</p>
</li>
<li><p>选择需要打包成图集的图片（可以多选）在inspector面板里选择“Texture Type“为“Sprite （2D and UI）”，并Apply应用；</p>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20210414152912571.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3podXl1cWlhbmcxMjM4,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="img"></p>
<ol start="3">
<li>在”Packing Tag”选项里面填上图集的名称，该选项相同的图片会打包为同一个图集</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20210414152951987.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3podXl1cWlhbmcxMjM4,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="img"></p>
<ol start="4">
<li><p>选择菜单栏里面的 “Edit” -&gt; “Project Settings” -&gt; “Editor”</p>
</li>
<li><p>在inspector面板里设置“Sprite Packers”下面的“Mode”选项，</p>
<p>其中</p>
<p>“Disabled”表示关闭图集功能，</p>
<p>“Enabled for Builds”表示打包发布时才打包图集，</p>
<p>“Always Enable”表示始终打包图集；</p>
<p>Enabled for Builds（Legacy Sprite Packer）表示打包发布时才打包图集（使用旧版技术）；</p>
<p>“Always Enable（Legacy Sprite Packer）”表示始终打包图集（使用旧版技术）</p>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/2021041415304878.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<ol start="6">
<li>设置完上述选项后，选中需要打包图集的图片，在 “Window ” -&gt; “Sprite Packer”面板里预览图集，可尝试点击左上角的“Pack”按钮立即打包</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20210414153138772.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3podXl1cWlhbmcxMjM4,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="img"></p>
<blockquote>
<p><strong>不同图片如何合并至一个图集？</strong></p>
</blockquote>
<ul>
<li>选中需要打包图集的图片，将其类型修改Sprite （2D and UI），修改其Packing Tag为你自定义的名字。不同的图片，只要Tag相同，就可以打包到同一个图集里面。</li>
</ul>
<blockquote>
<p><strong>打图集策略</strong></p>
</blockquote>
<ol>
<li><p><strong>DefaultPackerPolicy</strong>：</p>
<p>是默认的打包方式，也是矩形打包方式。他会把所有的小图按照矩形的方式来排列，如果宽高不一样的图片，它们会自动补齐,使用方式就是tag设置时加上”[RECT]图集名”来设置。</p>
</li>
<li><p><strong>TightPackerPolicy</strong>：</p>
<p>是紧密打包方式，也就是尽可能的把图片都打包在图集上，这种方式要比DefaultPackerPolicy打包的图片更多一些，也就是更省空间,使用方式就是tag设置时加上”[TIGHT]图集名”来设置。</p>
</li>
<li><p><strong>TightRotateEnabledPackerPolicy</strong>：</p>
<p>是紧密可旋转打包方式,也就是使用紧密打包，并且允许精灵进行旋转。</p>
</li>
</ol>
<h4 id="SpriteAtlas使用"><a href="#SpriteAtlas使用" class="headerlink" title="SpriteAtlas使用"></a>SpriteAtlas使用</h4><p>Sprite Atlas 针对现有的图集打包系统Sprite Packer在性能和易用性上的不足，进行了全面改善。除此之外，相比Sprite Packer，Sprite Atlas将对精灵更多的控制权交还给用户。由用户来掌控图集的打包过程以及加载时机，更加利于对系统性能的控制。设置Edit–&gt;Project Settings –&gt;Editor —&gt;Mode为Always Enable。</p>
<p><strong>Sprite Atlas的主要有以下三个功能：</strong></p>
<ol>
<li><p>创建、编辑图集以及设定图集参数</p>
</li>
<li><p>添加图集Variant（变种）</p>
</li>
<li><p>运行时访问图集</p>
</li>
<li><p><strong>创建、编辑图集及参数设定</strong></p>
</li>
</ol>
<p>在Unity 2017.1版本之后，SpriteAtlas是一种资源，右击 Asset —&gt; Create —&gt;SpriteAtlas 可以像其它资源一样在Unity中创建，例如预制件、场景等。</p>
<p><img src="https://img-blog.csdnimg.cn/20210414153317781.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3podXl1cWlhbmcxMjM4,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>这里可以支持多种类型，包括单个Sprite、Sliced Sprite、文件夹，以及这些类型的任意组合。</p>
<p>操作更加方便，对用户更友好。可以将文件夹，纹理或精灵分配给Sprite Atlas。可以将整个文件夹分配给Sprite Atlas资产，该文件夹中的所有纹理（包括子文件夹）都将被打包，使用起来非常方便。</p>
<p>此外，在检视窗口上还可以看到图集的一些参数设定，例如：打包时是否支持精灵旋转(Allow Rotation)、贴图的采样模式(Filter Mode)、压缩方式(Compression)等等。  在最下方的预览窗口中，可以查看图集的生成效果。这样就可以很清楚的知道图集的打包方式是否合理，是否存在大量被浪费的空间。</p>
<p>设计UI，添加几个Image，使用SpriteAtlas图集内部的图片作为Image原图片，发现DrawCall只需要一次就可以完成。</p>
<ol start="2">
<li><strong>添加图集Variant（变种）</strong></li>
</ol>
<p>所谓Variant，就是指原有图集的一个变种。它会复制原有图集的贴图，并根据一个比例系数来调整复制贴图的大小。</p>
<p>这样的Variant通常用于为高分辨率和低分辨率的屏幕准备不同的图集。</p>
<p>因为如果只准备一套高分辨率的图集，在低分辨率的设备上占用内存过多。反之，如果只准备一套低分辨率图集，在高分辨率的设备上就会模糊。</p>
<p>通过Atlas Variant就可以很方便地解决该问题。如下图所示，SpriteAtlas .spriteatlas是新建的一个低清图集，在检视窗口中将Type设为Variant，Master Atlas设为SpriteAtlas。这里为了与原图进行更明显的对比，将Scale设为0.1， 点击Pack Preview。<br><img src="https://img-blog.csdnimg.cn/20210414153422968.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3podXl1cWlhbmcxMjM4,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="img"></p>
<ol start="3">
<li><strong>运行时访问图集</strong></li>
</ol>
<p>我们经常会在代码中切换ui的图片，所以就需要单独加载图集中的每个精灵。</p>
<p>这样做的好处是，让用户可以更加直接地随时编辑图集，而且不用去单独加载图集中的每个精灵。</p>
<p>下面是一段动态换装的代码，该脚本通过LoadAsset加载SpriteAtlas类型的资源，再通过SpriteAtlas的GetSprite接口获取图集中的精灵，最后将精灵传递给SpriteRenderer。相较于基于Sprite Packer的实现，整个过程要简单直接的多。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">using</span> UnityEditor;<br><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> UnityEngine.U2D;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SpriteAtlasExample</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>       <br> <br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>      <span class="hljs-comment">//加载图集</span><br>        SpriteAtlas atlas = AssetDatabase.LoadAssetAtPath&lt;SpriteAtlas&gt;<br>            (<span class="hljs-string">&quot;Assets/Hero.spriteatlas&quot;</span>);<br> <br>        <span class="hljs-comment">//获取图集下的所有Sprite</span><br>        Sprite[] sp = <span class="hljs-keyword">new</span> Sprite[atlas.spriteCount];<br>        atlas.GetSprites(sp);<br>        print(sp.Length);<br> <br>        <span class="hljs-comment">//根据小图名称获取对应的Sprite</span><br>        Sprite sprite = atlas.GetSprite(<span class="hljs-string">&quot;nxxg&quot;</span>);<br>        <span class="hljs-keyword">if</span> (sprite != <span class="hljs-literal">null</span>)<br>        &#123;<br>            GetComponent&lt;SpriteRenderer&gt;().sprite = sprite;<br>        &#125;<br>       <br>    &#125;<br> <br> <br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> UnityEngine.U2D;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SpriteAtlasMgr</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SpriteAtlasMgr instance;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span><br>    &#123;<br>        instance = <span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> Dictionary&lt;<span class="hljs-built_in">string</span>, SpriteAtlas&gt; atlas = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">string</span>, SpriteAtlas&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddSpriteAtlas</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span> &#123; <br>        <span class="hljs-comment">//</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RemoveAtlas</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span> &#123;<br>        <span class="hljs-comment">//</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Sprite <span class="hljs-title">GetSpriteFromAtlas</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> sname</span>)</span> &#123;<br>        <span class="hljs-comment">//....</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Sprite <span class="hljs-title">GetSpriteFromAtlas</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> atlasname, <span class="hljs-built_in">string</span> sname</span>)</span><br>    &#123;<br>        <span class="hljs-comment">//....</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// public static SpriteAtlasMgr</span><br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <br>    &#125;<br><br>    <span class="hljs-comment">// Update is called once per frame</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span><br>    &#123;<br>        <br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h3 id="Prebab-预设体问题"><a href="#Prebab-预设体问题" class="headerlink" title="Prebab 预设体问题"></a>Prebab 预设体问题</h3><blockquote>
<p>简述prefab的用处</p>
</blockquote>
<p>在游戏运行时实例化，prefab相当于一个模板，对你已经有的素材、脚本、参数做一个默认的配置，以便于以后的修改，同时prefab打包的内容简化了导出的操作，便于团队的交流。</p>
<blockquote>
<p> 请简述一下Prefab（预制体）的本质是什么？</p>
</blockquote>
<p>Prefab的本质就是一个配置文件<br>其中记录了一个GameObject对象上挂载的脚本信息<br>并且记录了脚本信息中的可配置的属性信息</p>
<h3 id="Unity-协同程序和线程-进程问题"><a href="#Unity-协同程序和线程-进程问题" class="headerlink" title="Unity 协同程序和线程,进程问题"></a>Unity 协同程序和线程,进程问题</h3><blockquote>
<p>Unity 协程和线程,进程的区别</p>
</blockquote>
<p>在 Unity 中，协程、线程和进程都是实现多任务处理的方式</p>
<ul>
<li><p><strong>进程（Process）</strong></p>
<p>是Windows系统中的一个基本概念，是系统进行资源分配和调度的基本单位，是操作系统结构的基础他包含着运行一个程序所需要的基本资源。<strong>一个正在运行的应用程序在操作系统中被视为一个进程，进程可以包括一个或多个线程。</strong>　　　</p>
</li>
<li><p><strong>线程（Thread）</strong></p>
<p>是一种操作系统级别的多任务处理方式，是操纵系统能进行运算调度的最小单位，它被包含再进程之中，是进程中的实际运作单位。它允许在游戏运行时<strong>启动一个独立的执行流程，该执行流程不会阻塞主线程，可以并行执行</strong>，从而提高游戏的响应速度。线程可以用来处理一些耗时的操作，例如网络请求和文件读写等。在 Unity 中，<strong>使用线程需要注意线程安全问题，因为线程与主线程共享资源，需要采取一些措施来保证数据的一致性。</strong></p>
</li>
<li><p><strong>协程（Coroutine）</strong>。</p>
<p><font color = "red"><b>协程不是线程。协程的实现原理是迭代器，而迭代器的实现原理是状态机。</b></font></p>
<p> <strong>协程是伴随着主线程一起运行的一段程序。</strong></p>
<p><strong>是一种轻量级的线程</strong>，它可以在代码执行过程中暂停和恢复执行，避免了线程的上下文切换和锁竞争问题，同时协程也具有良好的可控性和可维护性。在 Unity 中，协程是通过 StartCoroutine 方法来启动的，<strong>协程的执行是在主线程中，而不是在一个独立的执行流程中。</strong></p>
<p><strong>一般应用一个应用程序只使用线程这一“资源”</strong>。</p>
<p>Unity只使用了一个线程，<strong>协程是一种”伪线程</strong>“。 </p>
<ol>
<li>协同程序（coroutine）,即协作式程序，一系列互相依赖的协程间依次使用CPU，每次只有一个协程工作，而其他协成处于休眠状态。协程实际上是在一个线程中，只不过每个协程对CPU进行分时，协程可以访问和使用unity的所有方法和component。　　　　</li>
<li>同一时间只能执行某个协程，协程适合对某个任务进行分时处理。</li>
<li>控制代码在特定的时间执行。　　　　</li>
<li><strong>协程不是线程，也不是异步执行，跟Update一样，在主线程中执行</strong>。不用考虑同步和锁的问题。　　　　</li>
<li>协程是一个分部组件，遇到条件（yield return）会挂起,直到条件满足才会被唤起执行后面的语句。</li>
</ol>
</li>
</ul>
<blockquote>
<p>线程与协程的区别</p>
</blockquote>
<p><strong>协程(协同程序)</strong>: 同一时间只能执行某个协程。开辟多个协程开销不大。<strong>协程适合对某任务进行分时处理。</strong></p>
<p><strong>线程:</strong> 同一时间可以同时执行多个线程。开辟多条线程开销很大。<strong>线程适合多任务同时处理。</strong></p>
<p> <font color = "red"><b>线程和协同程序的主要不同在于</b></font>：<strong>在多处理器情况下，从概念上来讲多线程程序同时运行多个线程；而协同程序是通过协作来完成，在任一指定时刻只有一个协同程序在运行，并且这个正在运行的协同程序只在必要时才会被挂起。</strong></p>
<blockquote>
<p>协程的主要作用</p>
</blockquote>
<p><strong>延迟执行</strong>：协程可以延迟执行某个任务，从而在指定时间后执行相应的操作。</p>
<p><strong>异步执行</strong>：协程可以在后台执行任务，从而避免卡顿和阻塞主线程。</p>
<p><strong>任务管理</strong>：协程可以管理多个任务，从而实现更灵活和可控的代码执行顺序。</p>
<p>协程是辅助主线程的操作，避免卡顿。</p>
<blockquote>
<p>什么是协同程序？</p>
</blockquote>
<p>在主线程运行的同时开启另一段逻辑处理，来协助当前程序的执行，协程很像多线程，但是不是多线程，Unity的协程实在每帧结束之后去检测yield的条件是否满足。</p>
<blockquote>
<p>请简述Unity中协程的原理</p>
</blockquote>
<p>Unity中的协同程序分为<strong>两部分</strong></p>
<ol>
<li>协程函数本体（<strong>迭代器函数</strong>）</li>
<li>协程调度器（<strong>协程管理器</strong>）</li>
</ol>
<p>协程利用迭代器函数的分步执行的特点<br>加上<br>协程调度器对迭代器函数们进行统一管理<br>根据迭代器函数的返回值来决定下一次执行函数逻辑的时间点<br>从而实现逻辑分时分步执行的目的</p>
<blockquote>
<p>Unity中的协同程序中yield return不同的内容，代表的含义不同</p>
<p>请说明下面这些yield return的含义</p>
</blockquote>
<ol>
<li>yield return 数字;</li>
<li>yield return null;</li>
<li>yield return new WaitForSeconds(数字);</li>
<li>yield return new WaitForFixedUpdate();</li>
<li>yield return new WaitForEndOfFrame();</li>
<li>yield break;</li>
</ol>
<p><strong>答案：</strong></p>
<ol>
<li>yield return 数字; 下一帧执行</li>
<li>yield return null;  下一帧执行</li>
<li>yield return new WaitForSeconds(数字); 等待指定秒后执行</li>
<li>yield return new WaitForFixedUpdate(); 等待下一个固定物理帧更新时执行</li>
<li>yield return new WaitForEndOfFrame(); 等待摄像机和GUI渲染完成后执行</li>
<li>yield break; 跳出协程</li>
</ol>
<blockquote>
<p>yield return 挂起的程序什么时候执行</p>
</blockquote>
<p>协同程序主要是Update()方法之后，LateUpdate()方法之前调用的</p>
<blockquote>
<p> 使用Unity协同程序进行异步加载时，底层是否会使用多线程？</p>
</blockquote>
<p>可能会<br>协同程序的原理是分时分步完成指定逻辑<br>在其中的某一步骤中，是可以使用多线程来完成某些加载操作的，多线程加载完成后，再进入协同程序的下一步继续执行</p>
<blockquote>
<p>Unity是否支持写成多线程程序？如果支持的话需要注意什么？</p>
</blockquote>
<p>1.只能从主线程访问Unity相关组件、对象以及<br>UnityEngine命名空间中的绝大部分内容<br>2.如果多线程中要和Unity主线程同时修改一些数据<br>可以通过lock关键词加锁</p>
<h3 id="Unity-Invoke问题"><a href="#Unity-Invoke问题" class="headerlink" title="Unity Invoke问题"></a>Unity Invoke问题</h3><ol>
<li><strong>Invoke</strong></li>
</ol>
<p>​       <strong>Invoke() 方法是 Unity3D 的一种委托机制</strong></p>
<p>​    如： Invoke(“Test”, 5);  它的意思是：5 秒之后调用 Test() 方法；</p>
<p>注意：</p>
<pre><code class="hljs">    1 ：它应该在 脚本的生命周期里的（Start、Update、OnGUI、FixedUpdate、LateUpdate）中被调用；
    2：Invoke(); 不能接受含有参数的方法；
    3：在 Time.ScaleTime = 0; 时， Invoke() 无效，因为它不会被调。
</code></pre>
<ol start="2">
<li><p><strong>InvokeRepeating</strong><br> <strong>InvokeRepeating(“Test”, 2 , 3);</strong> </p>
<p> 这个方法的意思是指：2 秒后调用 Test() 方法，并且之后每隔 3 秒调用一次 Test() 方法。</p>
<p> 被激活时设置了，但是此时将引擎对象设置为false,还会被执行。</p>
<pre><code class="hljs">还有三个重要的方法：

IsInvoking：用来判断某方法是否被延时，即将执行。
CancelInvoke()  : 停止当前脚本中所有的Invoke和InvokeRepeating方法。
CancelInvoke(&quot;MethodName&quot;) ： 停止当前脚本某个Invoke和InvokeRepeating方法。
</code></pre>
</li>
</ol>
<blockquote>
<p>Invoke与协程的区别</p>
</blockquote>
<p><strong>Invoke方法</strong>：执行没有被挂起，相当于设置完被调用函数的执行时间后即时向下执行。应用到每隔一段时间执行某个函数很方便。</p>
<p><strong>Coroutine方法</strong>：新开一条执行序列（跟新建线程差不多）并挂起，等待中断指令结束。开销不大。当需要挂起当前执行时使用。</p>
<p>协程的效率比Invoke高。</p>
<blockquote>
<p>正在运行的脚本，隐藏物体与禁止脚本导致OnDisable，Invoke与coroutine是否正常运行？</p>
</blockquote>
<p><strong>如果把物体直接隐藏：Invoke正常运行，coroutine不会正常运行。</strong></p>
<p><strong>原因：</strong></p>
<p>​    因为游戏物体隐藏了，一切与游戏物体相关的脚本生命周期都会停止，协程自然也会停止 ；    </p>
<p>​    如果游戏对象没有隐藏，只是将脚本隐藏，游戏对象照样可以通过反射获取协程迭代器对象继续协程的执行。</p>
<h3 id="Unity坐标系问题"><a href="#Unity坐标系问题" class="headerlink" title="Unity坐标系问题"></a>Unity坐标系问题</h3><blockquote>
<p>本地坐标系 世界坐标系</p>
</blockquote>
<ul>
<li><strong>世界坐标系</strong>：世界坐标是指物体在场景中的坐标，当某个物体没有父物体时，它的position即为世界坐标的position，rotation同理；本地坐标是物体相对于它的父物体的坐标而言，这个相对坐标是以父物体本身为坐标轴进行计算的，与世界坐标没有必然联系。而对于没有父物体的物体，可以认为不存在本地坐标这种说法。</li>
<li><strong>本地坐标系</strong>：当某个物体有父物体时，它的inspector栏transform中的position实际是localposition，即本地坐标。</li>
</ul>
<blockquote>
<p>Unity中如何将本地坐标转为世界坐标？</p>
</blockquote>
<ol>
<li>使用TransformPoint方法将本地坐标系转为世界坐标系</li>
<li>用本地坐标加上父对象相对世界的坐标（如果有多层父子关系，不停地往上加即可）</li>
</ol>
<blockquote>
<p>transform.forward和Vector3.forword的区别</p>
</blockquote>
<p>Vector3.forword始终时(0,0,1)<br>可以认为是世界坐标系的Z轴朝向</p>
<p>transform.forword是当前物体的局部坐标系的Z轴在世界坐标系下的朝向<br>可以认为是物体自己的Z轴朝向</p>
<h3 id="Unity碰撞器问题"><a href="#Unity碰撞器问题" class="headerlink" title="Unity碰撞器问题"></a>Unity碰撞器问题</h3><blockquote>
<p>Unity3d中的碰撞器和触发器的区别？</p>
</blockquote>
<p><strong>碰撞器</strong>是<em>触发器的载体</em>，而<strong>触发器</strong>只是<em>碰撞器身上的一个属性</em>。</p>
<p>当<strong>Is Trigger&#x3D;false</strong>时，碰撞器根据物理引擎引发碰撞，产生碰撞的效果，可以调用OnCollisionEnter&#x2F;Stay&#x2F;Exit函数；</p>
<p>当<strong>Is Trigger&#x3D;true</strong>时，碰撞器被物理引擎所忽略，没有碰撞效果，可以调用OnTriggerEnter&#x2F;Stay&#x2F;Exit函数。</p>
<p>如果既要检测到物体的接触又不想让碰撞检测影响物体移动或要检测一个物件是否经过空间中的某个区域这时就可以用到触发器</p>
<blockquote>
<p>物体发生碰撞的必要条件</p>
</blockquote>
<p><strong>两个物体都必须带有碰撞器</strong>（Collider），<strong>其中一个物体还必须带有Rigidbody刚体</strong>，而且必须是运动的物体带有Rigidbody脚本才能检测到碰撞。</p>
<blockquote>
<p>在物体发生碰撞的整个过程中，有几个阶段，分别列出对应的函数</p>
</blockquote>
<p><strong>三个阶段:</strong></p>
<ol>
<li>OnCollisionEnter </li>
<li>OnCollisionStay </li>
<li>OnCollisionExit</li>
</ol>
<blockquote>
<p>Unity中当一个细小高速物体撞击另一个较大物体时会出现什么情况？如何避免？</p>
</blockquote>
<p><strong>穿透</strong></p>
<ol>
<li>我们可以尽量用射线检测来替代细小物体的物理系统碰撞<br>因为传统的FPS游戏都是通过射线检测加模拟计算来判断伤害的</li>
<li>修改Rigidbody刚体中的<strong>Interpolate（插值）</strong>和<strong>CollisionDetection（碰撞检测）</strong>两个参数，来提高碰撞检测的准确性</li>
</ol>
<table>
<thead>
<tr>
<th><strong>Interpolate</strong></th>
<th>仅当在刚体运动中看到急动时才尝试使用提供的选项之一。</th>
</tr>
</thead>
<tbody><tr>
<td>- <strong>None</strong></td>
<td>不应用插值。</td>
</tr>
<tr>
<td>- <strong>Interpolate</strong></td>
<td>根据前一帧的变换来平滑变换。</td>
</tr>
<tr>
<td>- <strong>Extrapolate</strong></td>
<td>根据下一帧的估计变换来平滑变换。</td>
</tr>
<tr>
<td><strong>Collision Detection</strong></td>
<td>用于防止快速移动的对象穿过其他对象而不检测碰撞。</td>
</tr>
<tr>
<td>- <strong>Discrete</strong></td>
<td>对场景中的所有其他碰撞体使用离散碰撞检测。其他碰撞体在测试碰撞时会使用离散碰撞检测。用于正常碰撞（这是默认值）。</td>
</tr>
<tr>
<td>- <strong>Continuous</strong></td>
<td>对动态碰撞体（具有刚体）使用离散碰撞检测，并对静态碰撞体（没有刚体）使用基于扫掠的连续碰撞检测。设置为__连续动态 (Continuous Dynamic)__ 的刚体将在测试与该刚体的碰撞时使用连续碰撞检测。其他刚体将使用离散碰撞检测。用于__连续动态 (Continuous Dynamic)__ 检测需要碰撞的对象。（此属性对物理性能有很大影响，如果没有快速对象的碰撞问题，请将其保留为 <strong>Discrete</strong> 设置）</td>
</tr>
<tr>
<td>- <strong>Continuous Dynamic</strong></td>
<td>对设置为__连续 (Continuous)__ 和__连续动态 (Continuous Dynamic)__ 碰撞的游戏对象使用基于扫掠的连续碰撞检测。还将对静态碰撞体（没有刚体）使用连续碰撞检测。对于所有其他碰撞体，使用离散碰撞检测。用于快速移动的对象。</td>
</tr>
<tr>
<td>- <strong>Continuous Speculative</strong></td>
<td>对刚体和碰撞体使用推测性连续碰撞检测。这也是可以设置运动物体的唯一 CCD 模式。该方法通常比基于扫掠的连续碰撞检测的成本更低。</td>
</tr>
</tbody></table>
<h3 id="Unity-Camera问题"><a href="#Unity-Camera问题" class="headerlink" title="Unity Camera问题"></a>Unity Camera问题</h3><blockquote>
<p>在场景中放置多个Camera并同时处于活动状态会发生什么？</p>
</blockquote>
<p>游戏界面可以看到很多摄像机的混合。</p>
<blockquote>
<p>Unity中，照相机的Clipping Planes(剪裁屏幕)的作用是什么？调整Near、Fare两个值时，应该注意什么？</p>
</blockquote>
<p>剪裁平面 。从相机到开始渲染和停止渲染之间的距离。</p>
<blockquote>
<p>移动相机动作在哪个函数里，为什么在这个函数里？</p>
</blockquote>
<p>LateUpdate，是在所有的update结束后才调用，比较适合用于命令脚本的执行。官网上例子是摄像机的跟随，都是所有的update操作完才进行摄像机的跟进，不然就有可能出现摄像机已经推进了，但是视角里还未有角色的空帧出现。</p>
<blockquote>
<p>将Camera组件的ClearFlags选项选成Depth only是什么意思？有何用处？</p>
</blockquote>
<p>如果把摄像机的ClearFlags勾选为Deapth Only,那么摄像机就会只渲染看得见的对象，把背景会完全透明，这种情况一般用在两个摄像机以上的场景中</p>
<h3 id="Unity-动画问题"><a href="#Unity-动画问题" class="headerlink" title="Unity 动画问题"></a>Unity 动画问题</h3><blockquote>
<p>请描述游戏动画有哪几种，以及其原理？</p>
</blockquote>
<p>主要有关节动画、骨骼动画、单一网格模型动画(关键帧动画)。</p>
<ul>
<li><p><strong>关节动画</strong></p>
<p>把角色分成若干独立部分，一个部分对应一个网格模型，部分的动画连接成一个整体的动画，角色比较灵活，Quake2中使用这种动画；</p>
</li>
<li><p><strong>骨骼动画</strong></p>
<p>广泛应用的动画方式，集成了以上两个方式的优点，骨骼按角色特点组成一定的层次结构，有关节相连，可做相对运动，皮肤作为单一网格蒙在骨骼之外，决定角色的外观；</p>
</li>
<li><p><strong>单一网格模型动画</strong></p>
<p>由一个完整的网格模型构成，在动画序列的关键帧里记录各个顶点的原位置及其改变量，然后插值运算实现动画效果，角色动画较真实。</p>
</li>
</ul>
<blockquote>
<p><strong>Animation和Animator的区别</strong></p>
</blockquote>
<p>Animation和Animator 虽然都是控制动画的播放，但是它们的<strong>用法和相关语法都是大有不同</strong>的。</p>
<p><strong>Animation控制一个动画的播放</strong>，而<strong>Animator是多个动画之间相互切换</strong>，并且Animator有一个动画控制器，俗称动画状态机。</p>
<p>Animator利用它做动画的切换是很方便的，但是它有一个缺点就是占用内存比Animation大。</p>
<h3 id="Unity-光源问题"><a href="#Unity-光源问题" class="headerlink" title="Unity 光源问题"></a>Unity 光源问题</h3><blockquote>
<p>Unity提供了几种光源，分别是什么</p>
</blockquote>
<p>四种</p>
<ol>
<li><strong>平行光</strong>：Directional Light</li>
<li><strong>点光源</strong>：Point Light</li>
<li><strong>聚光灯</strong>：Spot Light</li>
<li><strong>区域光源</strong>：Area Light</li>
</ol>
<blockquote>
<p>实时点光源的优缺点是什么？</p>
</blockquote>
<p>可以有cookies – 带有 alpha通道的立方图(Cubemap )纹理。点光源是最耗费资源的.</p>
<blockquote>
<p>Unity中的光照贴图的作用是什么？</p>
</blockquote>
<p>在移动平台上（或配置较低的设备上）使用实时光源是非常消耗性能的<br>我们可以使用光照贴图，预先将环境光烘焙到贴图上，可以减少性能消耗</p>
<blockquote>
<p>两种阴影判断的方法、工作原理</p>
</blockquote>
<p><strong>本影和半影</strong></p>
<ul>
<li><p><strong>本影：</strong></p>
<p>景物表面上那些没有被光源直接照射的区域（全黑的轮廓分明的区域）。</p>
</li>
<li><p><strong>半影：</strong></p>
<p>景物表面上那些被某些特定光源直接照射但并非被所有特定光源直接照射的区域（半明半暗区域）</p>
</li>
</ul>
<h3 id="Unity-渲染问题"><a href="#Unity-渲染问题" class="headerlink" title="Unity 渲染问题"></a>Unity 渲染问题</h3><blockquote>
<p>在Unity中如何控制渲染优先级？</p>
</blockquote>
<ol>
<li>不同摄像机渲染时，摄像机深度（Camera depth）控制优先级</li>
<li>相同摄像机时，排序层级（Sorting Layer）控制优先级</li>
<li>相同排序层级时，层中的顺序（Order in Layer）控制优先级</li>
<li>相同摄像机，无排序层级属性时，Shader中的RenderQueue（渲染队列）控制优先级</li>
</ol>
<blockquote>
<p>Unity中场景中一个处于激活状态的物体(场景上只有这一个物体)，不能被摄像机渲染出来，可能有几种情况？（至少说出3种可能的情况）</p>
</blockquote>
<ol>
<li>在摄像机可视范围外（视口范围外）</li>
<li>在摄像机可视范围外（远近裁剪面之外范围）</li>
<li>物体的层级不能被摄像机渲染</li>
<li>该物体使用了透明材质，处于透明状态</li>
<li>该物体使用了单面渲染材质，摄像机看到的是该物体的背面</li>
<li>如果存在多摄像机，摄像机深度可能会影响<br>等等</li>
</ol>
<blockquote>
<p>解释一下Unity中的渲染管线（Rendering Pipeline）是什么，如何使用它，并举例说明它在游戏开发中的应用场景。</p>
</blockquote>
<p><strong>几何图形的准备</strong>：将场景中的几何图形转换为渲染引擎可以理解的形式，例如将3D模型转换为网格数据（Mesh）和材质信息。</p>
<p><strong>光照计算</strong>：计算场景中每个几何图形的光照效果，包括直接光照和间接光照。</p>
<p><strong>视点变换</strong>：根据摄像机的位置和方向将场景中的几何图形转换为摄像机的视图空间（View Space）坐标系下的形式。</p>
<p><strong>投影变换</strong>：将摄像机的视图空间坐标系下的几何图形转换为投影坐标系下的形式。</p>
<p><strong>图像空间计算</strong>：将投影坐标系下的几何图形转换为屏幕上的像素坐标。</p>
<p><strong>着色</strong>：根据材质信息和光照信息对几何图形进行着色，计算每个像素的颜色值。</p>
<p><strong>合成</strong>：将所有的像素颜色值按照一定的顺序合成为最终的图像，输出到屏幕上。</p>
<h3 id="Unity-贴图问题"><a href="#Unity-贴图问题" class="headerlink" title="Unity 贴图问题"></a>Unity 贴图问题</h3><blockquote>
<p>LOD是什么，优缺点是什么？</p>
</blockquote>
<p><strong>LOD(Level of detail)多层次细节</strong>，是最常用的游戏优化技术。它按照模型的位置和重要程度决定物体渲染的资源分配</p>
<ul>
<li><p><strong>优点</strong></p>
<p>降低非重要物体的面数和细节度，从而获得高效率的渲染运算</p>
</li>
<li><p><strong>缺点</strong></p>
<p>增加了内存</p>
</li>
</ul>
<blockquote>
<p>LOD（多细节层次）和 MipMap（纹理图）的作用是什么？</p>
</blockquote>
<ul>
<li><strong>优化游戏性能</strong><br>从不同距离渲染对象时，使用的是质量不同的模型(LOD)和贴图(Mipmap)。（一般情况是越远面数越低，图片越小）</li>
</ul>
<h3 id="Unity-UI问题"><a href="#Unity-UI问题" class="headerlink" title="Unity UI问题"></a>Unity UI问题</h3><h4 id="Canvas问题"><a href="#Canvas问题" class="headerlink" title="Canvas问题"></a>Canvas问题</h4><blockquote>
<p>UGUI中的Canvas以及三种画布渲染模式区别</p>
</blockquote>
<ol>
<li><strong>Screen Space-Overlay</strong>模式</li>
</ol>
<p><strong>Screen Space-Overlay（屏幕控件-覆盖模式）的画布会填满整个屏幕空间，并将画布下面的所有的UI元素置于屏幕的最上层，</strong>或者说画布的画面永远“覆盖”其他普通的3D画面，如果屏幕尺寸被改变，画布将自动改变尺寸来匹配屏幕　　　　　　　　　　　　　　　　　　　　　　　　　　　　　</p>
<p>Screen Space-Overlay模式的画布有<strong>Pixel Perfect</strong>和<strong>Sort Layer</strong>两个参数：</p>
<ol>
<li><p><strong>Pixel Perfect</strong>：只有RenderMode为Screen类型时才有的选项。使UI元素像素对应，效果就是边缘清晰不模糊。</p>
</li>
<li><p><strong>Sort Layer</strong>: Sort Layer是UGUI专用的设置，用来指示画布的深度。</p>
</li>
</ol>
<hr>
<ol start="2">
<li><strong>Screen Space-Camera模式</strong></li>
</ol>
<p><strong>Screen Space-Camera（屏幕空间-摄影机模式）和Screen Space-Overlay模式类似，画布也是填满整个屏幕空间，如果屏幕尺寸改变，画布也会自动改变尺寸来匹配屏幕</strong>。所不同的是，在该模式下，画布会被放置到摄影机前方。在这种渲染模式下，画布看起来 绘制在一个与摄影机固定距离的平面上。所有的UI元素都由该摄影机渲染，因此摄影机的设置会影响到UI画面。在此模式下，UI元素是由perspective也就是视角设定的，视角广度由Filed of View设置。</p>
<p>　　<strong>这种模式可以用来实现在UI上显示3D模型的需求</strong>，比如很多MMO游戏中的查看人物装备的界面，可能屏幕的左侧有一个运动的3D人物，左侧是一些UI元素。通过设置Screen Space-Camera模式就可以实现上述的需求.</p>
<p>　　它比Screen Space-Overlay模式的画布多了下面几个参数：</p>
<ol>
<li><p><strong>Render Camera</strong>:渲染摄像机</p>
</li>
<li><p><strong>Plane Distance</strong>:画布距离摄像机的距离</p>
</li>
<li><p><strong>Sorting Layer</strong>: Sorting Layer是UGUI专用的设置，用来指示画布的深度。</p>
<p>可以通过点击该栏的选项，在下拉菜单中点击“Add Sorting Layer”按钮进入标签和层的设置界面，或者点击导航菜单-&gt;edit-&gt;Project Settings-&gt;Tags and Layers进入该页面。可以点击“+”添加Layer，或者点击“-”删除Layer。画布所使用的Sorting Layer越排在下面，显示的优先级也就越高。</p>
</li>
<li><p><strong>Order in Layer</strong>:在相同的Sort Layer下的画布显示先后顺序。数字越高，显示的优先级也就越高。</p>
</li>
</ol>
<hr>
<ol start="3">
<li><strong>World Space</strong></li>
</ol>
<p>　　<strong>World Space即世界控件模式</strong>。在此模式下，画布被视为与场景中其他普通游戏对象性质相同的类似于一张面片（Plane）的游戏物体。画布的尺寸可以通过RectTransform设置，所有的UI元素可能位于普通3D物体的前面或者后面显示。当UI为场景的一部分时，可以使用这个模式。</p>
<p>　　它有一个单独的参数Event Camera，用来指定接受事件的摄像机，可以通过画布上的GraphicRaycaster组件发射射线产生事件。</p>
<p>　　这种模式可以用来实现跟随人物移动的血条或者名称</p>
<hr>
<p><strong>区别：</strong></p>
<table>
<thead>
<tr>
<th>渲染模式</th>
<th>画布对应屏幕</th>
<th>摄像机</th>
<th>像素对应</th>
<th>适合类型</th>
</tr>
</thead>
<tbody><tr>
<td>Screen Space-Overlay</td>
<td>是</td>
<td>不需要</td>
<td>可选</td>
<td>2D UI</td>
</tr>
<tr>
<td>Screen Space-Camera</td>
<td>是</td>
<td>需要</td>
<td>可选</td>
<td>2D UI</td>
</tr>
<tr>
<td>World Space</td>
<td>否</td>
<td>需要</td>
<td>不可选</td>
<td>3D UI</td>
</tr>
</tbody></table>
<h4 id="Image和Rawlmage的区别"><a href="#Image和Rawlmage的区别" class="headerlink" title="Image和Rawlmage的区别"></a>Image和Rawlmage的区别</h4><p>1.lmgae比Rawlmage更消耗性能。</p>
<p>2.lmage只能使用Sprite属性的图片，但是Rawlmage什么样的都可以使用。</p>
<p>3.Image适合放一些有操作的图片，裁剪平铺旋转什么的，针对Image Type属性。RawImage就放单独展示的图片就可以，性能会比Image好很多。</p>
<h4 id="unity中的UI层为什么要分为动态和静态"><a href="#unity中的UI层为什么要分为动态和静态" class="headerlink" title="unity中的UI层为什么要分为动态和静态"></a>unity中的UI层为什么要分为动态和静态</h4><p>动态分离出来也是为了减少绘制次数，动态的话 Canves会重新绘制，不分开就会重新绘制一遍静态和动态，增加DC。</p>
<h3 id="Unity-数学问题"><a href="#Unity-数学问题" class="headerlink" title="Unity 数学问题"></a>Unity 数学问题</h3><h4 id="数学问题"><a href="#数学问题" class="headerlink" title="数学问题"></a>数学问题</h4><p><font color = " red"><b>插值运算</b></font></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C#">Mathf.Lerp(start,end,t);<br><span class="hljs-comment">//线性插值</span><br>Vector3.Lerp(start,end,t);<br>两个向量之间的线性差值，适用于从某点移动到某点（或跟随某物体），缓动效果。<br><span class="hljs-comment">//球形插值</span><br>Vector3.Slerp(strart,end,t);<br>两个向量之间的球形（弧线）差值，适用于从某点移动到某点（或跟随某物体），缓动效果，当前位置与目标位置距离越远，效果越明显。非匀速。<br></code></pre></td></tr></table></figure>

<p><strong>Res:</strong><br>$$<br>start + (end - start) * t<br>$$<br>t ：插值系数 取值范围 0~1</p>
<p><strong>作用：</strong></p>
<ol>
<li><p>每帧改变start的值——变化<strong>速度先快后慢，位置无限接近</strong>，但是不会得到end位置</p>
<p><strong>例如：</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">start = Mathf.Lerp(start,<span class="hljs-number">10</span>,Time.deltaTime)<br></code></pre></td></tr></table></figure>
</li>
<li><p>每帧改变t的值——变化速度<strong>匀速</strong>，位置每帧接近，当t&gt;&#x3D;1时得到结果</p>
<p><strong>例如:</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#">time += Time.deltaTime;<br>res = Mathf.Lerp(start,<span class="hljs-number">10.</span>time);<br></code></pre></td></tr></table></figure></li>
</ol>
<p><strong>三角函数</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//弧度转角度</span><br><span class="hljs-comment">//弧度 * 57.3f = 对应角度</span><br><span class="hljs-built_in">float</span> rad = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">float</span> anger = rad * Mathf.Rad2Deg;<br><br><span class="hljs-comment">//角度转弧度</span><br><span class="hljs-comment">//角度 * 0.01745 = 对应弧度</span><br>anger = <span class="hljs-number">1</span>;<br>rad = anger * Mathf.Deg2Rad;<br><br><span class="hljs-comment">//三角函数</span><br><span class="hljs-comment">//Mathf的三角函数相关函数，传入的参数需要弧度值</span><br>Mathf.Sin(<span class="hljs-number">30</span> * Mathf.Deg2Rad);<br>Mathf.Cos(<span class="hljs-number">60</span> * Mathf.Deg2Rad);<br><br><span class="hljs-comment">//反三角函数</span><br>rad = Mathf.Asin(<span class="hljs-number">0.5f</span>);<br>print(rad * Mathf.Rad2Deg);<br><br></code></pre></td></tr></table></figure>

<blockquote>
<p>Unity中使用的是左手还是右手坐标系？我们需要注意什么？</p>
</blockquote>
<p><strong>左手坐标系</strong><br>在进行向量相关计算时，要注意左手和右手坐标系的区别</p>
<hr>
<h4 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//世界转本地</span><br><span class="hljs-keyword">this</span>.transform.InverseTransformDirection;<br><span class="hljs-keyword">this</span>.transform.InverseTransformPoint;<br><span class="hljs-keyword">this</span>.transform.InverseTransformVector;<br><br><span class="hljs-comment">//本地转世界</span><br><span class="hljs-keyword">this</span>.transform.TransformDirection;<br><span class="hljs-keyword">this</span>.transform.TransformPoint;<br><span class="hljs-keyword">this</span>.transform.TransformVector;<br><br><span class="hljs-comment">//世界转屏幕</span><br>Camera.main.WorldToScreenPoint;<br><span class="hljs-comment">//屏幕转世界</span><br>Camera.main.ScreenToWorldPoint;<br><br><span class="hljs-comment">//世界转视口</span><br>Camera.main.WorldToViewportPoint;<br><span class="hljs-comment">//视口转世界</span><br>Camera.main.ViewportToWorldPoint;<br><br><span class="hljs-comment">//视口转屏幕</span><br>Camera.main.ViewportToScreenPoint;<br><span class="hljs-comment">//屏幕转视口</span><br>Camera.main.ScreenToViewportPoint;<br></code></pre></td></tr></table></figure>


<hr>
<h4 id="向量问题"><a href="#向量问题" class="headerlink" title="向量问题"></a>向量问题</h4><p>$$<br>AB &#x3D; B - A<br>$$</p>
<p><strong>向量模长</strong></p>
<p>向量的模长就是<strong>向量的长度</strong></p>
<p>向量是由两个点算出，所以向量的模长就是<strong>两个点的距离</strong></p>
<p><strong>公式：</strong><br>$$<br>√x²+y²+z²<br>$$</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C#">Vector3 A = Vector3.forward;<br>Vector3 B = Vector3.up;<br>Vector3 AB = B - A;<br><span class="hljs-comment">//获取模长，下面两种都可以获得两点的距离长度</span><br>AB.magnitude;<br>Vector3.Distance(A,B);<br></code></pre></td></tr></table></figure>

<p><strong>单位向量</strong></p>
<p><strong>模长为1的向量为单位向量</strong>，任意一个向量经过归一化就是单位向量</p>
<p><strong>只需要方向，不想让模长影响计算结果时使用单位向量</strong></p>
<p><strong>公式：</strong><br>$$<br>(x&#x2F;模长,y&#x2F;模长,z&#x2F;模长)<br>$$</p>
<blockquote>
<p>Unity中点乘和叉乘对于我们来说的作用是什么？</p>
</blockquote>
<p><font color = "red"><b>点乘作用</b></font></p>
<ol>
<li><strong>判断对象的方位</strong></li>
<li><strong>计算两向量之间的夹角</strong></li>
</ol>
<blockquote>
<p>用点乘实现散弹角度实现机制</p>
</blockquote>
<p> 以枪口方向为轴，上下或者左右为展开方向。获取夹角。利用点乘的方法。</p>
<ol>
<li>通过Vector3.Dot（向量A，向量B）获取两个向量的点乘C。</li>
<li>然后通过Acos C 然后由弧度转换为角度即可。</li>
<li>弧度乘以Mathf.Rad2Deg得到角度;</li>
</ol>
<p><font color = "red"><b>叉乘作用</b></font></p>
<ol>
<li><p><strong>获取一个平面的法向量</strong></p>
</li>
<li><p><strong>得到两向量之间的左右位置关系</strong></p>
</li>
</ol>
<p><strong>点乘</strong>：向量 A * 向量 B &#x3D; （A1A2,B1B2,C1C2）</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">Vector3.Dot（）;<br></code></pre></td></tr></table></figure>

<p>点乘结果 &gt; 0 两个向量夹角为锐角</p>
<p>点乘结果 &#x3D; 0 两个向量夹角为直角</p>
<p>点乘结果 &lt; 0 两个向量夹角为钝角</p>
<p>点乘 &gt;  0 为前方</p>
<p>点乘 &lt; 0 为后方</p>
<p><strong>叉乘：</strong>向量 A * 向量 B &#x3D; （B1C2 - C1B2 , A1C2 - C1A1 , A1B2 - B1A2）</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">Vector3.Cross（）;<br></code></pre></td></tr></table></figure>

<p>叉乘结果 y &gt; 0 右侧</p>
<p>叉乘结果 y &lt; 0 左侧</p>
<blockquote>
<p>Unity中如何计算出两个向量之间的夹角，请说出两种方式</p>
</blockquote>
<ol>
<li>利用Vector3中的API：<strong>Vector3.Angle</strong></li>
<li>先使用 <strong>Vector3.Dot 算出方向向量点乘结果</strong>，再<strong>通过Mathf.Acos反三角函数算出弧度</strong>，再将<strong>弧度转为角度</strong></li>
</ol>
<blockquote>
<p>矩阵相乘的意义及注意点</p>
</blockquote>
<p><strong>意义：</strong>用于表示<strong>线性变换：旋转、缩放、投影、平移、仿射</strong></p>
<p><strong>注意：</strong>矩阵的蠕变：误差的积累</p>
<hr>
<h4 id="四元数"><a href="#四元数" class="headerlink" title="四元数"></a>四元数</h4><p>简单来说，四元数本质上是一种高阶复数，是一个四维空间，相对于复数的二维空间。四元数由实数加上三个虚数单位组成，主要用于在三维空间中表试旋转。</p>
<p>一个四元数包含<strong>一个标量和一个3D向量</strong></p>
<p>[w,v],w为标量，v为3D向量，[w,(x,y,z)]<br>$$<br>四元数Q &#x3D;[cos(β&#x2F;2),sin(β&#x2F;2)x,sin(β&#x2F;2)y,sin(β&#x2F;2)z]<br>$$<br>对于给定的任意一个四元数：<strong>表试3D空间的一个旋转量</strong></p>
<blockquote>
<p>四元数的作用？</p>
</blockquote>
<p>四元数用于<strong>表示旋转</strong>。</p>
<p>其相对于欧拉角的优点：</p>
<ol>
<li>避免万向锁。</li>
<li>只需要一个4维的四元数就可以执行绕任意过原点的向量的旋转，方便快捷，在某些实现下比旋转矩阵效率更高。</li>
<li>可以提供平滑插值。</li>
</ol>
<blockquote>
<p>两个四元数相乘有什么作用？</p>
</blockquote>
<p>四元数相乘：角度叠加,代表旋转四元数</p>
<blockquote>
<p>四元数乘以向量有什么作用？</p>
</blockquote>
<p>四元数乘以向量：向量旋转</p>
<blockquote>
<p>Unity场景中有两个点连成了一条线，想要旋转这条线，应该怎么做？</p>
</blockquote>
<p>两点相减得到一条向量，向量乘以四元数即可</p>
<hr>
<h4 id="欧拉角"><a href="#欧拉角" class="headerlink" title="欧拉角"></a>欧拉角</h4><p>欧拉角用于表示刚体当前的姿态。</p>
<p>用一句话说，欧拉角就是<strong>物体绕坐标系三个坐标轴(x,y,z轴）的旋转角度</strong>。</p>
<ol>
<li><p>静态：即绕世界坐标系三个轴的旋转，由于物体旋转过程中坐标轴保持静止，所以称为静态。</p>
</li>
<li><p>动态：即绕物体坐标系三个轴的旋转，由于物体旋转过程中坐标轴随着物体做相同的转动，所以称为动态。<br>物体的任何一种旋转都可分解为分别绕三个轴的旋转，但分解方式不唯一。</p>
</li>
</ol>
<p>unity 3D欧拉角的<strong>旋转顺序（父子关系）是y-x-z</strong>。</p>
<p>unity中最简单的万向锁就是先让X轴旋转90度，z轴旋转和y轴旋转效果是一样。</p>
<p><strong>思想</strong>：将刚体绕某一轴的一次旋转，分解为依次分别绕X、Y、Z轴的三次旋转。这三个轴分别旋转的转动角度，就是一组三个欧拉角。</p>
<p>图片中即为上述的三次旋转（而其实可以绕某一轴，一次旋转即可达到最终位置）</p>
<p><img src="https://pic2.zhimg.com/v2-35da80e428ca5750491ffd2770e187e1_b.webp" srcset="/img/loading.gif" lazyload alt="动图"></p>
<p>具体旋转过程举例，如图：</p>
<p><img src="https://pic1.zhimg.com/80/v2-6a4e77fe8ead57f7384a1491d1c73ab0_720w.webp" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>图中有两组坐标系，我们定义为：</p>
<ul>
<li>xyz ：世界坐标系（固定不动）</li>
<li>XYZ ：刚体坐标系（与刚体同步运动）</li>
</ul>
<p>具体旋转步骤为：</p>
<ul>
<li>1、绕<strong>世界系</strong>的 z 轴，旋转 α 角。</li>
<li>2、绕<strong>刚体系</strong>的 X 轴，旋转 β 角。</li>
<li>3、绕<strong>刚体系</strong>的 Z 轴，旋转 是 γ 角。</li>
</ul>
<p>下面有一个直观的动图展示。</p>
<p><img src="https://pic1.zhimg.com/v2-5480232b0c74e8d236044529bd170834_b.webp" srcset="/img/loading.gif" lazyload alt="动图"></p>
<p>动图旋转步骤为 z→Y→X ，按照顺序标记为 zYX，加上角度即为一个完整欧拉角：</p>
<p>zYX — （ψ，θ，Φ）</p>
<hr>
<h4 id="万向节死锁"><a href="#万向节死锁" class="headerlink" title="万向节死锁"></a>万向节死锁</h4><p>万向锁（英语：Gimbal lock）<strong>是在使用动态欧拉角表示三维物体的旋转时出现的问题。</strong><br>万向节死锁的<strong>根本问题是欧拉角（EulerAngles）保存的信息不足以描述空间中的唯一转向。</strong></p>
<p>这种围绕选旋转前固定轴的<strong>先Z、再X、再Y的旋转操作</strong>，与其最终所预期的三个轴向可以旋转的结果并非一定是一对一的映射。某些情况下是多对一的映射，造成一些旋转自由度的缺失，也就是“死锁”。</p>
<p>在Unity 上 当某个特定轴达到某个特殊值时，<strong>绕一个轴旋转可能会覆盖住另一个轴的旋转，从而失去一维自由度。</strong></p>
<p><strong>Unity的X轴达到90度时，会产生万向节死锁</strong></p>
<p><strong>陀螺仪中的万向节死锁</strong></p>
<p>现在看起来，这个陀螺仪一切正常，在船体发生任意方向摇晃都可以通过自身调节来应对。然而，真的是这样吗？</p>
<p>假如，船体发生了剧烈的变化，此时船首仰起了90度，此时的陀螺仪调节状态如下图：</p>
<p><img src="https://img-blog.csdn.net/20170311165114162?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQW5kcmV3RmFu/font/5a6L5L2T/fontsize/200/fill/I0JBQkFCMA==/dissolve/70/gravity/NorthEast" srcset="/img/loading.gif" lazyload alt="死锁开始"></p>
<p>此时，船体再次发生转动，沿着当前世界坐标的+Z轴（蓝色轴，应该正指向船底）进行转动</p>
<p><img src="https://img-blog.csdn.net/20170311165659086?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQW5kcmV3RmFu/font/5a6L5L2T/fontsize/200/fill/I0JBQkFCMA==/dissolve/70/gravity/NorthEast" srcset="/img/loading.gif" lazyload alt="死锁的陀螺仪"></p>
<p>现在，转子不平衡了，陀螺仪的三板斧不起作用了。它失去了自身的调节能力。<br>之前陀螺仪之所以能通过自身调节，保持平衡，是因为存在可以相对旋转的连接头。在这种情况下，已经不存在可以相对旋转的连接头了。<br>那么连接头呢？去了哪里？显然，它还是在那里，只不过是，连接头可以旋转的相对方向不是现在需要的按着+Z轴方向。从上图中，我们清楚地看到：</p>
<ul>
<li><p>红色连接头：可以给予一个相对俯仰的自由度。</p>
</li>
<li><p>绿色连接头：可以给予一个相对偏航的自由度。</p>
</li>
<li><p>蓝色连接头：可以给予一个相对偏航的自由度。</p>
</li>
</ul>
<p>没错，三个连接头，提供的自由度只对应了俯仰和偏航两个自由度，桶滚自由度丢失了。这就是<strong>陀螺仪上的“万向节死锁”问题</strong>。</p>
<hr>
<h4 id="各种旋转优缺点"><a href="#各种旋转优缺点" class="headerlink" title="各种旋转优缺点"></a>各种旋转优缺点</h4><ul>
<li><p><strong>矩阵旋转</strong></p>
<ul>
<li><p><strong>优点：</strong></p>
<p>旋转轴可以是任意向量；</p>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li>旋转其实只需要知道一个向量+一个角度，一共4个值的信息，但矩阵法却使用了16个元素；</li>
<li>而且在做乘法操作时也会增加计算量，造成了空间和时间上的一些浪费；</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>欧拉旋转</strong></p>
<ul>
<li><p><strong>优点：</strong></p>
<ul>
<li>很容易理解，形象直观；</li>
<li>存储空间小</li>
<li>可以进行从一个方向到另一个方向旋转大于180度的角度</li>
<li>表示更方便，只需要3个值（分别对应x、y、z轴的旋转角度）；但按我的理解，它还是转换到了3个3*3的矩阵做变换，效率不如四元数；</li>
</ul>
</li>
<li><p><strong>缺点：</strong></p>
<ul>
<li><strong>同一旋转的表试不唯一</strong>；</li>
<li><strong>会造成万向节锁（Gimbal Lock）的现象</strong>。这种现象的发生就是由于上述固定坐标轴旋转顺序造成的。理论上，欧拉旋转可以靠这种顺序让一个物体指到任何一个想要的方向，但如果在旋转中不幸让某些坐标轴重合了就会发生万向节锁，这时就会丢失一个方向上的旋转能力，也就是说在这种状态下我们无论怎么旋转（当然还是要原先的顺序）都不可能得到某些想要的旋转效果，除非我们打破原先的旋转顺序或者同时旋转3个坐标轴。这里有个视频可以直观的理解下；</li>
<li>由于万向节锁的存在，欧拉旋转无法实现球面平滑插值；</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>四元数旋转</strong></p>
<ul>
<li><strong>优点：</strong><ul>
<li>可以避免万向节锁现象；</li>
<li>只需要一个4维的四元数就可以执行绕任意过原点的向量的旋转，方便快捷，在某些实现下比旋转矩阵效率更高；</li>
<li>可以提供平滑插值；</li>
</ul>
</li>
<li>缺点：<ul>
<li>比欧拉旋转稍微复杂了一点点，因为多了一个维度；</li>
<li>理解更困难，不直观；</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="Unity-性能优化"><a href="#Unity-性能优化" class="headerlink" title="Unity 性能优化"></a>Unity 性能优化</h3><p><strong>内存：</strong></p>
<ol>
<li><p>尽量要占用少</p>
<ul>
<li><strong>使用对象池：</strong>对象池是一种常见的技术，用于缓存和重复使用游戏对象，而不是频繁地创建和销毁它们。使用对象池可以减少内存分配和垃圾回收的开销，从而提高游戏性能。</li>
<li><strong>减少资源占用：</strong>在开发过程中，应该尽量避免使用过多的高分辨率纹理和复杂的模型。可以使用纹理压缩、减少纹理尺寸、使用轻量级的模型等方式来减小资源占用。</li>
<li><strong>及时销毁不再使用的对象：</strong>当游戏中不再需要使用某些对象时，应该及时销毁它们，以释放它们占用的内存。尤其是一些长时间存在的对象，如粒子系统、音频和视频资源等，都应该及时销毁。</li>
<li><strong>使用异步加载：</strong>如果游戏中需要加载大量的资源，可以使用异步加载技术。异步加载可以减少游戏卡顿和内存占用，从而提高游戏性能。可以使用Unity提供的异步加载API或者自定义异步加载方式来实现异步加载。</li>
<li><strong>使用资源打包：</strong>在打包游戏时，可以使用资源打包技术来减少游戏的内存占用。资源打包可以将多个资源打包成一个单独的文件，从而减小游戏的内存占用。可以使用Unity提供的Asset Bundle功能或者自定义打包方式来实现资源打包。</li>
</ul>
</li>
<li><p>减少GC</p>
</li>
</ol>
<p><strong>CPU&#x2F;GPU性能</strong></p>
<ol>
<li><p><strong>减少Draw Call</strong>：在Unity中，每次渲染一个物体都会使用一个Draw Call。过多的Draw Call会导致渲染性能下降，因此应该尽量减少它们的数量。可以通过合并网格、使用物体批处理和减少物体数量等方式来减少Draw Call。</p>
</li>
<li><p><strong>使用级别LOD</strong>：如果场景中有大量的物体，可以使用级别LOD技术来优化性能。通过在远离玩家的位置使用低分辨率的网格，可以降低渲染开销，提高性能。</p>
</li>
<li><p><strong>合理使用资源</strong>：在开发过程中，应该尽量避免使用过多的高分辨率纹理和复杂的模型。可以使用纹理压缩、减少纹理尺寸、使用轻量级的模型等方式来减小资源占用。</p>
</li>
<li><p><strong>使用光照贴图</strong>：在游戏中，光照是非常重要的，但是使用动态光照会带来很大的渲染开销。因此，可以使用光照贴图来减少动态光照的数量。光照贴图可以在编辑器中生成，并且可以有效地提高游戏的性能。</p>
</li>
<li><p><strong>使用对象池</strong>：对象池是一种常见的技术，用于缓存和重复使用游戏对象，而不是频繁地创建和销毁它们。使用对象池可以减少内存分配和垃圾回收的开销，从而提高游戏性能。</p>
</li>
</ol>
<h3 id="Unity-对象移动"><a href="#Unity-对象移动" class="headerlink" title="Unity 对象移动"></a>Unity 对象移动</h3><p><strong>1.Transform</strong></p>
<p>​    通过 Update 函数每帧更新其位置来达到移动目的。</p>
<p>​     <strong>1.1 Transform.position</strong></p>
<p>​    向量相加</p>
<p>​    最基础的移动方式，每帧+&#x3D;计算好的新位置，更加直观。 </p>
<p>​     <strong>1.2 Transform.Translate</strong></p>
<p>​    在平移的方向和距离上移动变换。</p>
<p>​    <strong>每秒</strong>向某方向移动多少距离，此种方法和上一种没有太大区别，但当需要坐标转换时，使用此方法可省略转换步骤。</p>
<p><strong>2. Vector3</strong></p>
<p>​	Vector3 类型可以存储物体的位置、方向。 V3 自带的类方法通过对位置的一些运算得到相对平滑的参数，其移动本质还是修改物体的 position。</p>
<ol start="2">
<li>1 <strong>Vector3.Lerp</strong></li>
</ol>
<p>​	两个向量之间的线性插值，适用于从某点移动到某点（或跟随某物体），缓动效果。</p>
<ol start="2">
<li>2 <strong>Vector3.Slerp</strong></li>
</ol>
<p>​	两个向量之间的球形（弧线）插值，适用于从某点移动到某点（或跟随某物体），缓动效果，当前位置与目标位置距离越远，效果越明显。<strong>非匀速。</strong></p>
<ol start="2">
<li>3 <strong>Vector3.MoveTowards</strong></li>
</ol>
<p>​	和 Lerp 函数基本相同，但此函数多了一个最大速度限制，且是<strong>匀速</strong>朝目标运动，而 Lerp 和 Slerp 则是将抵达位置时放缓（减速）</p>
<ol start="2">
<li><p>4 <strong>Vector3.SmoothDamp</strong></p>
<p>​	官方翻译为：“平滑阻尼”，无比丝滑的从 A 移动到 B 点，速度可控，比较适用于摄像机跟随，Lerp 也比较适用于摄像机跟随</p>
</li>
</ol>
<p><strong>3. Rigidbody</strong></p>
<p>​	Rigidbody 组件通过物理模拟来控制一个物体的位置，当使用此组件控制物体移动时，应在 FixedUpdate 函数中更新数据，该方法会在每一次执行物理模拟前被调用，这样要比 Update 函数更加精确。</p>
<p>​	<strong>3.1</strong> <strong>AddForce</strong></p>
<p>​    添加一个方向的力到刚体，刚体将开始移动，这种方式适合模拟外力作用下的刚体运动，如子弹。但注意，此力是累加的，不适合重复施加力来模拟物体！</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">AddForce(有方向的力(V3)</span>，力的模式(ForceMode,默认：ForceMode.Force))<br><br><span class="hljs-constructor">ForceMode(力的模式)</span>:<br><br><span class="hljs-number">1.</span><span class="hljs-constructor">Force(可持续的力，受质量影响)</span><br><br><span class="hljs-number">2.</span><span class="hljs-constructor">Acceleration(可持续的加速度，不受质量影响)</span><br><br><span class="hljs-number">3.</span><span class="hljs-constructor">Impulse(一个瞬间冲击力，受质量影响)</span><br><br><span class="hljs-number">4.</span><span class="hljs-constructor">VelocityChange(一个瞬间速度变化，不受质量影响)</span><br><br>  public <span class="hljs-built_in">float</span> forceNumber = <span class="hljs-number">20</span>f;<br> <br>     public Rigidbody rig; <span class="hljs-comment">//获取当前物体的刚体组件</span><br> <br>     void <span class="hljs-constructor">FixedUpdate()</span><br> <br>     &#123;<br> <br>         Vector3 force = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Vector3(0, 0, <span class="hljs-params">forceNumber</span>)</span>;<br> <br>         rig.<span class="hljs-constructor">AddForce(<span class="hljs-params">force</span>, ForceMode.Force)</span>;<br>     &#125; <br><br><br></code></pre></td></tr></table></figure>

<ol start="3">
<li>2 <strong>MovePosition</strong></li>
</ol>
<p>​	移动刚体到一个新的位置，移动的同时受到物理模拟的影响。</p>
<ol start="3">
<li>3 <strong>Velocity</strong></li>
</ol>
<p>​	瞬间给一个物体恒定的速度，将该物体提升到这个速度，保持。相比较 AddForce 更加适合跳跃功能。每次跳跃都是恒定高度。做跳跃的话： </p>
<ol start="4">
<li><strong>Character Controller</strong></li>
</ol>
<p>​	角色控制器顾名思义，是 Unity 推出的特别用于角色移动的组件，使用角色控制器的物体有刚体的效果，但不会翻滚（意思是运动仅受限于碰撞体，不受其他因素影响），很适合角色移动。还可以设置斜坡参数，一定坡度自动抬升，本身也是个碰撞体。</p>
<p>​	4 .1 <strong>SimpleMove</strong></p>
<p>​    以一定速度移动角色，<strong>以秒为单位</strong>，无需乘以时间，<strong>具备重力。</strong></p>
<p>​	4 .2 <strong>Move</strong></p>
<p>​    以一定速度移动角色,不具备重力，需要自行计算下落</p>
<h3 id="Unity-寻路"><a href="#Unity-寻路" class="headerlink" title="Unity 寻路"></a>Unity 寻路</h3><p>NavMesh是一种基于多边形网络的寻路导航系统，整个寻路分为导航网格的构建和寻路算法两个部分。</p>
<p>（1）烘焙导航网格</p>
<p>（2）需要导航的物体添加 NavMeshAgent 组件</p>
<p>（3）运行时候使用 NavMeshAgent.SetDestination 函数进行导航</p>
<h3 id="Unity-Mask实现原理"><a href="#Unity-Mask实现原理" class="headerlink" title="Unity Mask实现原理"></a>Unity Mask实现原理</h3><p><strong>Mask的实现原理：</strong></p>
<ol>
<li>Mask会赋予Image一个特殊的材质，这个材质会给Image的每个像素点进行标记，将标记结果存放在一个缓存内（这个缓存叫做 Stencil Buffer）</li>
<li>当子级UI进行渲染的时候会去检查这个 Stencil Buffer内的标记，如果当前覆盖的区域存在标记（即该区域在Image的覆盖范围内），进行渲染，否则不渲染。</li>
</ol>
<h3 id="Unity-帧同步"><a href="#Unity-帧同步" class="headerlink" title="Unity 帧同步"></a>Unity 帧同步</h3><blockquote>
<p> 什么是帧同步？</p>
</blockquote>
<p><strong>帧同步是一种前后端数据同步的方式，一般应用于对实时性要求很高的网络游戏。</strong></p>
<p><strong>基本实现流程及思路可以概括为</strong></p>
<ol>
<li>所有客户端每帧上传操作指令集到服务器;</li>
<li>服务端将这些操作指令集保存到对应帧序列字典，并记录帧号，并在下一帧将其广播给所有客户端;</li>
<li>客户端收到指令集后，分别按帧序，帧号进行执行指令集中的操作命令。</li>
<li>也就是：<strong>相同的时机(帧序列) + 相同的操作命令(指令集-确定性) &#x3D; 相同的结果(帧同步)</strong></li>
</ol>
<h3 id="Unity的GC"><a href="#Unity的GC" class="headerlink" title="Unity的GC"></a>Unity的GC</h3><ol>
<li><p><strong>贝姆垃圾收集器</strong></p>
<p>Untiy使用的GC机制是通过贝姆垃圾收集器（Boehm GC）来实现的，是应用在C&#x2F;C++语言上的一个保守的垃圾回收器，同时也适用于其它执行环境的各类编程语言，比如我们使用的基于mono实现的C#。</p>
</li>
<li><p><strong>回收机制</strong></p>
</li>
</ol>
<p>​	Unity的GC的是采用 <strong>贝姆垃圾收集器</strong> ，本质上采用的是<strong>非分代非压缩的标记清除算法</strong>。</p>
<p>​	它会在需要进行GC时占用主线程，进行<strong>遍历-标记-垃圾回收</strong>的过程，然后在归还主线程控制权。这会导致帧数的突然下降，产生卡顿（不过因为该实现是非压缩式的，所以卡顿现象相对较轻，但是对内存利用率进一步下降了，会有内存碎片的问题）。</p>
<p>​	所以我们需要慎重地处理对象的创建（内存请求），还有释放（使用GC管理内存是没有主动释放内存的接口的，但是我们可以通过消除对某个对象的引用来做到这一点）。此外，Unity的代码分为两部分：<strong>托管与非托管</strong>，GC影响的只有托管部分的代码使用的堆内存。而且这个托管堆占用的地址空间不会返还给操作系统。</p>
<p>​	标记清楚算法可以解决两个变量相互引用，产生标记的现象。</p>
<ol start="3">
<li><p><strong>托管堆的垃圾回收机制</strong></p>
<p> Unity使用的垃圾机制是<strong>Boehm GC算法</strong>，他是<strong>非分代，非压缩</strong>的。<strong>非分代意味着每次回收都需要扫描整个堆</strong>，而<strong>非压缩则意味着内存分配后整个托管堆会存在间隙或者说内存碎片</strong>。这两个特点意味着Unity中托管堆的垃圾回收机制会耗时较长而且内存利用率存在着问题。</p>
</li>
<li><p><strong>整个垃圾回收的流程</strong></p>
<ol>
<li><p>停止所有进行托管堆内存分配的线程。        </p>
</li>
<li><p>找到所有不再被需要的内存，将其标记为垃圾。</p>
</li>
<li><p>将所有被标记的内存释放到空闲内存。</p>
</li>
<li><p>恢复之前停止的托管堆内存分配的线程。</p>
</li>
</ol>
</li>
<li><p><strong>GC优化</strong><br> GC对性能影响的原因（占用主线程进行大量工作），而优化GC即是减小占用GC占用主线程时花费的CPU时间，所以优化GC优化的是CPU时间，而非内存。</p>
</li>
</ol>
<h3 id="Unity和Android与iOS如何交互？"><a href="#Unity和Android与iOS如何交互？" class="headerlink" title="Unity和Android与iOS如何交互？"></a>Unity和Android与iOS如何交互？</h3><p>UnitySendMessage(“Cube111”,”methodName111”,”传给unity。。。”);</p>
<h3 id="Unity-Text-和-TMPtext的区别-优缺点"><a href="#Unity-Text-和-TMPtext的区别-优缺点" class="headerlink" title="Unity Text 和 TMPtext的区别 优缺点"></a>Unity Text 和 TMPtext的区别 优缺点</h3><p>​		Text是像素渲染放大之后就会模糊，<strong>使用Text父物体的放大缩小会影响子物体Text的清晰度</strong>， <strong>TMPtext不会，它是网格渲染TMPtext会把字体生成一个类似于贴图的东西然后读取贴图的坐标来获取对应的文字</strong>，更换文字的<strong>消耗会比Text大</strong>，<strong>TMPtext适用于那种不会变动的文字</strong>，特别是在量大的情况下，性能比Text高一些，需要<strong>经常变动的问题用Text好点</strong>，TMPtext在字体库很大的情况下查找更换会比较慢。</p>
<h3 id="Unity-行为树和有限状态机"><a href="#Unity-行为树和有限状态机" class="headerlink" title="Unity 行为树和有限状态机"></a>Unity 行为树和有限状态机</h3><p><strong>有限状态机系统</strong>：是指在不同阶段会呈现出不同的运行状态的系统，这些状态是有限的、不重叠的。这样的系统在某一时刻一定会处于其所有状态中的一个状态，此时它接收一部分允许的输入，产生一部分可能的响应，并且迁移到一部分可能的状态。</p>
<ol>
<li>基本节点是状态：他包含了一系列运行在该状态的行为以及离开这个状态的条件。</li>
</ol>
<ol start="2">
<li><p>状态可以任意跳转,实现简单,但是对于大的状态机很难维护，状态逻辑的重用性低。</p>
</li>
<li><p>每一个状态的逻辑会随着一些新状态的增加而越来越复杂。维持状态的数量和状态逻辑复杂性是一个很大的难点。需要合理的分割以及重用状态。</p>
</li>
<li><p>状态机状态的复用性很差，一旦一些因素变化导致这个环境发生变化。你只能新增一个状态，并且给这个新状态添加连接他以及其他状态的跳转逻辑。</p>
</li>
<li><p>状态机的跳转条件一旦不满足，就会一直卡在某一个状态。</p>
</li>
</ol>
<p><strong>行为树：</strong>一个流行的AI技术，涵盖了层次状态机，事件调度，事件计划，行为等一系列技术。实现AI的过程更加得有技巧，框架设计者较为全面考虑了我们可能会遇到的种种情况，把每种情况都抽象成了一个类型的节点，而我们要做的就是按照规范去写节点，然后把节点连接成一颗行为树。更加得具有面向对象的味道，行为模块间的藕合度相对较低。</p>
<ol>
<li>高度模块化状态，去掉状态中的跳转逻辑，使得状态变成一个“行为”。</li>
</ol>
<ol start="2">
<li><p>“行为”和”行为”之间的跳转是通过父节点的类型来决定的。比如并行处理两个行为，在状态机里面无法同时处理两个状态。</p>
</li>
<li><p>通过增加控制节点的类型，可以达到复用行为的目的。</p>
</li>
<li><p>可视化编辑。</p>
</li>
</ol>
<p><strong>行为树的概念</strong>：</p>
<p>对于<strong>有限状态机</strong>而言，<strong>必须明确状态的转换方式</strong>；</p>
<p>对于<strong>行为树</strong>，必须明确状态前提：<strong>前提条件</strong>。</p>
<p>每一个行为必须有“前提条件” ，这决定了该行为是否被选择。<br>行为树的运算也是通过帧循环的update来驱动，不一定是每帧都update，但是要周期性update。<br>每一次run从根节点(root)开始，每一运行都会选择一个可行的子节点运行，这种选择可以是随机方式，也可以是预设好优先条件。<br>行为树由叶子节点和中间节点组成，叶子节点是最基本的行为(如跑动，攻击)，中间节点代表逻辑单元(巡逻，逃跑)。<br>当一个叶子节点被选择后，就会激活其对应的基本的行为。<br>最基本的行为可能执行成功也可能失败。<br>高等级的行为（中间节点）是否执行成功依赖于他们的孩子节点是否执行成功。<br>一个子节点失败可能导致父母节点选择另外一个孩子。<br>除了选择(selector)一个单独的子节点行为，一个节点还可能顺序(sequence)or并行(concurrent)得运行他的所有子节点。<br>一个行为除了有前提条件，可能还有上下文条件(父节点or孩子节点可能存储一定的状态变量)。<br>高优先级的行为可能抢占低优先级的行为。<br>优点：</p>
<ol>
<li><p>行为逻辑和状态数据分离，任何节点写好以后可以反复利用。</p>
</li>
<li><p>重用性高，可用通过重组不同的节点来实现不同的行为树。</p>
</li>
<li><p>呈线性的方式扩展，易于扩展。</p>
</li>
<li><p>可配置，把工作交给designer。</p>
</li>
<li><p>能够胜任”AI” “掉宝”等等场景。</p>
</li>
</ol>
<p>缺点：</p>
<ol>
<li><p>每一帧都从root开始，有可能会访问到所有的节点，相对State Machine消耗更多的cpu。</p>
</li>
<li><p>任何一个简单的操作都必须要使用节点。</p>
</li>
</ol>
<h3 id="Unity中判断两个2D矩形是否相交，有几种方式？（请至少说出两种方式）"><a href="#Unity中判断两个2D矩形是否相交，有几种方式？（请至少说出两种方式）" class="headerlink" title="Unity中判断两个2D矩形是否相交，有几种方式？（请至少说出两种方式）"></a>Unity中判断两个2D矩形是否相交，有几种方式？（请至少说出两种方式）</h3><ol>
<li>使用Unity物理系统进行碰撞检测</li>
<li>使用Unity中范围检测相关API</li>
<li>自己写算法进行检测</li>
</ol>
<h3 id="Unity制作物理游戏相关功能时，我们采用哪种方式处理位移？为什么？"><a href="#Unity制作物理游戏相关功能时，我们采用哪种方式处理位移？为什么？" class="headerlink" title="Unity制作物理游戏相关功能时，我们采用哪种方式处理位移？为什么？"></a>Unity制作物理游戏相关功能时，我们采用哪种方式处理位移？为什么？</h3><p>通过刚体相关API来处理位移，比如加力、改变刚体速度变量<br>原因：在碰撞检测时能更准确无误</p>
<h3 id="Unity中想要制作角色的连招功能，在制作状态机时我们一般如何处理？"><a href="#Unity中想要制作角色的连招功能，在制作状态机时我们一般如何处理？" class="headerlink" title="Unity中想要制作角色的连招功能，在制作状态机时我们一般如何处理？"></a>Unity中想要制作角色的连招功能，在制作状态机时我们一般如何处理？</h3><ol>
<li>状态机条件可以添加一个Trigger类型和Int类型<br>   Trigger条件主要用于触发动作，Int条件主要用于连招计数判断</li>
<li>逻辑上，当攻击按键输入时，我们需要触发动作，并且进行攻击计数<br>   每次按键时都应该重新进      行攻击计数延迟清零</li>
</ol>
<h3 id="Unity中想要制作自动寻路逻辑，我们应该怎么做？（请至少说出两种做法）"><a href="#Unity中想要制作自动寻路逻辑，我们应该怎么做？（请至少说出两种做法）" class="headerlink" title="Unity中想要制作自动寻路逻辑，我们应该怎么做？（请至少说出两种做法）"></a>Unity中想要制作自动寻路逻辑，我们应该怎么做？（请至少说出两种做法）</h3><ol>
<li>Unity自带的网格寻路系统</li>
<li>自定义寻路算法（比如 A星寻路算法）</li>
</ol>
<h3 id="Unity中如果想要在动作的某一时刻进行伤害检测，我们应该怎么做？（请说出两种做法）"><a href="#Unity中如果想要在动作的某一时刻进行伤害检测，我们应该怎么做？（请说出两种做法）" class="headerlink" title="Unity中如果想要在动作的某一时刻进行伤害检测，我们应该怎么做？（请说出两种做法）"></a>Unity中如果想要在动作的某一时刻进行伤害检测，我们应该怎么做？（请说出两种做法）</h3><p>1.　添加动画事件<br>2.　在切换动画一开始，进行延迟触发，延迟时间为想要触发伤害的时间（延迟可以用延迟函数，也可以用协同程序）</p>
<h3 id="游戏编辑器（比如-角色编辑器、关卡编辑器、地图编辑器等工具）的本质是什么？"><a href="#游戏编辑器（比如-角色编辑器、关卡编辑器、地图编辑器等工具）的本质是什么？" class="headerlink" title="游戏编辑器（比如 角色编辑器、关卡编辑器、地图编辑器等工具）的本质是什么？"></a>游戏编辑器（比如 角色编辑器、关卡编辑器、地图编辑器等工具）的本质是什么？</h3><p>数据的图形化编辑工具</p>
<h3 id="动态加载资源的方式？他们之间的区别"><a href="#动态加载资源的方式？他们之间的区别" class="headerlink" title="动态加载资源的方式？他们之间的区别"></a>动态加载资源的方式？他们之间的区别</h3><ol>
<li><strong>Resources</strong></li>
</ol>
<p>Resource类中的相关方法加载Resources文件夹下的资源</p>
<p>Resources是动态内部调用，Resources在编辑环境下是project窗口的一个文件夹，调用里面的资源，可以用Resources类，比如Resources.Load，打包后这个文件夹是不存在的，会统一生成assets资源</p>
<ol start="2">
<li><strong>AssetBundle、Addressables</strong></li>
</ol>
<p>AssetBundle类中或Addressables类中的相关方法加载AB包中的资源</p>
<p>AssetBundle 是外部调用，要用AssetBundle 首先要先把资源打包为.assetbundle文件，再动态的去加载这个文件，本地或者网络服务器都可以。</p>
<ol start="3">
<li><strong>WWW类中或UnityWebRequest类</strong></li>
</ol>
<p>WWW类中或UnityWebRequest类中的相关方法加载本地或远端资源</p>
<ol start="4">
<li><strong>C#原生的一些文件加载相关 File FileStream</strong></li>
</ol>
<p><strong>总结：</strong></p>
<p><strong>简单说，Resources资源的加载是动态加载内部的，AssetBundle和Addressables是动态加载外部的、WWW和UnityWebReuest加载本地或远端资源、 File FileStream是加载一些文件相关</strong></p>
<h3 id="Application-streamingAssetsPath-和-Application-persistentDataPath两个路径有何区别？对于我们的意义是什么？"><a href="#Application-streamingAssetsPath-和-Application-persistentDataPath两个路径有何区别？对于我们的意义是什么？" class="headerlink" title="Application.streamingAssetsPath 和 Application.persistentDataPath两个路径有何区别？对于我们的意义是什么？"></a>Application.streamingAssetsPath 和 Application.persistentDataPath两个路径有何区别？对于我们的意义是什么？</h3><p>Application.streamingAssetsPath   只读<br>Application.persistentDataPath      可读可写</p>
<p>Application.streamingAssetsPath   适合放置一些默认2进制配置文件<br>Application.persistentDataPath      用于处理数据持久化，或作为热更新下载内容的存放目录，因为它可读可写</p>
<h3 id="Unity内存优化问题"><a href="#Unity内存优化问题" class="headerlink" title="Unity内存优化问题"></a>Unity内存优化问题</h3><blockquote>
<p>如何优化内存？</p>
</blockquote>
<ol>
<li><p>压缩自带类库；</p>
</li>
<li><p>将暂时不用的以后还需要使用的物体隐藏起来而不是直接Destroy掉；</p>
</li>
<li><p>释放AssetBundle占用的资源；</p>
</li>
<li><p>降低模型的片面数，降低模型的骨骼数量，降低贴图的大小；</p>
</li>
<li><p>使用光照贴图，使用多层次细节(LOD)，使用着色器(Shader)，使用预设(Prefab)。</p>
</li>
<li><p>代码中少产生临时变量</p>
</li>
</ol>
<blockquote>
<p>如何优化UI（基于UGUI）</p>
</blockquote>
<p><strong>性能上</strong></p>
<ol>
<li>打图集，将同一画面的图片放入一个图集中，目的是减少DrawCall</li>
<li>面板中的图片和文字尽量不要交叉，因为这样会产生多余的DrawCall</li>
<li>取消勾选在UI组件上的不必要的射线检测</li>
<li>减少透明图片的重叠使用<br>等等</li>
</ol>
<p><strong>内存上</strong></p>
<ol>
<li>大图尽量使用9宫格缩放，让美术设计UI面板底图时不要过于复杂<br>尽量是有规律的纹理和颜色变化</li>
<li>图片的RGBA通道分离<br>等等</li>
</ol>
<blockquote>
<p>UNITY3d在移动设备上的一些优化资源的方法</p>
</blockquote>
<ol>
<li><p>使用assetbundle，实现资源分离和共享，将内存控制到200m之内，同时也可以实现资源的在线更新</p>
</li>
<li><p>顶点数对渲染无论是cpu还是gpu都是压力最大的贡献者，降低顶点数到8万以下，fps稳定到了30帧左右</p>
</li>
<li><p>只使用一盏动态光，不是用阴影，不使用光照探头。粒子系统是cpu上的大头</p>
</li>
<li><p>剪裁粒子系统</p>
</li>
<li><p>合并同时出现的粒子系统</p>
</li>
<li><p>自己实现轻量级的粒子系统</p>
</li>
</ol>
<p>​	   animator也是一个效率奇差的地方</p>
<ol start="7">
<li><p>把不需要跟骨骼动画和动作过渡的地方全部使用animation，控制骨骼数量在30根以下</p>
</li>
<li><p>animator出视野不更新</p>
</li>
<li><p>删除无意义的animator</p>
</li>
<li><p>animator的初始化很耗时（粒子上能不能尽量不用animator）</p>
</li>
<li><p>除主角外都不要跟骨骼运动apply root motion</p>
</li>
<li><p>绝对禁止掉那些不带刚体带包围盒的物体（static collider ）运动</p>
</li>
<li><p>每帧递归的计算finalalpha改为只有初始化和变动时计算</p>
</li>
<li><p>去掉法线计算</p>
</li>
<li><p>不要每帧计算viewsize 和windowsize</p>
</li>
<li><p>filldrawcall时构建顶点缓存使用array.copy</p>
</li>
<li><p>代码剪裁：使用strip level ，使用.net2.0 subset</p>
</li>
<li><p>尽量减少smooth group</p>
</li>
<li><p>给美术定一个严格的经过科学验证的美术标准，并在U3D里面配以相应的检查工具</p>
</li>
</ol>
<h3 id="Unity中如何解决过多创建和删除对象带来的卡顿问题？"><a href="#Unity中如何解决过多创建和删除对象带来的卡顿问题？" class="headerlink" title="Unity中如何解决过多创建和删除对象带来的卡顿问题？"></a>Unity中如何解决过多创建和删除对象带来的卡顿问题？</h3><p>可以通过协同程序，分时分步创建或删除<br>原理是避免一帧中处理太多对象</p>
<h3 id="第一次执行GameObject-Instantiate时可能出现明显的卡顿，如何解决该问题？"><a href="#第一次执行GameObject-Instantiate时可能出现明显的卡顿，如何解决该问题？" class="headerlink" title="第一次执行GameObject.Instantiate时可能出现明显的卡顿，如何解决该问题？"></a>第一次执行GameObject.Instantiate时可能出现明显的卡顿，如何解决该问题？</h3><p>我们可以通过<strong>Unity自带的性能分析工具Profiler分析</strong>实例化时造成卡顿的原因<br><strong>程序上</strong>，一般我们可以从以下3个方面去优化它</p>
<ol>
<li><p><strong>相关资源加载：</strong>如果是由于资源加载带来的卡顿，我们可以在进入场景时进行资源预加载，总体思路就是<strong>将较大资源提前或者分帧加载</strong></p>
</li>
<li><p><strong>脚本初始化：</strong>实例化对象时，会同步执行它身上挂载所有脚本的初始化工作，我们可以策略性的<strong>改变一些初始化逻辑，尽量不要再Awake和Start中做较复杂的逻辑，或者将复杂逻辑提前或者分帧处理</strong></p>
</li>
<li><p>对于会频繁使用的对象，我们可以<strong>使用缓存池</strong></p>
</li>
</ol>
<p><strong>美术上</strong><br>不能只追求好的美术效果，而不考虑资源的消耗，要根据项目的实际情况，来设定模型的骨骼数、面数以及贴图的数量和大小上限。<br>在制作粒子特效时，粒子数、粒子面积、贴图等都要尽量少和小。<br>美术上要遵循：用最少的资源做出做好的效果，不能一味的用性能去换效果，最终会得不偿失</p>
<h3 id="Unity的IL2CPP-、Mono和跨平台等问题"><a href="#Unity的IL2CPP-、Mono和跨平台等问题" class="headerlink" title="Unity的IL2CPP 、Mono和跨平台等问题"></a>Unity的IL2CPP 、Mono和跨平台等问题</h3><blockquote>
<p>Unity底层如何处理C#代码？</p>
</blockquote>
<p>两种方案<br><font color = "red"><b>Mono和IL2CPP</b></font></p>
<blockquote>
<p>Mono</p>
</blockquote>
<p>C#代码——&gt;Mono C#编译器——&gt;IL中间代码——&gt; <font color = "red"><b>Mono VM——&gt;操作系统的原生代码</b></font></p>
<p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230201222507758.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>Net与Mono的关系</p>
</blockquote>
<p>​	Net是一个语言平台，Mono为.Net提供集成开发环境，集成并实现了.NET的编译器、CLR和基础类库，使得.Net暖既可以运行在windows也可以运行于linux，Unix，Mac OS等。</p>
<blockquote>
<p>Mono 和 Unity 的区别</p>
</blockquote>
<p>Unity 因为方便和跨平台选择了 C#作为主要的开发语言。而且 C#的跨平台是基于.Net Framework 框架下的（CIL，通用描述语言）和 CLR（通用运行环境的）。 在经过各种考量后，Unity 选择了开源，并且平台支持性很好的 Mono 这一开源 的.Net Framework 跨平台实现方案。</p>
<blockquote>
<p>IL2CPP</p>
</blockquote>
<p>C#代码——&gt;Mono C#编译器——&gt;IL中间代码——&gt;<font color = "red"><b>IL2CPP——&gt;C++——&gt;C++编译器——&gt;原生汇编代码——&gt;IL2CPP VM</b></font></p>
<p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230201222538994.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>两者区别</p>
</blockquote>
<p><font color = "red"><b>IL2CPP效率高于Mono，跨平台也更好维护</b></font></p>
<p><font color = "red"><b>Mono是JIT即时编译，IL2CPP是AOT提前编译</b></font></p>
<p>建议使用效率更高的<strong>IL2CPP</strong></p>
<blockquote>
<p>Unity使用IL2CPP打包时，我们应该注意什么？如何避免（可以举例说明）</p>
</blockquote>
<p>使用IL2CPP打包时，<b>最可能出现的问题就是<font color = "red">代码裁剪</font></b>，IL2CPP会自动将它认为不会使用的代码裁剪掉，比如我们在使用Lua开发时，其实会用到很多UnityEngine或者我们自己写的C#代码，但是这些代码并不会在引擎中直接使用，都是在Lua中使用的，此时最容易出现的问题就是代码裁剪，导致打包后出现异常和报错。</p>
<p>要<strong>避免IL2CPP的裁剪有3种方式</strong>，我们可以组合使用</p>
<ol>
<li><strong>设置打包时的裁剪等级</strong></li>
<li><strong>通过xml文件配置明确规定哪些内容不裁剪</strong></li>
<li><strong>在静态方法中显示调用不想被裁剪的内容</strong></li>
</ol>
<blockquote>
<p>Unity实现跨平台的原理？</p>
</blockquote>
<p>Unity的跨平台技术是<strong>通过一个Mono虚拟机实现</strong>的。就是<strong>通过Mono将C#脚本代码编译成CIL，然后Mono运行时利用JIT或者AOT将CLI编译成目标平台的原生代码实现的</strong>。</p>
<p><strong>还有只会推出的IL2CPP</strong>，把本来应该再mono的虚拟机上跑的中间代码转换成cpp代码，这样再把生成的cpp代码，利用c的跨平台特性，在各个平台上通过对各平台都有良好优化的native c编译器编译，以获得更高的效率和更好的兼容性。</p>
<blockquote>
<p>讲讲Jit</p>
</blockquote>
<p><strong>即时编译（Just In-Time compile）</strong>，这是.NET运行可执行程序的基本方式，编译一个.NET程序时，编译器将源代码翻译成中间语言，<strong>它是一组可以有效地转换为本机代码且独立于CPU的指令</strong>。</p>
<p>当执行这些指令时，实时（JIT）编译器将它们转化为CPU特定的代码。部分加密软件通过挂钩JIT来进行IL加密，同时又保证程序正常运行。JIT也会将编译过的代码进行缓存，而不是每一次都进行编译。所以说它是静态编译和解释器的结合体。</p>
<h3 id="Unity引擎中哪些功能使用了C-的反射功能？至少说出一点"><a href="#Unity引擎中哪些功能使用了C-的反射功能？至少说出一点" class="headerlink" title="Unity引擎中哪些功能使用了C#的反射功能？至少说出一点"></a>Unity引擎中哪些功能使用了C#的反射功能？至少说出一点</h3><ol>
<li><p>Inspector窗口中显示的内容</p>
</li>
<li><p>预设体文件</p>
</li>
<li><p>场景文件</p>
</li>
<li><p>Unity中的各种特性</p>
<p>等等</p>
</li>
</ol>
<h3 id="Unity中如何调试排查Android上运行的项目问题"><a href="#Unity中如何调试排查Android上运行的项目问题" class="headerlink" title="Unity中如何调试排查Android上运行的项目问题"></a>Unity中如何调试排查Android上运行的项目问题</h3><ol>
<li><p><strong>如果需要进行断点调试</strong><br>通过数据线链接运行项目的Android设备<br>发布时开启了<br>Development Build 开发模式构建<br>Autoconnect Profiler 自动连接分析器<br>Script Debuggins 脚本调试<br>Wait For Managed Debugger 等待托管调试器<br>等选项<br>然后只需要Build and Run既可以<br>利用Unity的Profiler 性能剖析器窗口排查性能问题<br>并且还可以进行断点调试</p>
</li>
<li><p><strong>如果只是获取一些打印调试信息</strong><br>可以利用Unity2019.4及其以上版本提供的Android Logcat工具获取信息<br>Unity2019.4以下的版本，可以使用Android的ADB（安卓调试桥）工具</p>
</li>
<li><p><strong>如果需要获取设备输入信息</strong><br>可以利用Unity Remote来测试移动设备的输入相关逻辑</p>
</li>
</ol>
<h3 id="Unity场景上有多个对象，都分别挂载了n个脚本。我们如何控制不同脚本间生命周期函数Awake的执行先后顺序？"><a href="#Unity场景上有多个对象，都分别挂载了n个脚本。我们如何控制不同脚本间生命周期函数Awake的执行先后顺序？" class="headerlink" title="Unity场景上有多个对象，都分别挂载了n个脚本。我们如何控制不同脚本间生命周期函数Awake的执行先后顺序？"></a>Unity场景上有多个对象，都分别挂载了n个脚本。我们如何控制不同脚本间生命周期函数Awake的执行先后顺序？</h3><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/AwakeOrder.png" srcset="/img/loading.gif" lazyload></p>
<ol>
<li>可以通过选中脚本文件，点击Inspector窗口右上角的Execution Order（执行顺序）按钮 </li>
<li>可以打开Project Setting窗口，选择Script Execution Order选项</li>
</ol>
<p>通过这两种方式我们可以打开脚本执行顺序窗口<br>在其中我们可以自己设置自定义脚本的执行顺序</p>
<h3 id="想要在Unity中使用指针我们需要进行哪些操作？"><a href="#想要在Unity中使用指针我们需要进行哪些操作？" class="headerlink" title="想要在Unity中使用指针我们需要进行哪些操作？"></a>想要在Unity中使用指针我们需要进行哪些操作？</h3><ol>
<li>需要在PlayerSetting中的OtherSettings中勾选  Allow ‘unsafe’ code 选项</li>
<li>使用指针时必须在unsafe修饰的代码块中</li>
</ol>
<h3 id="请简述一下对象池，在游戏开发中我们什么时候会用到它？"><a href="#请简述一下对象池，在游戏开发中我们什么时候会用到它？" class="headerlink" title="请简述一下对象池，在游戏开发中我们什么时候会用到它？"></a>请简述一下对象池，在游戏开发中我们什么时候会用到它？</h3><ol>
<li><p>对象池的主要作用是 <strong>避免大量创建对象再释放对象时造成的内存消耗，可以有效降低GC发生的频率</strong>。我们把不用的对象放入对象池中而不是让它直接变为垃圾，下次需要用到对象时再从对象池中获取，我们通过占用内存来避免更多的内存消耗和GC的发生</p>
</li>
<li><p>在游戏中频繁创建对象、实例化对象的地方，都可以用到对象池。<br>比如前端开发中，游戏中的子弹、伤害字体、特效等等<br>比如后端开发中线程池等等</p>
</li>
</ol>
<h3 id="buff-系统中，如何用一个-byte，记录多种buff状态标识"><a href="#buff-系统中，如何用一个-byte，记录多种buff状态标识" class="headerlink" title="buff 系统中，如何用一个 byte，记录多种buff状态标识"></a>buff 系统中，如何用一个 byte，记录多种buff状态标识</h3><p>答案：<br>一个byte，有8位，我们可以让每一位代表一种状态，0代表无，1代表有</p>
<p>byte buffType &#x3D; 0;</p>
<p>0000 0000<br>0000 0001  中毒 buff<br>0000 0010  灼烧 buff<br>0000 0100  回春 buff</p>
<p>当状态添加时，进行 或 ( | ) 运算<br>buffType | 灼烧 buff &#x3D; 0000 0010<br>buffType | 中毒 buff &#x3D; 0000 0011</p>
<p>当状态移除时，进行 异或 ( ^ ) 运算<br>buffType 0000 0011<br>buffType ^ 中毒 buff &#x3D; 0000 0011 ^ 0000 0001 &#x3D; 0000 0010</p>
<h3 id="Unity客户端与服务器交互方式"><a href="#Unity客户端与服务器交互方式" class="headerlink" title="Unity客户端与服务器交互方式"></a>Unity客户端与服务器交互方式</h3><p><strong>消息数据：</strong>Socket或HTTP<br><strong>文件数据：</strong>FTP或HTTP</p>
<p><strong>socket</strong>通常也称作”套接字”,实现服务器和客户端之间的物理连接，并进行数据传输，主要有UDP和TCP两个协议。<strong>Socket处于网络协议的传输层</strong>。</p>
<p>http协议传输的主要有http协议 和基于http协议的Soap协议（web service）,常见的方式是 http 的post 和get 请求，web 服务。</p>
<h3 id="Unity-ESC"><a href="#Unity-ESC" class="headerlink" title="Unity ESC"></a>Unity ESC</h3><p><strong>什么是Unity ECS</strong></p>
<p>什么是Unity ECS<br>Unity ECS是Unity引擎中的一种高性能游戏开发架构，它采用了基于数据的设计思路，与传统的面向对象编程不同。它的目标是提高游戏的性能和可伸缩性。</p>
<p>Unity ECS通过实体（Entity）、组件（Component）和系统（System）这三个概念来描述游戏对象。实体是游戏对象的标识符，组件是游戏对象的属性，系统是对实体和组件的操作。</p>
<p>Unity ECS与传统的面向对象编程不同，主要体现在以下方面：</p>
<p><strong>面向数据</strong>：ECS是一种基于数据的编程模型，它着重于描述游戏对象的属性和行为，而不是游戏对象本身。这使得ECS能够更加高效地处理大量的游戏对象。</p>
<p><strong>任务并行</strong>：ECS使用任务并行技术，使得游戏的逻辑可以在多个CPU核心上并行执行，从而提高了游戏的性能。</p>
<p><strong>内存布局</strong>：ECS使用紧凑的内存布局，使得游戏对象的数据可以更快地被访问，从而提高了游戏的性能。</p>
<h2 id="🌙C"><a href="#🌙C" class="headerlink" title="🌙C#"></a>🌙C#</h2><h3 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h3><p><em><strong>封装</strong></em> ：隐藏对象的属性，并实现细节（方法），对外提供接口，<br>public全局，protected子类，internal同集，隐藏private<br>同类，public属性器，private字段，对赋值进行限定。<br>sealed修饰符的子类是不能被继承的。</p>
<ul>
<li><p><strong>设计上：</strong>分而治之，封装变化、高内聚低耦合 	</p>
</li>
<li><p><strong>数据上</strong>：把一些基本数据复合成一个自定义类型的数据 	</p>
</li>
<li><p><strong>方法上：</strong>隐藏实现细节，向外提供接口</p>
</li>
</ul>
<p><em><strong>继承</strong></em>：重用现有代码</p>
<p><em><strong>多态</strong></em>：静态多态重载，动态多态重写。<br>父类行为由子类具体实现，包含virtual虚方法，abstract抽象方法，interface接口<br><code>可以涉及题目虚方法、抽象方法、接口的区别</code></p>
<p><em><strong>重载和重写区别</strong></em><br>静态重载：返回值无关，与参数个数，类型相关。编译阶段。便于扩展和维护<br>动态重写override（运行时，改写了方法表的新地址）。<br>抽象方法的父类必须是抽象类，子类是抽象类可以不重写，抽象类不可以被实例化。</p>
<h3 id="请简述private，public，protected，internal的区别"><a href="#请简述private，public，protected，internal的区别" class="headerlink" title="请简述private，public，protected，internal的区别"></a>请简述private，public，protected，internal的区别</h3><p><strong>public</strong>：对任何类和成员都公开，无限制访问</p>
<p><strong>private</strong>：仅对该类公开</p>
<p><strong>protected</strong>：对该类和其派生类公开</p>
<p><strong>internal</strong>：只能在包含该类的程序集中访问该类</p>
<h3 id="字符串三种为空的不同写法的区别"><a href="#字符串三种为空的不同写法的区别" class="headerlink" title="字符串三种为空的不同写法的区别"></a>字符串三种为空的不同写法的区别</h3><p><strong>请说明字符串中三者的区别</strong></p>
<ul>
<li>string str &#x3D; null</li>
<li>string str &#x3D; “”</li>
<li>string str &#x3D; string.Empty</li>
</ul>
<p><strong>str &#x3D; null</strong> 在堆中没有分配内存地址<br><strong>str &#x3D; “”</strong> 和 <strong>string.Empty</strong> 一样都是在堆内存中分配了空间，里面存储的是空字符串<br>而<strong>string.Empty</strong>是一个静态只读变量</p>
<h3 id="string和stringBuilder区别"><a href="#string和stringBuilder区别" class="headerlink" title="string和stringBuilder区别"></a>string和stringBuilder区别</h3><ul>
<li><p><strong>string</strong></p>
<p>String不变性，字符序列不可变，对原管理中实例对象赋值，会重新开一个新的实例对象赋值，新开的实例对象会等待被GC。<br>string拼接要重新开辟空间，因为string原值不会改变，导致GC频繁，性能消耗大</p>
</li>
<li><p><strong>StringBuilder</strong></p>
<p>StringBuilder是字符串可变对象，基本和StringBuilder相同。唯一的区别是StringBuffer是线程安全，相关方法前带synchronized关键字，一般用于多线程。StringBuilder是非线程安全，所以性能略好，一般用于单线程</p>
</li>
</ul>
<p><strong>三者性能比较</strong> StringBuilder&gt;String</p>
<blockquote>
<p>在开发时，对string和StringBuilder我们应该如何选择</p>
</blockquote>
<p><strong>string</strong>在每次拼接时都会产生垃圾<br><strong>StringBuilder</strong>在拼接时，是在原空间中进行修改，不会产生垃圾，会自动帮助我们扩容<br>所以<strong>当字符串需要频繁修改拼接时，我们使用StringBuilder</strong></p>
<h3 id="请说说你认为C-中-x3D-x3D-和-Equals-的区别是什么？"><a href="#请说说你认为C-中-x3D-x3D-和-Equals-的区别是什么？" class="headerlink" title="请说说你认为C#中 &#x3D;&#x3D; 和 Equals 的区别是什么？"></a>请说说你认为C#中 &#x3D;&#x3D; 和 Equals 的区别是什么？</h3><ol>
<li>&#x3D;&#x3D; 是运算符，Equals是万物之父Object中的虚方法，子类可重写</li>
<li>Equals 一般在子类中重写后用于比较两个对象中内容是否相同<br> &#x3D;&#x3D;在没有运算符重载的前提下时<br> 引用类型用于比较地址；值类型用于比较值是否相同</li>
<li>运算效率不同，一般Equals没有&#x3D;&#x3D;效率高，因为一般Equals比较的内容比&#x3D;&#x3D;多</li>
</ol>
<h3 id="C-重载运算符，重载-x3D-x3D-和-x3D-以及Object基类中的虚方法-virtual-bool-Equals-Object-obj-对于我们的意义是什么？"><a href="#C-重载运算符，重载-x3D-x3D-和-x3D-以及Object基类中的虚方法-virtual-bool-Equals-Object-obj-对于我们的意义是什么？" class="headerlink" title="C#重载运算符，重载 &#x3D;&#x3D; 和 !&#x3D; 以及Object基类中的虚方法 virtual bool Equals(Object obj)对于我们的意义是什么？"></a>C#重载运算符，重载 &#x3D;&#x3D; 和 !&#x3D; 以及Object基类中的虚方法 virtual bool Equals(Object obj)对于我们的意义是什么？</h3><p>为了判断两个对象的非引用地址相等<br>我们可以选择 使用 重载运算符 &#x3D;&#x3D; 和 !&#x3D; 或者<br>重写Equals方法，来自定义判断两个对象是否相等<br>如果想保留原有的引用地址相等判断，那么一般我们选择重写Equals方法</p>
<h3 id="浅拷贝和深拷贝的区别？可以举例说明"><a href="#浅拷贝和深拷贝的区别？可以举例说明" class="headerlink" title="浅拷贝和深拷贝的区别？可以举例说明"></a>浅拷贝和深拷贝的区别？可以举例说明</h3><p><strong>浅拷贝：</strong><br>只复制对象的引用地址<br>两个对象指向同一内存地址，修改其中一个另一个也会随之变化</p>
<p><strong>深拷贝：</strong><br>将对象和值赋值过来，两个对象修改其中任意值都不会影响对方</p>
<p>举例：<br>比如引用对象A和引用对象B<br>让A &#x3D; B，就是浅拷贝，此时A、B的引用地址相同，改A中内容，B也变</p>
<p>如果想要深拷贝，简单处理就是new（包括对象中的成员）</p>
<h3 id="装箱和拆箱是指什么？"><a href="#装箱和拆箱是指什么？" class="headerlink" title="装箱和拆箱是指什么？"></a>装箱和拆箱是指什么？</h3><p>装箱——把栈中内容迁移到堆中去（值转引用）<br>拆箱——把堆中内容迁移到栈中去（引用转值）</p>
<p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230201221201268.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="值和引用类型在变量赋值时的区别是什么？"><a href="#值和引用类型在变量赋值时的区别是什么？" class="headerlink" title="值和引用类型在变量赋值时的区别是什么？"></a>值和引用类型在变量赋值时的区别是什么？</h3><p>在C#中<strong>值类型的变量直接存储数据</strong>，而<strong>引用类型的变量持有的是数据的引用，数据存储在数据堆中</strong>。</p>
<p><strong>值类型</strong>（value type）：<strong>byte，short，int，long，float，double，decimal，char，bool，enum 和 struct</strong> 统称为值类型。值类型变量声明后，不管是否已经赋值，编译器为其分配内存。<br><img src="https://img-blog.csdnimg.cn/b99d714ae81d4ed08afb9a933e5df2ea.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br><strong>引用类型</strong>（reference type）：<strong>string ，class，interface，delegate</strong>统称为引用类型。当声明一个类时，只在栈中分配一小片内存用于容纳一个地址，而此时并没有为其分配堆上的内存空间。当使用 new 创建一个类的实例时，分配堆上的空间，并把堆上空间的地址保存到栈上分配的小片空间中。<br><img src="https://img-blog.csdnimg.cn/cdda4b5f61374524bf3082080d30c4fb.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>值类型的实例通常是在线程栈上分配的（静态分配），但是在某些情形下可以存储在堆中。引用类型的对象总是在进程堆中分配（动态分配)。</p>
<p><strong>内存区域上的区别</strong><br><strong>值类型</strong>：数据存储在<strong>栈</strong>上，超出作用域就自动清理<br><strong>引用类型：</strong>数据存储在托管<strong>堆</strong>上，<strong>引用地址在线程栈上，地址指向数据存放的堆上</strong><br>托管堆会由GC来自动释放 ，线程栈数据在作用域结束后会被清理。</p>
<p><strong>拷贝策略：值类型是拷贝数据，引用类型是拷贝引用地址</strong><br>如果值类型为传值参数，传值参数会在栈上新开辟一个副本，原先的值类型数据不会改变<br>如果引用类型是传值参数，传值参数会创建一个新的引用地址，两个引用地址会指向同一个对象实例的数据，实例数据会随着改变进行改变。（这种行为被称为副作用，一般实际项目不会这么操作，要么return返回参数，要么使用ref或者out修饰符）</p>
<blockquote>
<p>数据结构的栈和堆</p>
</blockquote>
<p>堆和栈都是一种数据项按序排列的数据结构。</p>
<ul>
<li><p><strong>栈</strong></p>
<p>栈就像装数据的桶，具有后进先出性质；</p>
</li>
<li><p><strong>堆</strong></p>
<p>堆像一棵倒过来的树，<strong>堆是一种经过排序的树形数据结构，每个结点都有一个值。</strong>堆的存取是随意，这就如同我们在图书馆的书架上取书，虽然书的摆放是有顺序的</p>
</li>
</ul>
<h3 id="C-结构体和类的区别"><a href="#C-结构体和类的区别" class="headerlink" title="C# 结构体和类的区别"></a>C# 结构体和类的区别</h3><p><strong>结构体：</strong></p>
<ul>
<li>值类型</li>
<li>存储在栈</li>
<li>不能够使用protected保护修饰符</li>
<li>成员变量申明不能指定初始值</li>
<li>不能申明无参构造函数</li>
<li>申明有参构造函数之后，无参会被顶掉</li>
<li>不能申明析构函数</li>
<li>不能被继承</li>
<li>结构体需要在构造函数中初始化所有成员变量</li>
<li>不能被静态static修饰</li>
<li>不能再自己内部申明和自己一样的结构体变量</li>
</ul>
<p><strong>类：</strong></p>
<ul>
<li>引用类型</li>
<li>存储在堆</li>
</ul>
<h3 id="C-foreach-和-for-问题"><a href="#C-foreach-和-for-问题" class="headerlink" title="C# foreach 和 for 问题"></a>C# foreach 和 for 问题</h3><blockquote>
<p>C#中如何让自定义容器类能够使用for循环遍历？（通过 类对象[索引] 的形式遍历）</p>
</blockquote>
<p>通过在类中实现索引器实现</p>
<blockquote>
<p>C#中如何让自定义容器类能够使用foreach循环遍历？</p>
</blockquote>
<p>通过为该类实现迭代器可以让其使用foreach遍历<br>传统方式：<br>继承IEnumerator、IEnumerable两个接口<br>实现其中的<br>1.GetEnumerator方法<br>2.Current属性<br>3.MoveNext方法<br>语法糖方式：<br>利用yield return语法糖，实现GetEnumerator方法即可完成迭代器的实现&#x3D;</p>
<blockquote>
<p>foreach迭代器遍历和for循环遍历的区别</p>
</blockquote>
<ul>
<li><p><strong>foreach</strong></p>
<p>如果集合需要foreach遍历，是否可行，存在一定问题<br>foreach中的迭代变量item是的只读，不能对其进行修改，比如	list.Remove（item）操作<br>foreach只读的时候记录下来，在对记录做操作，或者直接用for循环遍历<br>foreach对int[]数组循环已经不产生GC，避免对ArrayList进行遍历</p>
</li>
<li><p><strong>for</strong></p>
<p>for语句中初始化变量i的作用域，循环体内部可见。<br>通过索引进行遍历，可以根据索引对所遍历集合进行修改<br>unity中for循环使用lambda表达式注意闭包问题</p>
</li>
</ul>
<p><strong>Foreach遍历原理</strong><br>任何集合类（Array）对象都有一个GetEnumerator()方法，该方法可以返回一个实现了 IEnumerator接口的对象。<br>这个返回的IEnumerator对象既不是集合类对象，也不是集合的元素类对象，它是一个独立的类对象。<br>通过这个实现了 IEnumerator接口对象A，可以遍历访问集合类对象中的每一个元素对象<br>对象A访问MoveNext方法，方法为真，就可以访问Current方法，读取到集合的元素。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C#">  List&lt;<span class="hljs-built_in">string</span>&gt; list = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">string</span>&gt;() &#123; <span class="hljs-string">&quot;25&quot;</span>, <span class="hljs-string">&quot;哈3&quot;</span>, <span class="hljs-string">&quot;26&quot;</span>, <span class="hljs-string">&quot;花朵&quot;</span> &#125;;<br>IEnumerator listEnumerator = list.GetEnumerator();<br>     <span class="hljs-keyword">while</span> (listEnumerator.MoveNext())<br>     &#123;<br>         Console.WriteLine(listEnumerator.Current);<br>     &#125;<br><br></code></pre></td></tr></table></figure>



<h3 id="内存中，堆和栈的区别是什么？"><a href="#内存中，堆和栈的区别是什么？" class="headerlink" title="内存中，堆和栈的区别是什么？"></a>内存中，堆和栈的区别是什么？</h3><p>堆和栈是操作系统堆进程占用的内存空间的两种管理方式</p>
<ul>
<li><p><strong>栈：</strong>由操作系统自动分配释放，存放函数的参数值，局部变量值，栈中数据的生命周期随着函数的执行完成而结束</p>
</li>
<li><p><strong>堆：</strong>一般由程序员分配释放，如果开发人员不释放，程序结束时由操作系统回收<br>（在C#中 托管堆内存 会由 C#帮助我们管理，存在GC垃圾回收机制）</p>
</li>
</ul>
<h3 id="C-容器类、各自特点、性能区别"><a href="#C-容器类、各自特点、性能区别" class="headerlink" title="C#容器类、各自特点、性能区别"></a>C#容器类、各自特点、性能区别</h3><h4 id="Stack栈"><a href="#Stack栈" class="headerlink" title="Stack栈"></a><strong>Stack栈</strong></h4><p><strong>先进后出</strong>，入栈和出栈，底层泛型数组实现，入栈动态扩容2倍</p>
<hr>
<h4 id="Queue队列"><a href="#Queue队列" class="headerlink" title="Queue队列"></a><strong>Queue队列</strong></h4><p><strong>先进先出</strong>，入队和出队，底层泛型数组实现，表头表尾指针，判空还是满通过size比较</p>
<p><strong>Queue和Stack主要是用来存储临时信息的</strong></p>
<hr>
<h4 id="Array数组"><a href="#Array数组" class="headerlink" title="Array数组"></a><strong>Array数组</strong></h4><p><strong>Array</strong> 类是 C# 中所有数组的基类，它是在 System 命名空间中定义。Array 类提供了各种⽤于数组的属性和⽅法。且需要声明长度，不安全</p>
<p>使⽤⽅法如下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">int</span>[] nums = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span> &#125;;<br>Array.Sort(nums);<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="ArrayList数组列表"><a href="#ArrayList数组列表" class="headerlink" title="ArrayList数组列表"></a><strong>ArrayList数组列表</strong></h4><p><strong>ArrayList</strong>动态数组，是.Net Framework提供的⽤于数据存储和检索的专⽤类，它是命名空间System.Collections下的⼀部分。它的大小是按照其中存储的数据来动态扩充与收缩的。所以，我们在声明ArrayList对象时并不需要指定它的长度。ArrayList继承了IList接⼝，所以它可以很⽅便的进行数据的添加，插⼊和移除.</p>
<p>比如：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C#">ArrayList al = <span class="hljs-keyword">new</span> ArrayList();<br><span class="hljs-comment">//新增数据</span><br>al.Add(<span class="hljs-string">&quot;abc&quot;</span>); al.Add(<span class="hljs-number">123</span>);<br><span class="hljs-comment">//修改数据</span><br>al[<span class="hljs-number">2</span>] = <span class="hljs-number">345</span>;<br><span class="hljs-comment">//移除数据</span><br>al.RemoveAt(<span class="hljs-number">0</span>);<br><span class="hljs-comment">//插⼊数据</span><br>al.Insert(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;hello world&quot;</span>);<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="List列表"><a href="#List列表" class="headerlink" title="List列表"></a><strong>List列表</strong></h4><p><strong>List</strong>类是ArrayList类的泛型等效类。它的⼤部分⽤法都与ArrayList相似，因为List类也继承了IList接⼝。最关键的区别在于，在声明List集合时，我们同时需要为其声明List集合内数据的对象类型。</p>
<h5 id="List底层原理"><a href="#List底层原理" class="headerlink" title="List底层原理"></a>List底层原理</h5><p>底层实现是泛型数组，特性，动态扩容，泛型安全</p>
<p>List是一种动态数组，其<strong>底层是一个数组</strong>，当元素个数超出数组的长度时，系统会自动为数组扩容，<strong>新的长度通常是原长度的2倍</strong>。List提供了一系列的方法，可以方便地添加、删除、查找、排序等操作。</p>
<p>为了支持动态扩容，<strong>List在内部维护了</strong><font color = "red"><b>一个数组和一个元素个数</b></font>。当<strong><em>元素个数</em>超出数组长度</strong>时，List会<strong>创建一个新数组</strong>，并<strong>将原来的元素拷贝到新的数组</strong>中，然后使用新数组替换旧数组，从而实现动态扩容。为了避免频繁的扩容，<strong>List采用了一种预分配策略，即当扩容时，会一次性预分配一定的容量，以减少扩容次数。</strong></p>
<p>比如：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C#">List&lt;<span class="hljs-built_in">int</span>&gt; list = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;();<br><span class="hljs-comment">//新增数据</span><br> list.Add(<span class="hljs-number">123</span>);<br><span class="hljs-comment">//修改数据</span><br>list[<span class="hljs-number">0</span>] = <span class="hljs-number">345</span>;<br><span class="hljs-comment">//移除数据</span><br>list.RemoveAt(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure>

<p> 上例中，如果我们往List泛型集合中插⼊string字符”hello world”，IDE就会报错，且不能通过编译。这样就避免了前⾯讲的类型安全问题与装箱拆箱的性能问题了。</p>
<p><strong>List泛型的好处：</strong><br>　　通过允许指定泛型类或⽅法操作的特定类型，泛型功能将类型安全的任务从您转移给了编译器。不需要编写代码来检测数据类型是否正确，因为会在编译时强制使⽤正确的数据类型。减少了类型强制转换的需要和运⾏时错误的可能性。泛型提供了类型安全但没有增加多个实现的开销。</p>
<blockquote>
<p>请说明C#中的List是如何扩容的</p>
</blockquote>
<p>List的本质是数组</p>
<blockquote>
<p>List初始化效率问题</p>
</blockquote>
<p><strong>以下代码，谁的效率更高？为什么？</strong></p>
<p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ListProblem.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>代码2的效率更高</strong></p>
<p>因为List的本质是数组，在初始化时，如果不默认为其指明分配多少容量，它会不断扩容<br><strong>扩容会带来效率的降低和垃圾的产生</strong></p>
<ul>
<li><strong>效率的降低：</strong>从旧数组到新数组的搬家</li>
<li><strong>垃圾的产生：</strong>每次扩容时，就数组就变成了垃圾</li>
</ul>
<blockquote>
<p>C#Array、ArrayList和List的区别</p>
</blockquote>
<ol>
<li>三者都⽤来处理⼀组数据，继承了IEnumerable接⼝，可⽤于for循环处理。<strong>都可以通过索引下标进⾏获取和设置元素</strong>。</li>
<li>Array在内存中是连续的，长度固定，⽆法删除和增加新的元素。⽽ArrayList或List的容量可根据需要⾃动插⼊和删除元素。</li>
<li>Array可以具有多个维度，⽽ ArrayList或 List&lt; T&gt; 始终只具有⼀个维度。但是，您可以轻松创建数组列表或列表的列表。</li>
<li>特定类型（Object 除外）的数组 的性能优于 ArrayList的性能。 这是因为 ArrayList的元素属于 Object 类型；所以在存储或检索值类型时通常发⽣装箱和拆箱操作。不过，在不需要重新分配时（即最初的容量⼗分接近列表的最⼤容量），List&lt; T&gt; 的性能与同类型的数组⼗分相近。</li>
<li>在决定使⽤ List 还是使⽤ArrayList 类（两者具有类似的功能）时，记住List 类在⼤多数情况下执⾏得更好并且是类型安全的。如果对<br>List&lt; T&gt; 类的类型T 使⽤引⽤类型，则两个类的⾏为是完全相同的。但是，如果对类型T使⽤值类型，则需要考虑实现和装箱问题。</li>
</ol>
<hr>
<h4 id="LinkList链表"><a href="#LinkList链表" class="headerlink" title="LinkList链表"></a><strong>LinkList链表</strong></h4><ol>
<li><p>数组和List、ArrayList集合都有一个重大的缺陷，就是从数组的中间位置删除或插入一个元素需要付出很大的代价，其原因是数组中处于被删除元素之后的所有元素都要向数组的前端移动。</p>
</li>
<li><p>LinkedList（底层是由链表实现的）<strong>基于链表的数据结构</strong>，很好的解决了数组删除插入效率低的问题，且不用动态的扩充数组的长度。</p>
<p><strong>优点</strong>：插入、删除元素效率比较高；</p>
<p><strong>缺点</strong>：访问效率比较低。</p>
</li>
</ol>
<hr>
<blockquote>
<p>C#则List和LinkedList的区别</p>
</blockquote>
<ul>
<li><p>List是数组列表</p>
<p>List读取速度快，时间复杂度是O（1），增删比较麻烦，时间复杂度是O(n).</p>
</li>
<li><p>LinkedList是双向链表</p>
<p>LinkedList读取时间复杂度是O(n),增删时间复杂度是O（1）</p>
</li>
</ul>
<blockquote>
<p>数组和链表的区别是什么？</p>
</blockquote>
<ol>
<li><strong>存储结构不同</strong></li>
</ol>
<ul>
<li>数组是顺序存储结构，在内存中是连续存储的</li>
<li>链表是链式存储结构，在内存中是非连续存储的</li>
</ul>
<ol start="2">
<li><strong>访问效率不同</strong></li>
</ol>
<ul>
<li>数组由于是顺序存储，通过下标访问，访问效率高</li>
<li>链表由于是非连续存储，我们想要获取其中某一元素，需要从头或尾遍历，效率低</li>
</ul>
<ol start="3">
<li><strong>插入、删除效率不同</strong></li>
</ol>
<ul>
<li>数组由于是顺序存储，在插入和删除时，需要整体移动数组中的大部分元 素，效率低</li>
<li>链表由于是链式存储，在插入和删除时，效率高</li>
</ul>
<ol start="4">
<li><strong>越界问题</strong></li>
</ol>
<ul>
<li>数组由于是顺序存储，声明时容量是固定的，如果不处理扩容逻辑，存在越界风险</li>
<li>链表由于是链式存储，无越界风险</li>
</ul>
<hr>
<h4 id="HashTable哈希表（散列表）"><a href="#HashTable哈希表（散列表）" class="headerlink" title="HashTable哈希表（散列表）"></a><strong>HashTable哈希表（散列表）</strong></h4><p><strong>概念：</strong>不定长的二进制数据通过哈希函数映射到一个较短的二进制数据集，即Key通过HashFunction函数获得HashCode<br>装填因子：α&#x3D;n&#x2F;m&#x3D;0.72 ,存储的数据N和空间大小M<br>然后通过哈希桶算法，HashCode分段，每一段都是一个桶结构，一般是HashCode直接取余。<br>桶结构会加剧冲突，解决冲突使用拉链法，将产生冲突的元素建立一个单链表，并将头指针地址存储至Hash表对应桶的位置。这样定位到Hash表桶的位置后可通过遍历单链表的形式来查找元素。</p>
<ol>
<li>Key—Value形式存取，无序，类型Object，需要类型转换。</li>
<li>Hashtable查询速度快，而添加速度相对慢</li>
<li><ul>
<li><strong>Hashtable</strong>中的数据实际存储在内部的一个数据桶里（bucket结构体数组），容量固定，根据数组索引获取值。</li>
<li><strong>Directionary&lt;TKey,TVaule&gt;字典</strong>，有序，泛型存储不需要进行类型装换（不需要装箱拆箱），碰撞阈值扩容</li>
<li><strong>HashSet</strong>：一组不包含重复的元素集合</li>
</ul>
</li>
</ol>
<hr>
<h4 id="字典Dictionary"><a href="#字典Dictionary" class="headerlink" title="字典Dictionary"></a><strong>字典Dictionary</strong></h4><p>泛型集合命名空间using System.Collections.Generic;<br><strong>任何键都必须是唯一</strong></p>
<p>是一种键值对的形式存放数据，即 key值 、value 值 一 一映射的。key的类型没有限制，可以是整数、字符串甚至是实例对象。</p>
<p>该类最大的<strong>优点</strong>就是它**查找元素的时间复杂度接近O(1)**，实际项目中常被用来做一些数据的本地缓存，提升整体效率。</p>
<p><font color = "red" > <b>重点！！！！👇👇👇👇👇</b></font></p>
<h5 id="Dictionary底层原理"><a href="#Dictionary底层原理" class="headerlink" title="Dictionary底层原理"></a><strong>Dictionary底层原理</strong></h5><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/96633352">【C#】浅析C# Dictionary实现原理 - 知乎 (zhihu.com)</a></p>
<p>有两个关键的算法，<strong>Hash算法 和 解决Hash 碰撞冲突 的算法</strong>。key value的映射关系用的就是Hash函数来建立的。</p>
<ol>
<li><p>哈希算法：<strong>将不定长度的二进制数据集给映射到一个较短的二进制长度数据集</strong>一个Key通过HashFunc（哈希函数）得到HashCode</p>
</li>
<li><p>Hash桶算法：是解决哈希表而引入的一个概念 ，为每一个hashCode 建立一个桶，桶里面放着一个数组。</p>
<p>对HashCode进行分段显示，常用方法是对HashCode直接取余</p>
</li>
<li><p>解决碰撞冲突算法（拉链法）：分段会导致key对应的桶会相同，<strong>拉链法的思想就像对冲突的元素，建立一个单链表，头指针存储到对应的哈希桶位置</strong>。反之就是通过确定hash桶位置后，遍历单链表，获取对应的value</p>
</li>
</ol>
<p><strong>变量定义</strong></p>
<p><img src="https://img2022.cnblogs.com/blog/708460/202205/708460-20220514185149561-1170153985.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p> 从定义可知，<strong>字典的实现底层数据结构</strong>依靠的是<strong>数组</strong>。</p>
<p>Key值 HashFunc Buckets桶 Entries入口（最小数据结构）</p>
<p><img src="https://img-blog.csdnimg.cn/20210117205128952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNDA3NTIz,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p>Dictionary字典中最小的数据结构体Entry，调用Add(Key,Value)方法添加的元素都会被封装在这样的一个结构体中。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">private</span> <span class="hljs-keyword">struct</span> Entry &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> hashCode;    <span class="hljs-comment">// 除符号位以外的31位hashCode值, 如果该Entry没有被使用，那么为-1</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> next;        <span class="hljs-comment">// 下一个元素的下标索引，如果没有下一个就为-1</span><br>    <span class="hljs-keyword">public</span> TKey key;        <span class="hljs-comment">// 存放元素的键</span><br>    <span class="hljs-keyword">public</span> TValue <span class="hljs-keyword">value</span>;    <span class="hljs-comment">// 存放元素的值</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>Collection版本控制，字典重要变量version，这个变量，在每一次新增、修改和删除操作时，都会使version++<br>之后每一次迭代过程都会检查版本号是否一致，如果不一致将抛出异常。<br>这样就避免了在迭代过程中修改了集合，造成很多诡异的问题。</p>
<p><font color = "red"><b>总结：</b></font></p>
<p>Dictionary由数组构成，Hash函数作为地址构建，拉链法解决Hash冲突。Dictionary也是线程不安全的，因此在多线程访问的时候，需要自行加lock处理。</p>
<ul>
<li>C# Dictionary使用一个<strong>Entry结构体</strong>来存储键值对，每个Entry包含一个哈希码、一个下一个元素的索引、一个键和一个值。</li>
<li>C# Dictionary使用一个<strong>int数组</strong>来表示哈希桶，每个桶存储了对应的Entry在Entry数组中的索引，如果桶为空，则为-1。</li>
<li>C# Dictionary使用一个<strong>Entry数组</strong>来存放所有的元素，每个元素通过next字段指向同一桶中的下一个元素，形成链表结构。</li>
<li>C# Dictionary使用<strong>除留余数法</strong>来计算哈希码和桶索引，即<code>bucketIndex = hashCode % buckets.Length</code>。</li>
<li>C# Dictionary使用<strong>拉链法</strong>来解决哈希冲突，即将冲突的元素放在同一桶中的链表上。</li>
<li>C# Dictionary在添加、删除或查找元素时，都需要先计算哈希码和桶索引，然后遍历对应桶中的链表。</li>
<li>C# Dictionary在添加元素时，如果发现空闲位置（被删除的Entry），则优先复用该位置；如果发现数组已满或者碰撞次数过多，则进行扩容操作。</li>
<li>C# Dictionary在扩容操作时，会重新分配哈希桶和Entry数组，并重新计算所有元素的哈希码和桶索引。</li>
</ul>
<p>大概：</p>
<p>Dictionary 是一种通过 key value 存储数据的结构，它通过哈希算法，将不定长的二进制数据集映射到一个较短的二进制长度数据集，其中的key通过哈希函数得到hashcode。再通过哈希桶算法，为每一个hashcode建立一个桶，桶里面放着数组。还对每一个hashcode进行分段显示，常用的是对hashcode取余。如果产生碰撞冲突，使用拉链法解决冲突，即对产生冲突的元素建立一个单链表，头指针存储到对应的哈希桶位置。Dictionary下还有一个结构体Entry，调用添加（ADD）方法都会封装在这一个结构体中。</p>
<blockquote>
<p>C#中Dictionary不支持相同键存储，如果想要一个键对多个值该如何处理</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//按需求选择值的存储类型，可以用List，数组等来存储值</span><br>Dictionary&lt;<span class="hljs-built_in">string</span> , List&lt;player&gt;&gt; dic;<br> Dictionary&lt;<span class="hljs-built_in">string</span> , player[]&gt; dic;   <br></code></pre></td></tr></table></figure>



<hr>
<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p><strong>性能排序：</strong><br>插入性能： LinkedList &gt; Dictionary &gt; HashTable &gt; List<br>遍历性能：List &gt; LinkedList &gt; Dictionary &gt; HashTable<br>删除性能： Dictionary &gt; LinkedList &gt; HashTable &gt; List</p>
<p><font color = "red"><b>小结：</b></font></p>
<p><font color = "red"><b>在修改较频繁，且查找和删除也较多时，首选LinkedList,<br>在主要以删除为主，插入为辅，且查找较少时，首选Dictionary，<br>在查找频繁，而又无需修改的情况下，则首选List。</b></font></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//哈希表结构体</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">struct</span> bucket &#123;<br>   <span class="hljs-keyword">public</span> Object key;<span class="hljs-comment">//键</span><br>    <span class="hljs-keyword">public</span> Object val;<span class="hljs-comment">//值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> hash_col;<span class="hljs-comment">//哈希码</span><br>&#125;<br><span class="hljs-comment">//字典结构体</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">struct</span> Entry &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> hashCode;    <span class="hljs-comment">// 除符号位以外的31位hashCode值, 如果该Entry没有被使用，那么为-1</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> next;        <span class="hljs-comment">// 下一个元素的下标索引，如果没有下一个就为-1</span><br>    <span class="hljs-keyword">public</span> TKey key;        <span class="hljs-comment">// 存放元素的键</span><br>    <span class="hljs-keyword">public</span> TValue <span class="hljs-keyword">value</span>;    <span class="hljs-comment">// 存放元素的值</span><br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span>[] buckets;      <span class="hljs-comment">// Hash桶</span><br><span class="hljs-keyword">private</span> Entry[] entries;    <span class="hljs-comment">// Entry数组，存放元素</span><br><span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> count;          <span class="hljs-comment">// 当前entries的index位置</span><br><span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> version;        <span class="hljs-comment">// 当前版本，防止迭代过程中集合被更改</span><br><span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> freeList;       <span class="hljs-comment">// 被删除Entry在entries中的下标index，这个位置是空闲的</span><br><span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> freeCount;      <span class="hljs-comment">// 有多少个被删除的Entry，有多少个空闲的位置</span><br><span class="hljs-keyword">private</span> IEqualityComparer&lt;TKey&gt; comparer;   <span class="hljs-comment">// 比较器</span><br><span class="hljs-keyword">private</span> KeyCollection keys;     <span class="hljs-comment">// 存放Key的集合</span><br><span class="hljs-keyword">private</span> ValueCollection values;     <span class="hljs-comment">// 存放Value的集合</span><br><br><br></code></pre></td></tr></table></figure>

<hr>
<h3 id="C-泛型问题"><a href="#C-泛型问题" class="headerlink" title="C# 泛型问题"></a>C# 泛型问题</h3><h4 id="泛型是什么-好处是什么"><a href="#泛型是什么-好处是什么" class="headerlink" title="泛型是什么,好处是什么"></a>泛型是什么,好处是什么</h4><p>多个代码对 【不同数据类型】 执行 【相同指令】的情况<br><strong>泛型：</strong>多个类型共享一组代码<br>泛型允许类型参数化，泛型类型是类型的模板<br><strong>5种泛型：</strong>&lt; **类、结构、接口、委托、方法** &gt;<br>类型占位符 <strong>T</strong> 来表示泛型</p>
<p>泛型类不是实际的类，而是类的模板<br>从泛型类型创建实例<br>声明泛型类型 &gt;&gt; 通过提供【真实类型】创建构造函数类型 &gt;&gt; 从构造类型创建实例<br>类&lt;T1,T2&gt; 泛型类型参数</p>
<p><strong>性能</strong>：泛型不会强行对值类型进行装箱和拆箱，或对引用类型进行向下强制类型转换，所以性能得到提高<br><strong>安全</strong>：通过知道使用泛型定义的变量的类型限制，编译器可以在一定程度上验证类型假设，所以泛型提高了程序的类型安全。</p>
<blockquote>
<p>泛型的好处是什么</p>
</blockquote>
<ol>
<li>可以为不同类型对象的相同行为进行通用处理，提升代码复用率</li>
<li>避免装箱拆箱，提升性能</li>
</ol>
<h4 id="泛型约束有几种"><a href="#泛型约束有几种" class="headerlink" title="泛型约束有几种"></a>泛型约束有几种</h4><ol>
<li>值类型约束 T:struct</li>
<li>引用类型约束 T:class</li>
<li>公共无参构造约束 T:new()</li>
<li>类约束 T:类名</li>
<li>接口约束 T:接口名</li>
<li>另一个泛型约束 T:U</li>
</ol>
<h3 id="C-中如何让一个类不能再被其他类所继承？"><a href="#C-中如何让一个类不能再被其他类所继承？" class="headerlink" title="C#中如何让一个类不能再被其他类所继承？"></a>C#中如何让一个类不能再被其他类所继承？</h3><p>使用密封关键字sealed修饰该类</p>
<h3 id="C-接口和抽象类问题"><a href="#C-接口和抽象类问题" class="headerlink" title="C#接口和抽象类问题"></a>C#接口和抽象类问题</h3><blockquote>
<p>什么是接口，描述一下接口的成员具体实现</p>
</blockquote>
<ol>
<li>接口interface，不能定义字段，可以定义【非静态的】属性、索引器、事件、方法</li>
<li>默认public，但不能写任何访问修饰符</li>
<li>接口是引用类型，可以通过as运算符强转，获取某对象的接口的引用</li>
<li>接口可以继承N个接口，继承类要实现所有接口的方法</li>
</ol>
<p>声明接口IA &gt; 继承接口的类B &gt; 类B实现接口所有方法<br>接口要小而精，定义一组方法，继承接口的派生类要实现接口的所有方法。<br>接口和抽象类是不能被实例化的对象（引用类型）。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DelegateTest</span>()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">ITest</span> <span class="hljs-comment">//只能包含非静态成员函数，隐式public，但不允许访问修饰符</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Method</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> a</span>)</span>; <span class="hljs-comment">//方法</span><br>        <span class="hljs-built_in">string</span> Property <span class="hljs-comment">//属性</span><br>        &#123;<br>            <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>;<br>        &#125;<br>        <span class="hljs-keyword">event</span> DelegateTest EventTest; <span class="hljs-comment">//事件，需要先定义一个委托</span><br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">this</span>[<span class="hljs-built_in">int</span> index] <span class="hljs-comment">//索引器</span><br>        &#123;<br>            <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>;<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure>

<p><strong>例子</strong>：</p>
<p>游戏门：抽象类，不能实例，很多行为，定义接口，破坏可以击碎<br>系统接口鼠标行为，停留进入离开<br>很多设计模式，是对接口的应用，面向接口编程，实现层面更加有层次。</p>
<blockquote>
<p>C#中接口的作用是什么？说说你的理解</p>
</blockquote>
<p>用于建立行为的继承关系，而不是对象<br>不同对象，有相同行为时，我们可以利用接口对不同对象的行为进行整合</p>
<blockquote>
<p>请描述interface和抽象类之间的不同</p>
</blockquote>
<table>
<thead>
<tr>
<th>接口</th>
<th>抽象类</th>
</tr>
</thead>
<tbody><tr>
<td>是一种行为，不能直接实例化</td>
<td>是一种不能实例化的对象</td>
</tr>
<tr>
<td>可以定义方法、属性、索引器、事件</td>
<td>可以定义字段、静态字段和方法、抽象方法、属性、构造函数</td>
</tr>
<tr>
<td>可以继承，继承多个接口</td>
<td>可以继承，只能继承一个类</td>
</tr>
<tr>
<td>直接实现所有成员</td>
<td>重写override抽象方法</td>
</tr>
<tr>
<td>接口和抽象都不能被实例化，派生类必须实现基类或接口的方法</td>
<td>接口和抽象都不能被实例化，派生类必须实现基类或接口的方法</td>
</tr>
<tr>
<td>可以多重实现，抽象类只能单一继承</td>
<td>可以派生自另一个抽象类</td>
</tr>
</tbody></table>
<blockquote>
<p>如何选择抽象类和接口</p>
</blockquote>
<ul>
<li><strong>表示对象的用抽象类</strong>，<strong>表示行为拓展的用接口</strong></li>
<li><strong>不同对象用有共同行为，我们往往可以使用接口来实现</strong></li>
</ul>
<h3 id="C-委托和事件问题"><a href="#C-委托和事件问题" class="headerlink" title="C#委托和事件问题"></a>C#委托和事件问题</h3><blockquote>
<p>委托和事件在使用上的区别是什么？</p>
</blockquote>
<ol>
<li>事件和委托的使用是一模一样的，事件就是特殊的委托</li>
<li>事件相对委托来说，事件在外部使用时只能 +&#x3D;、-&#x3D;，委托哪都能用</li>
<li>事件 不能再外部执行 委托哪都能执行</li>
<li>事件 不能作为函数的临时变量 委托可以</li>
</ol>
<table>
<thead>
<tr>
<th>序号</th>
<th>区别</th>
<th>委托</th>
<th>事件</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>是否可以使用&#x3D;来赋值</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>2</td>
<td>是否可以在类外部进行调用</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>3</td>
<td>是否是一个类型</td>
<td>是</td>
<td>否，事件修饰的是一个对象</td>
</tr>
</tbody></table>
<p>事件是基于委托的</p>
<ol>
<li><p>类型兼容</p>
</li>
<li><p>存储方法的引用</p>
<p>委托是事件的“底层基础”</p>
<p>事件是委托的“上层建筑”</p>
</li>
</ol>
<blockquote>
<p>委托和事件的关系</p>
</blockquote>
<p>首先需要澄清的是： 事件不是委托类型的字段，也不是一种特殊委托类型的字段，也不是一种特殊方式声明的委托方式字段。<strong>事件只是委托类型字段的包装器、限制器，限制外界对委托字段的访问</strong>。委托类型的字段通过事件包装、限制之后，外界只能访问他的+&#x3D;、-&#x3D;操作符，换言之只能够【添加】或【移除】事件处理器，用来阻挡非法操作的“蒙版”，它绝对不是委托字段的本身。</p>
<blockquote>
<p>为什么要使用委托类型来声明事件、为什么事件是基于委托的</p>
</blockquote>
<p>站在事件的拥有者来说：是为了表明事件拥有者、能够对外部通知什么样的消息</p>
<p>站在事件订阅者、被通知者角度来说：是一种【约定】事件处理器能够收到什么样的消息也约束了我们使用什么样的方法、签名来处理响应这个事件，并且，我们会使用委托类型的实例去储存方法的引用、去储存未来这个事件处理器。当事件的响应者，向事件的拥有者，提供了一个与之匹配的事件的事件处理器之后需要找一个地方把事件处理器保存、记录、储存下来。能够记录、引用方法的这个任务，只有委托才能做到</p>
<blockquote>
<p>C#中委托和接口有什么区别？各用在什么场合？</p>
</blockquote>
<p><strong>委托delegate</strong>：unity事件与委托密切相关，回调机制，减少对象之间数据交互<br><strong>接口interface</strong>：多人协作，完全抽象，类单继承<br>委托是约束方法的集合<br>接口是约束类具备的功能集合，解决类单继承问题</p>
<h3 id="C-Action和Func问题"><a href="#C-Action和Func问题" class="headerlink" title="C#Action和Func问题"></a>C#Action和Func问题</h3><blockquote>
<p>C#中的Action和Func是什么？他们有什么区别？</p>
</blockquote>
<p>Action和Func是System命名空间下 C#为我们提供的两个写好的委托</p>
<ul>
<li><p><strong>Action</strong>本身是一个无参无返回值的委托<br>对应的Action&lt;&gt;泛型委托支持最多16个参数</p>
</li>
<li><p><strong>Func</strong>本身是一个无参有返回值的委托<br>对应的Func&lt;&gt;泛型委托支持最多16个参数，并且有返回值</p>
</li>
</ul>
<blockquote>
<p>Unity 中的UnityAction是什么？</p>
</blockquote>
<ol>
<li><p><strong>UnityAction</strong>是UnityEngine.Events命名空间下 <strong>Unity为我们提供的写好的委托</strong></p>
</li>
<li><p>UnityAction本身<strong>是一个无参无返回值的委托</strong><br>对应的UnityAction&lt;&gt;<strong>泛型委托支持最多4个参数</strong></p>
</li>
</ol>
<h3 id="C-Lambda问题"><a href="#C-Lambda问题" class="headerlink" title="C# Lambda问题"></a>C# Lambda问题</h3><blockquote>
<p>C# 函数 Func(string a, string b)用 Lambda 表达式怎么写?</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#">Lambda表达式（任意参数）=&gt; &#123; 表达式&#125; ； =&gt; 读作goesto<br>（a,b）=&gt; &#123; &#125; ;<br></code></pre></td></tr></table></figure>



<h3 id="C-回调函数指什么？一般在什么时候使用？（至少说出3种使用场景）"><a href="#C-回调函数指什么？一般在什么时候使用？（至少说出3种使用场景）" class="headerlink" title="C# 回调函数指什么？一般在什么时候使用？（至少说出3种使用场景）"></a>C# 回调函数指什么？一般在什么时候使用？（至少说出3种使用场景）</h3><p>回调函数指在程序设计中，将一个函数作为参数传递给另一个函数，并在另一个函数执行完毕后被调用的函数，在C#中，一般以委托形式出现</p>
<p>什么时候使用：<br>1.异步编程：异步逻辑执行完毕后，再执行回调函数<br>2.事件中心<br>3.UI界面中的空间逻辑回调，比如按钮点击<br>等等</p>
<h3 id="C-反射问题"><a href="#C-反射问题" class="headerlink" title="C# 反射问题"></a>C# 反射问题</h3><p>程序正在运行时，可以查看其他程序集或者自身的元数据</p>
<p><strong>一个运行的程序</strong><font color = "red"><b>查看本身或者其它程序的元数据的行为</b></font><strong>就叫做反射</strong></p>
<h4 id="反射的实现原理"><a href="#反射的实现原理" class="headerlink" title="反射的实现原理"></a>反射的实现原理</h4><p><strong>定义：</strong>运行时，动态获取类型信息,动态创建对象,动态访问成员的过程。<br><strong>另一种定义：</strong>审查元数据并收集元数据的信息。<br>元数据：编译后的最基本数据单元，就是一堆表，反射就是解析这些元数据。<br>反射是在运行期间获取到类、对象、方法、数据的一种手段<br>主要使用类库System.Reflection<br><strong>反射要点：</strong>如何获取类型，根据类型来动态创建对象，反射获取方法以及动态调用方法，动态创建委托</p>
<blockquote>
<p>反射的作用是什么？</p>
</blockquote>
<ol>
<li>程序运行时得到所有元数据，包括元数据的特性</li>
<li>程序运行时，实例化对象，操作对象</li>
<li>程序运行时创建新对象，用这些对象执行任务</li>
</ol>
<blockquote>
<p>如何利用反射获取类中所有公共成员</p>
</blockquote>
<p>用Type 和MemberInfo 来获取</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#">Type t = Type(Test);<br>MemberInfo[] infos  = t.GetMembers();<br></code></pre></td></tr></table></figure>

<blockquote>
<p>如何得到无参和有参构造函数并执行</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//无参</span><br>ConstructorInfo info = t.GetConstructor(<span class="hljs-keyword">new</span> Type[<span class="hljs-number">0</span>]);<br><span class="hljs-comment">//无参构造没有参数传null</span><br>Test obj = info.Invoke(<span class="hljs-literal">null</span>) <span class="hljs-keyword">as</span> Test;<br><br><span class="hljs-comment">//有参</span><br>ConstructorInfo info2 = t.GetConstructor(<span class="hljs-keyword">new</span> Type[]&#123;<span class="hljs-keyword">typeof</span>（<span class="hljs-built_in">int</span>&#125;);<br>obj = info2.Invoke(<span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>[]&#123;<span class="hljs-number">2</span>&#125;) <span class="hljs-keyword">as</span> Test;<br></code></pre></td></tr></table></figure>

<p>MemberInfo : 公共成员信息</p>
<p>ConstructorInfo : 构造函数信息</p>
<p>FieldInfo : 成员变量信息</p>
<p>MehodInfo ： 方法信息</p>
<blockquote>
<p>反射里如何快速实例化对象类</p>
</blockquote>
<p>先得到Type 然后<strong>Activator.CreatInstance</strong>快速实例化一个对象</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C#">Test test = <span class="hljs-keyword">typeof</span>(Test);<br><span class="hljs-comment">//无参构造</span><br>Test testObj = Activator.CreatInstance(testType) <span class="hljs-keyword">as</span> Test;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>如何加载程序集，使用反射</p>
</blockquote>
<p>程序集类</p>
<ul>
<li>主要用来加载其他程序集，加载后才能用Type来使用不是自己程序集的内容。</li>
<li>如果使用的不是自己程序集中的内容 需要现加载程序集，比如dll文件</li>
</ul>
<p><font color = "red">三种方法加载程序集</font></p>
<ul>
<li><p><strong>同一文件下的其他程序集</strong></p>
<p><strong>Assembly.Load(“程序集名称”)</strong></p>
</li>
<li><p><strong>不同文件下的其他程序集</strong></p>
<p><strong>Assembly.LoadFrom(“包含程序集清单的文件的名称或路径”)</strong></p>
<p><strong>Assembly.LoadFile(“要加载的文件的完全限定路径”)</strong></p>
</li>
</ul>
<p>例：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//1.先加载一个指定程序集</span><br>            Assembly asembly = Assembly.LoadFrom(<span class="hljs-string">@&quot;C:\Users\MECHREVO\Desktop\CSharp进阶教学\Lesson18_练习题\bin\Debug\netcoreapp3.1\Lesson18_练习题&quot;</span>);<br>            Type[] types = asembly.GetTypes();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; types.Length; i++)<br>            &#123;<br>                Console.WriteLine(types[i]);<br>            &#125;<br>            <span class="hljs-comment">//2.再加载程序集中的一个类对象 之后才能使用反射</span><br>            Type icon = asembly.GetType(<span class="hljs-string">&quot;Lesson18_练习题.Icon&quot;</span>);<br>            MemberInfo[] members = icon.GetMembers();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; members.Length; i++)<br>            &#123;<br>                Console.WriteLine(members[i]);<br>            &#125;<br>            <span class="hljs-comment">//通过反射 实例化一个 icon对象</span><br>            <span class="hljs-comment">//首先得到枚举Type 来得到可以传入的参数</span><br>            Type moveDir = asembly.GetType(<span class="hljs-string">&quot;Lesson18_练习题.E_MoveDir&quot;</span>);<br>            FieldInfo right = moveDir.GetField(<span class="hljs-string">&quot;Right&quot;</span>);<br>            <span class="hljs-comment">//直接实例化对象</span><br>            <span class="hljs-built_in">object</span> iconObj = Activator.CreateInstance(icon, <span class="hljs-number">10</span>, <span class="hljs-number">5</span>, right.GetValue(<span class="hljs-literal">null</span>));<br>            <span class="hljs-comment">//得到对象中的方法 通过反射</span><br>            MethodInfo move = icon.GetMethod(<span class="hljs-string">&quot;Move&quot;</span>);<br>            MethodInfo draw = icon.GetMethod(<span class="hljs-string">&quot;Draw&quot;</span>);<br>            MethodInfo clear = icon.GetMethod(<span class="hljs-string">&quot;Clear&quot;</span>);<br></code></pre></td></tr></table></figure>





<h3 id="C-中ref和out关键字有什么区别？知道Ref的深层原理是什么？"><a href="#C-中ref和out关键字有什么区别？知道Ref的深层原理是什么？" class="headerlink" title="C#中ref和out关键字有什么区别？知道Ref的深层原理是什么？"></a>C#中ref和out关键字有什么区别？知道Ref的深层原理是什么？</h3><ul>
<li><p><strong>ref</strong>修饰引用参数</p>
<p>参数必须赋值，带回返回值，又进又出</p>
</li>
<li><p><strong>out</strong>修饰输出参数</p>
<p>参数可以不赋值，带回返回值之前必须明确赋值，<br>引用参数和输出参数不会创建新的存储位置</p>
</li>
</ul>
<p>如果ref参数是值类型，原先的值类型数据，会随着方法里的数据改变而改变，<br>如果ref参数值引用类型，方法里重新赋值后，原对象堆中数据会改变，如果对引用类型再次创建新对象并赋值给ref参数，引用地址会重新指向新对象堆数据。方法结束后形参和新对象都会消失。实参还是指向原始对象，值不够数据改变了</p>
<h3 id="C-值和地址问题"><a href="#C-值和地址问题" class="headerlink" title="C# 值和地址问题"></a>C# 值和地址问题</h3><p><strong>请问A、B、C 三处打印结果分别为多少？为什么？</strong></p>
<p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/addressProblem.png" srcset="/img/loading.gif" lazyload></p>
<p>A是10，B和C为100</p>
<p>Test1处参数传递进去后，函数内部的形参value是在栈上重新开辟的空间，将传入参数的值拷贝到了该空间中，和传入参数没有关系</p>
<p>Test2处参数是指针类型，指针是用于存储内存地址的变量，我们传入的是值得地址&amp;test2Value，在函数内部改变的是地址中存储的值，所以外部的test2Value会随之改变</p>
<p>Test3处ref关键字，底层逻辑中是将value作为test3Value的一个别名，他们指向的空间一致，所以value改变后，外部的test3Value也会改变</p>
<h3 id="C-分布类如何写"><a href="#C-分布类如何写" class="headerlink" title="C# 分布类如何写"></a>C# 分布类如何写</h3><p>再类前加<strong>partial</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>&#123;&#125;<br></code></pre></td></tr></table></figure>



<h3 id="C-协变和逆变"><a href="#C-协变和逆变" class="headerlink" title="C# 协变和逆变"></a>C# 协变和逆变</h3><p>协变：</p>
<ul>
<li>和谐的变化，自然的变化</li>
<li>因为 里氏替换原则 父类可以装子类 所以子类 变父类 例如string 变 object，感受是和谐的</li>
</ul>
<p>逆变：</p>
<ul>
<li>逆常规的变化，不正常的变化</li>
<li>因为 里氏替换原则 父类可以装子类，子类不能装父类 所以父类变子类，感受是不和谐的</li>
</ul>
<p><strong>协变和逆变是修饰泛型的</strong></p>
<p><strong>协变：out</strong></p>
<ul>
<li>out修饰的泛型 只能作为返回值</li>
</ul>
<p><strong>逆变：in</strong></p>
<ul>
<li>in修饰的泛型 只能作为参数</li>
</ul>
<p><strong>用于泛型中 戏时 泛型字母的，只有泛型接口和泛型委托能使用</strong></p>
<h3 id="C-using-关键字的两个作用"><a href="#C-using-关键字的两个作用" class="headerlink" title="C# using 关键字的两个作用"></a>C# using 关键字的两个作用</h3><ol>
<li>引用命名空间</li>
<li>安全使用引用对象</li>
</ol>
<h3 id="C-中new关键字的作用（至少说出3种）"><a href="#C-中new关键字的作用（至少说出3种）" class="headerlink" title="C#中new关键字的作用（至少说出3种）"></a>C#中new关键字的作用（至少说出3种）</h3><ol>
<li>创建新对象</li>
<li>子类函数声明时加上new关键字，可以隐藏掉父类方法</li>
<li>泛型约束中使用new关键词，表示需要无参构造</li>
</ol>
<h3 id="C-如何拓展方法"><a href="#C-如何拓展方法" class="headerlink" title="C# 如何拓展方法"></a>C# 如何拓展方法</h3><p>拓展方法：为现有非静态 变量类型 添加 新方法</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Tools</span><br>&#123;<br>    <span class="hljs-comment">//为int 拓展了一个成员方法</span><br>    <span class="hljs-comment">//成员方法 是需要 实例化对象后 才能使用的</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SpeakValue</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span></span>)</span><br>    &#123;<br>        <span class="hljs-comment">//拓展方法的逻辑   </span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//使用</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&#123;<br>    <span class="hljs-built_in">int</span> i = <span class="hljs-number">10</span>;<br>    i.SpeakValue();<br>    <span class="hljs-comment">// 输出拓展方法的逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>作用：</p>
<ol>
<li>提升程序拓展性</li>
<li>不需要再对象中重写方法</li>
<li>不需要继承添加方法</li>
<li>为别人封装的类型写额外的方法</li>
</ol>
<p>特点：</p>
<ol>
<li>一定时是在静态类中</li>
<li>一定是个静态函数</li>
<li>第一个参数为拓展目标</li>
<li>第一个参数用this修饰</li>
</ol>
<p>注意：如果拓展名如果和已有参数相同，会直接调用已有方法</p>
<blockquote>
<p>如果我们想为Unity中的Transform类添加一个自定义的方法，应该如何处理？</p>
</blockquote>
<p>通过C#的拓展方法相关知识点进行添加</p>
<h3 id="什么是闭包？可以举例说明"><a href="#什么是闭包？可以举例说明" class="headerlink" title="什么是闭包？可以举例说明"></a>什么是闭包？可以举例说明</h3><p>闭包是指有权访问另一个函数作用域中的变量的函数<br>所以闭包一般都是指的一个函数<br>创建这种特殊闭包函数的方式往往是在一个函数中创建另一个函数</p>
<p><strong>闭包需要满足四个条件</strong></p>
<ol>
<li>有函数嵌套</li>
<li>内部函数引用外部作用域的变量参数</li>
<li>返回值是函数</li>
<li>创建一个对象函数，让其长期驻留</li>
</ol>
<p><strong>闭包的经典示例</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c#">    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>        &#123;<br>            Task.Run(() =&gt; Console.WriteLine(i));<br>        &#125;<br><br>        Console.ReadKey();<br>    &#125;<br><br>output:<br><span class="hljs-number">5</span><br><span class="hljs-number">5</span><br><span class="hljs-number">5</span><br><span class="hljs-number">5</span><br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>

<p>Task.Run中的委托其实就是我们的闭包，它把局部变量i捕获了，所以在执行这个闭包的时候可以使用到变量i，也就是闭包执行的时候i是多少，那么传入的参数就是多少。</p>
<p>但是按理说，i&#x3D;0时，也会执行闭包啊，为什么传入的不是0。<strong>猜测i&#x3D;0时，闭包并没有立马执行，包括i&#x3D;1,2,3,4等，只有在for循环结束了的时候（i&#x3D;5）时闭包才一起执行的，所以输出的都是5</strong>。我们可以把代码改为这样：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C#">        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>            &#123;<br>                Task task = Task.Run(() =&gt; Console.WriteLine(i));<br>                task.Wait();<br>            &#125;<br><br>            Console.ReadKey();<br>        &#125;<br>output:<br><span class="hljs-number">0</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br><br></code></pre></td></tr></table></figure>



<h3 id="C-线程、线程池、任务问题"><a href="#C-线程、线程池、任务问题" class="headerlink" title="C# 线程、线程池、任务问题"></a>C# 线程、线程池、任务问题</h3><blockquote>
<p>请说明Thread、ThreadPool、Task分别是什么？并简单说明彼此的区别</p>
</blockquote>
<ul>
<li>Thread是线程，可以使用他开启线程处理复杂逻辑，避免主线程卡顿</li>
<li>ThreadPool是线程池，他是C#为线程实现的缓存池，主要用于减少线程的创建，减少GC触发</li>
<li>Task是任务，他是基于线程池的优化，让我们可以更方便的控制线程</li>
</ul>
<blockquote>
<p>什么是线程池</p>
</blockquote>
<p>ThreadPool中有若干数量的线程，如果有任务需要处理时，会从线程池中获取一个空闲的线程来执行任务，当线程池中所有的线程都在忙碌时，又会有新任务要处理，线程池才会新建一个线程来处理该任务，如果线程数量到达设置的最大值，任务会排队，等待其他任务释放线程再执行。</p>
<p>优点：<strong>线程池能减少线程创建，节省开销，可以减少GC垃圾回收的触发</strong></p>
<p>缺点：<strong>不能控制线程池的执行顺序，也不能获取线程池内线程取消&#x2F;异常&#x2F;完成的通知</strong></p>
<blockquote>
<p>创建Task无返回值的三种方式</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C#">Task t1 = <span class="hljs-keyword">new</span> Task(()=&gt;&#123;&#125;);<br>t1.Start();<br><br>Task t2 = Task.Run(()=&gt;&#123;&#125;);<br><br>Task t3 = Task.Factory.StartNew(()=&gt;&#123;&#125;);<br></code></pre></td></tr></table></figure>

<p>如果需要返回值，直接加泛型，泛型里的就是返回类型</p>
<h3 id="C-同步和异步"><a href="#C-同步和异步" class="headerlink" title="C# 同步和异步"></a>C# 同步和异步</h3><p>同步和异步主要用于修饰方法</p>
<p><strong>同步方法：</strong></p>
<p>当一个方法被调用时，调用者需要等待该方法执行完毕后返回才能继续执行</p>
<p><strong>异步方法：</strong></p>
<p>当一个方法被调用时立即返回，并获取一个线程执行该方法内部的逻辑，调用者不用等待该方法执行完毕</p>
<p>使用<strong>async</strong>修饰异步方法</p>
<ol>
<li><strong>再异步方法中使用await关键字，否则异步方法会以同步执行</strong></li>
<li><strong>再异步方法名称建议以Async结尾</strong></li>
<li><strong>异步方法的返回值只能时void、Task、Task&lt;&gt;</strong></li>
<li><strong>异步方法中不能声明使用ref或out关键字修饰变量</strong></li>
</ol>
<blockquote>
<p>什么时候需要异步编程</p>
</blockquote>
<p>需要处理的逻辑会严重影响主线程执行的流畅性时，我们需要使用异步编程</p>
<p>例如：</p>
<ol>
<li>复杂逻辑计算</li>
<li>网络下载、网络通讯</li>
<li>资源加载</li>
</ol>
<h3 id="C-中元组对于我们的作用是什么？"><a href="#C-中元组对于我们的作用是什么？" class="headerlink" title="C#中元组对于我们的作用是什么？"></a>C#中元组对于我们的作用是什么？</h3><p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%85%83%E7%BB%84.png" srcset="/img/loading.gif" lazyload></p>
<ol>
<li>可以在不用写数据结构类的情况下</li>
<li>利用元组处理多返回值，或者临时数据的集合</li>
</ol>
<h3 id="内存泄漏问题"><a href="#内存泄漏问题" class="headerlink" title="内存泄漏问题"></a>内存泄漏问题</h3><blockquote>
<p>内存泄漏指什么？</p>
</blockquote>
<p>内存泄漏指的就是对象超过生命周期后而不能被GC回收，一般指<strong>不会再使用的引用对象由于某些操作而不能被GC垃圾回收，而一直占用着内存</strong></p>
<p>更风趣通俗一点的说就是：<strong>没用的家伙没有被当成垃圾回收</strong></p>
<blockquote>
<p>常见的内存泄漏有哪些？</p>
</blockquote>
<p>常见的内存泄漏有：</p>
<ol>
<li>静态引用</li>
<li>不使用的引用对象没有置null，一直被引用</li>
<li>文件操作时，没有使用using或者没有进行Dispose()</li>
<li>委托或事件注册后没有解除注册（有加就有减）<br>等等</li>
</ol>
<h3 id="序列化问题"><a href="#序列化问题" class="headerlink" title="序列化问题"></a>序列化问题</h3><blockquote>
<p>序列化是什么？</p>
</blockquote>
<p>序列化是将<strong>程序中数据对象转换为可以存储或传输的形式 的过程</strong>。</p>
<blockquote>
<p>常见的序列化方式有哪些？什么时候我们会用到序列化？</p>
</blockquote>
<p>我们常见的序列化方式 <strong>xml、Json、2进制等</strong>。就是将内存中的数据按照我们自己定义的规则进行序列化，序列化之后就可以用于存储和传输，当读取和接受数据时，只需要按照对应规则进行反序列化便可得到原始数据</p>
<p>所谓的存储读取和传输接受，其实一般指的就是<strong>数据持久化和网络通讯</strong><br>所以我们经常会在这两块知识点看到序列化反序列化这两个关键词</p>
<blockquote>
<p>文件中保存了文本信息，但是打开后却是乱码，一般是什么原因造成的？</p>
</blockquote>
<p>序列化和反序列化字符串时使用的编码格式不统一</p>
<h3 id="C-中try-catch-finally的执行顺序"><a href="#C-中try-catch-finally的执行顺序" class="headerlink" title="C#中try catch finally的执行顺序"></a>C#中try catch finally的执行顺序</h3><p>1.首先明确一点，就是不管怎样，finally一定会执行，即使程序有异常，并且在catch中thorw 了 ，finally还是会被执行。</p>
<p>2.当try和catch中有return时，finally仍然执行。</p>
<p>3.finally是在return后面的表达式运算完之后执行的，在执行完return时 ，程序并没有跳出，而是进入到finally中继续执行，</p>
<p> 如果在finally如果对返回值进行了重新赋值，分为两种情况：</p>
<p>（1）当返回值是值类型（包括string类型，虽然是引用类型，这是特殊的个例）时，返回的值不受影响，</p>
<p>​    就是在trycatch时，返回的值已经确定了。</p>
<p>（2）当返回值是引用类型时，会影响到返回值，</p>
<p>eg:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span>[] <span class="hljs-title">TestYinYong</span>()</span><br>     &#123;<br>         <span class="hljs-built_in">string</span>[] arr = &#123; <span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span> &#125;;<br>         <span class="hljs-keyword">try</span><br>         &#123;<br>             <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception();<br>         &#125;<br>         <span class="hljs-keyword">catch</span> (Exception)<br>         &#123;<br>             <span class="hljs-keyword">return</span> arr;<br>         &#125;<br>         <span class="hljs-keyword">finally</span><br>         &#123;<br>             arr[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;three&quot;</span>;<br>         &#125;<br>     &#125;<br></code></pre></td></tr></table></figure>

<p>此时返回的值是：{ “one”, “three” };</p>
<p>4.finally中不能有return语句，编译都无法通过，提示：控制不能离开finally子句主体</p>
<h3 id="C-内存抖动指什么？如何避免内存抖动"><a href="#C-内存抖动指什么？如何避免内存抖动" class="headerlink" title="Ｃ# 内存抖动指什么？如何避免内存抖动"></a>Ｃ# 内存抖动指什么？如何避免内存抖动</h3><p>答案：<br>内存抖动指<strong>短时间内有大量的对象被创建或者被回收的现象</strong><br>频繁的内存抖动会造成 GC 频繁运行，造成卡顿</p>
<p><strong>避免方式：</strong><br>对象池<br>享元模式<br>等</p>
<h3 id="C-索引器问题"><a href="#C-索引器问题" class="headerlink" title="C# 索引器问题"></a>C# 索引器问题</h3><p><strong>索引器概念：</strong></p>
<p>让对象可以让数组已有通过索引访问其中元素，使程序看起来更直观，更容易编写</p>
<blockquote>
<p>如何编写索引器</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">private</span> Person[] friend;<br><span class="hljs-keyword">public</span> Person <span class="hljs-keyword">this</span>[<span class="hljs-built_in">int</span> index]<br>&#123;<br>    <span class="hljs-keyword">get</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> friends[index];<br>    &#125;<br>    <span class="hljs-keyword">set</span><br>    &#123;<br>        friends[index] = <span class="hljs-keyword">value</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<h3 id="C-GC问题"><a href="#C-GC问题" class="headerlink" title="C# GC问题"></a>C# GC问题</h3><blockquote>
<p>GC是什么</p>
</blockquote>
<ul>
<li>垃圾回收的过程是遍历堆上动态分配的所有对象</li>
<li>通过识别他们是否被引用拉确定那些对象是垃圾，哪些对象仍要被使用</li>
<li>所谓的垃圾就是没有被任何遍历，对象引用的内容</li>
<li>垃圾就需要被回收释放</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li><strong>GC只负责堆（Heap）内存的垃圾回收</strong></li>
<li>引用内心都是存在堆中的，所以它的分配和释放都通过垃圾回收机制来管理</li>
<li><strong>栈上内存是由系统自动管理的</strong>，值类型在栈中分配内存的，他们由自己的生命周期，不用堆他们进行管理，会自动分配和释放</li>
</ul>
<blockquote>
<p><strong>C# GC内存回收机制大致原理</strong></p>
</blockquote>
<p>0代内存	1代内存	2代内存</p>
<p><strong>代的概念</strong></p>
<ul>
<li>代是GC使用的一种算法（分代算法）</li>
<li>新分配的对象都会被配置在第0代内存中</li>
<li>每次分配都可能会进行GC释放内存（0代内存满时）</li>
</ul>
<p>在一次内存回收过程开始时，垃圾回收器认为堆中全是垃圾，会进行以下两个步骤</p>
<ol>
<li><strong>标记对象，从根（静态字段、方法参数）开始检查引用对象，标记后为可达对象，未标记为不可达对象，不可达对象就认为是垃圾</strong></li>
<li><strong>搬迁对象压缩堆（挂起执行托管代码线程）释放未标记的对象 搬迁可达对象，修改引用地址</strong></li>
</ol>
<p>大对象总被认为是第二代内存，目的是减少性能损耗，提高性能</p>
<p>不会对大对象进行搬迁压缩 85000字节<strong>（83kb）以上的对象为大对象</strong></p>
<blockquote>
<p>请简述GC（垃圾回收）产生的原因，并至少说出避免GC发生的三种方式？</p>
</blockquote>
<ul>
<li><p>GC产生原因</p>
<p>是 避免堆内存溢出而产生的回收机制<br>当不再使用的堆内存占用达到一定上限时，将会进行垃圾回收</p>
</li>
<li><p>避免方式：</p>
<ol>
<li>尽量减少new对象，尽量复用对象（可使用缓存池）</li>
<li>用StringBuilder替换String，避免字符串拼接时产生垃圾</li>
<li>公共对象用静态声明<br>等等</li>
</ol>
</li>
</ul>
<h3 id="请简要说明-Net跨语言原理"><a href="#请简要说明-Net跨语言原理" class="headerlink" title="请简要说明.Net跨语言原理"></a>请简要说明.Net跨语言原理</h3><p><strong>.Net制定了了CLI（公共语言架构）的规则</strong><br>只要是按照该规则设计的语言在进行.Net相关开发时<br><strong>编译器会将源代码（C#、VB等等）编译为CIL（公共中间语言）通用中间代码</strong>。<br>也就是说不管什么语言进行开发，最终都会统一规范变为中间代码<br>最终通过<strong>CLR（公共语言运行时或者称为.Net虚拟）将中间代码翻译为对应操作系统的原生代码（机器码）</strong>在操作系统（Windows）上运行</p>
<p><img src="https://img-blog.csdn.net/20160528132344296" srcset="/img/loading.gif" lazyload alt="img"></p>
<h3 id="网络游戏开发中，网络传输数据的基本流程是什么？"><a href="#网络游戏开发中，网络传输数据的基本流程是什么？" class="headerlink" title="网络游戏开发中，网络传输数据的基本流程是什么？"></a>网络游戏开发中，网络传输数据的基本流程是什么？</h3><p>客户端将自定义类对象数据序列化为2进制数据发送给服务端</p>
<p>服务端将收到的2进制数据反序列化为对应的类对象进行逻辑处理</p>
<p>如果是服务端发送给客户端的消息也是同理</p>
<hr>
<h2 id="🌙Lua、XLua与热更新"><a href="#🌙Lua、XLua与热更新" class="headerlink" title="🌙Lua、XLua与热更新"></a>🌙Lua、XLua与热更新</h2><h3 id="Lua数据类型"><a href="#Lua数据类型" class="headerlink" title="Lua数据类型"></a>Lua数据类型</h3><p>Lua是动态类型语言，变量不要类型定义,只需要为变量赋值。 值可以存储在变量中，作为参数传递或结果返回。</p>
<p>Lua中有<strong>8个基本类型</strong>分别为：<strong>nil、boolean、number、string、userdata、function、thread和table</strong>。</p>
<p>其中：Lua 把 false 和 nil 看作是”假”，其他的都为”真”:</p>
<h3 id="pairs-和-ipairs区别"><a href="#pairs-和-ipairs区别" class="headerlink" title="pairs 和 ipairs区别"></a>pairs 和 ipairs区别</h3><ul>
<li><p><strong>pairs</strong></p>
<p>迭代 table，可以遍历表中所有的 key 可以返回 nil</p>
</li>
<li><p><strong>ipairs</strong></p>
<p>迭代数组，不能返回 nil,如果遇到 nil 则退出</p>
</li>
</ul>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> tab= &#123; [<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;a&quot;</span>, [<span class="hljs-number">3</span>] = <span class="hljs-string">&quot;b&quot;</span>, [<span class="hljs-number">4</span>] = <span class="hljs-string">&quot;c&quot;</span> &#125; <br><br><span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(tab) <span class="hljs-keyword">do</span>        <span class="hljs-comment">-- 输出 &quot;a&quot; ,&quot;b&quot;, &quot;c&quot;  ,    </span><br><br>   	<span class="hljs-built_in">print</span>( tab[i] ) <br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(tab) <span class="hljs-keyword">do</span>    <span class="hljs-comment">-- 输出 &quot;a&quot; ,k=2时断开</span><br><br>    <span class="hljs-built_in">print</span>( tab[i] )<br><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>



<h3 id="Lua表中问题"><a href="#Lua表中问题" class="headerlink" title="Lua表中问题"></a>Lua表中问题</h3><blockquote>
<p>下列代码中是否会打印 1</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua">Student = &#123;<br>    age = <span class="hljs-number">1</span>,<br>    Up = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>        <span class="hljs-built_in">print</span>(age)<br>    <span class="hljs-keyword">end</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>不会，这个<strong>print(age) 和 表中的age 没有关系</strong></p>
<p>print(a)里面的age是一个全局变量</p>
<p>如果要使用，改成</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--第一钟</span><br><span class="hljs-built_in">print</span>(Student.age)<br><span class="hljs-comment">--第二种 把自己作为一个参数 </span><br>Up = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(t)</span></span><br>    <span class="hljs-built_in">print</span>(t.age)<br><span class="hljs-keyword">end</span><br><span class="hljs-comment">--调用时,把自己作为参数传入自己</span><br>Student.Up(Student)<br><br><span class="hljs-comment">--第三种 使用语法糖 重要！！！</span><br>Up = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(t)</span></span><br>    <span class="hljs-built_in">print</span>(t.age)<br><span class="hljs-keyword">end</span><br>Student:Up()<br></code></pre></td></tr></table></figure>

<blockquote>
<p>Lua 中0 . 和 ：的区别</p>
</blockquote>
<ul>
<li><p><strong>：(冒号）</strong></p>
<p>冒号调用方法，会默认把调用者 作为第一个参数传入方法中</p>
<p>注：内部不能使用：，只能在外部使用</p>
</li>
</ul>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> t = &#123; x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span> &#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">t:SetPos</span><span class="hljs-params">(newX, newY)</span></span><br>  <span class="hljs-comment">--self会默认调用第一个参数 ： 的第一个参数就是表本身</span><br>  <span class="hljs-built_in">self</span>.x = newX<br>  <span class="hljs-built_in">self</span>.y = newY<br><span class="hljs-keyword">end</span><br><br>t:SetPos(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)<br></code></pre></td></tr></table></figure>

<ul>
<li><p><strong>.  (点)</strong></p>
<p>正常调用方法，直接访问表中的元素，有啥传啥</p>
</li>
</ul>
<h3 id="Lua元方法"><a href="#Lua元方法" class="headerlink" title="Lua元方法"></a>Lua元方法</h3><blockquote>
<p>Lua中常用的元方法有哪些？至少说出3个原方法</p>
</blockquote>
<p><code>__</code>index<br><code>__</code>newindex<br><code>__</code>tostring<br><code>__</code>call<br><code>__</code>add 运算符+<br><code>__</code>sub 运算符-<br><code>__</code>mul 运算符*<br><code>__</code>div 运算符&#x2F;<br><code>__</code>mod 运算符%<br><code>__</code>unm 运算符-<br><code>__</code>concat 运算符..<br><code>__</code>eq 运算符&#x3D;&#x3D;<br><code>__</code>lt 运算符&lt;<br><code>__</code>le 运算符&lt;&#x3D;<br>等</p>
<h3 id="Lua元表-Metatable"><a href="#Lua元表-Metatable" class="headerlink" title="Lua元表(Metatable)"></a>Lua元表(Metatable)</h3><p>在 Lua table 中我们可以访问对应的key来得到value值，但是却无法对两个 table 进行操作。</p>
<p>因此 Lua 提供了<strong>元表(Metatable)，允许我们改变table的行为，每个行为关联了对应的元方法</strong>。</p>
<p>例如，使用元表我们可以定义Lua如何计算两个table的相加操作a+b。</p>
<p>当Lua试图对两个表进行相加时，先检查两者之一是否有元表，之后检查是否有一个叫”__add”的字段，若找到，则调用对应的值。”  _add”等即时字段，其对应的值（往往是一个函数或是table）就是”元方法”。</p>
<p>有两个很重要的函数来处理元表：</p>
<ul>
<li><p><strong>setmetatable(table,metatable):</strong></p>
<p>对指定table设置元表(metatable)，如果元表(metatable)中存在__metatable键值，setmetatable会失败 。</p>
</li>
<li><p><strong>getmetatable(table)</strong></p>
<p>返回对象的元表(metatable)。</p>
</li>
<li><p><strong>__index 元方法</strong></p>
</li>
</ul>
<p>这是 metatable 最常用的键。</p>
<p>当你通过键来访问 table 的时候，如果这个键没有值，那么Lua就会寻找该table的metatable（假定有metatable）中的_index 键。如果 __index包含一个表格，Lua会在表格中查找相应的键。</p>
<p>Lua查找一个表元素时的规则，其实就是如下3个步骤:</p>
<ol>
<li><p>在表中查找，如果找到，返回该元素，找不到则继续</p>
</li>
<li><p>判断该表是否有元表，如果没有元表，返回nil，有元表则继续。</p>
</li>
<li><p>判断元表有没有<code>__</code>index方法，如果<code>__</code>index方法为nil，则返回nil；如果<code>__</code>index方法是一个表，则重复1、2、3；如果<code>__</code>index方法是一个函数，则返回该函数的返回值。</p>
</li>
</ol>
<ul>
<li><p><strong><code>__</code>newindex 元方法</strong></p>
<p><code>__</code>newindex 元方法用来对表更新，__index则用来对表访问 。</p>
</li>
</ul>
<p>当你给表的一个缺少的索引赋值，解释器就会查找__newindex 元方法：如果存在则调用这个函数而不进行赋值操作。</p>
<ul>
<li><strong>__call 元方法</strong></li>
</ul>
<p>​	   <code>__</code>call 元方法用于控制 function 的调用行为。</p>
<ul>
<li><strong>__tostring 元方法</strong></li>
</ul>
<p>​	   <code>__</code>tostring 元方法用于修改表的输出行为。</p>
<ul>
<li><p><strong>rawget（table，“key”）</strong></p>
<p>当我们使用它时，会去找自己身上有没有这个变量，不会去metatable找</p>
</li>
<li><p><strong>rawset(table,”key”,value)</strong></p>
</li>
<li><p>会忽略newindex的设置 只会改自己的变量</p>
</li>
</ul>
<blockquote>
<p>_index  和 _newindex 的区别</p>
</blockquote>
<p>在 Lua 中，<code>__index</code> 和 <code>__newindex</code> 是元方法，用于控制表的索引操作和新索引操作。它们都可以用于实现数据的动态访问和更新</p>
<ul>
<li><p><strong><code>__index</code></strong> </p>
<p><code>__index</code> 元方法会在表中<strong>查找不存在的键</strong>时被调用</p>
</li>
<li><p><strong><code>__newindex</code></strong></p>
<p><code>__newindex</code> 元方法则会在表中<strong>设置不存在的键</strong>时被调用。</p>
</li>
</ul>
<h3 id="Lua-闭包的体现是什么"><a href="#Lua-闭包的体现是什么" class="headerlink" title="Lua 闭包的体现是什么"></a>Lua 闭包的体现是什么</h3><p>函数里面返回一个函数，改变函数变量里面的生命周期</p>
<p>闭包&#x3D;函数+引用环境<br>子函数可以使用父函数中的局部变量，这种行为可以理解为闭包</p>
<h3 id="Lua如何实现面向对象的三大特性？"><a href="#Lua如何实现面向对象的三大特性？" class="headerlink" title="Lua如何实现面向对象的三大特性？"></a>Lua如何实现面向对象的三大特性？</h3><p>面向对象三大特性</p>
<ul>
<li>封装：利用<strong>table进行封装</strong></li>
<li>继承：利用<strong>元表和<code>__</code>index</strong>模拟继承关系<br>       设置<strong>子类的元表为父类</strong>，<strong>父类的_index为父类自己</strong><br>       当<strong>子类</strong>身上<strong>找不到对应属性和方法</strong>时<br>       会<strong>查找元表的<code>__</code>index中的内容，也就是会查找父类中的内容</strong><br>       通过这种方式来模拟继承</li>
<li>多态：子类自己去实现带：的同名方法即可</li>
</ul>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--面向对象三大特性 ： 封装 继承 多态</span><br><br>Object = &#123;&#125;<br><br><span class="hljs-comment">--封装</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Object:new</span><span class="hljs-params">()</span></span><br>	<span class="hljs-keyword">local</span> obj = &#123;&#125;<br>    <span class="hljs-built_in">self</span>.<span class="hljs-built_in">__index</span> = <span class="hljs-built_in">self</span>;<br>    <span class="hljs-built_in">setmetatable</span>(obj,<span class="hljs-built_in">self</span>)<br>    <span class="hljs-keyword">return</span> obj<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">--继承</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Object:subClass</span><span class="hljs-params">(classname)</span></span><br>    <span class="hljs-built_in">_G</span>[classname] = &#123;&#125;<br>    <span class="hljs-keyword">local</span> obj = <span class="hljs-built_in">_G</span>[classname]<br>    <span class="hljs-built_in">self</span>.<span class="hljs-built_in">__index</span> = <span class="hljs-built_in">self</span><br>    obj.base = <span class="hljs-built_in">self</span><br>    <span class="hljs-built_in">setmetatable</span>(obj,<span class="hljs-built_in">self</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>



<h3 id="Lua-中-require，loadfile和dofile的区别"><a href="#Lua-中-require，loadfile和dofile的区别" class="headerlink" title="Lua 中 require，loadfile和dofile的区别?"></a>Lua 中 require，loadfile和dofile的区别?</h3><p>首先区分loadfile，loadfile只负责编译并不会执行模块代码，而require和dofile都会编译且执行</p>
<h3 id="Lua-协同程序-coroutine"><a href="#Lua-协同程序-coroutine" class="headerlink" title="Lua 协同程序(coroutine)"></a><strong>Lua 协同程序(coroutine)</strong></h3><p><strong>什么是协同(coroutine)？</strong></p>
<p>Lua 协同程序(coroutine)与线程比较类似：拥有独立的堆栈，独立的局部变量，独立的指令指针，同时又与其它协同程序共享全局变量和其它大部分东西。</p>
<p>协同是非常强大的功能，但是用起来也很复杂。</p>
<p><strong>线程和协同程序区别</strong></p>
<p>线程与协同程序的主要区别在于，一个具有多个线程的程序可以同时运行几个线程，而协同程序却需要彼此协作的运行。</p>
<p>在任一指定时刻只有一个协同程序在运行，并且这个正在运行的协同程序只有在明确的被要求挂起的时候才会被挂起。</p>
<p>协同程序有点类似同步的多线程，在等待同一个线程锁的几个线程有点类似协同。</p>
<p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Lua%E5%8D%8F%E7%A8%8B.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="Lua-深拷贝和浅拷贝的区别"><a href="#Lua-深拷贝和浅拷贝的区别" class="headerlink" title="Lua 深拷贝和浅拷贝的区别"></a>Lua 深拷贝和浅拷贝的区别</h3><ul>
<li><p>浅拷贝</p>
</li>
<li><p>使用 &#x3D; 运算符号进行浅拷贝</p>
<p>拷贝对象是string、number、bool基本类型。拷贝的过程就是复制黏贴！修改新拷贝出来的对象，不会影响原先对象的值，两者互不干涉</p>
</li>
<li><p>深拷贝</p>
<p>拷贝对象是table表，拷贝出来的对象和原先对象时同一个对象，占用同一个对象，只是一个人两个名字，类似C#引用地址，指向同一个堆里的数据~，两者任意改变都会影响对方。</p>
</li>
</ul>
<h3 id="Lua-调用-C-重载时会遇到什么问题？该怎么解决"><a href="#Lua-调用-C-重载时会遇到什么问题？该怎么解决" class="headerlink" title="Lua 调用 C#重载时会遇到什么问题？该怎么解决"></a>Lua 调用 C#重载时会遇到什么问题？该怎么解决</h3><p>Lua 虽然支持调用重载 但是因为lua中的数值类型只有Number</p>
<p>所以对C#中多精度的重载函数支持不好 分不清</p>
<p><strong>解决：</strong></p>
<p>Xlua 提供了解决方法</p>
<ol>
<li>通过Type得到C#函数</li>
<li>通过xlua.tofunction转为lua 然后使用</li>
</ol>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 利用反射机制</span><br><span class="hljs-comment">-- Type 是反射的关键类</span><br><span class="hljs-comment">-- 利用lua的typeof</span><br><br><span class="hljs-comment">--得到参数是int的重载</span><br><span class="hljs-keyword">local</span> m1 = typeof(CS.ClassName):GetMethod(<span class="hljs-string">&quot;FunctionName&quot;</span>,&#123;typeof(CS.System.Int32)&#125;)<br><span class="hljs-comment">--folat 的重载</span><br><span class="hljs-keyword">local</span> m2 = typeof(CS.ClassName):GetMethod(<span class="hljs-string">&quot;FunctionName&quot;</span>,&#123;typeof(CS.System.Single)&#125;)<br><br><span class="hljs-comment">--通过 xlua 提供的一个方法 把他转成lua函数</span><br><span class="hljs-keyword">local</span> f1 = xlua.tofunction(m1)<br><span class="hljs-keyword">local</span> f2 = xlua.tofunction(m2)<br><br>f1(<span class="hljs-number">1</span>)<br>f2(<span class="hljs-number">1.1</span>)<br><br></code></pre></td></tr></table></figure>



<h3 id="如何让系统类型和第三方代码能和Lua互相访问"><a href="#如何让系统类型和第三方代码能和Lua互相访问" class="headerlink" title="如何让系统类型和第三方代码能和Lua互相访问"></a>如何让系统类型和第三方代码能和Lua互相访问</h3><p>利用加特性[CSharpCallLua]和[LuaCallCSharp]解决，但是系统类和第三方代码是不能修改的</p>
<ul>
<li><p><strong>[CSharpCallLua]</strong> </p>
<p>C#调用lua代码的时候 用自定义委托装Lua函数的时候会在委托的时候加[CSharpCallLua] ，让Xlua识别这个委托是用来装lua函数的</p>
<p>接口也会使用这个特性</p>
</li>
<li><p><strong>[LuaCallCSharp]</strong></p>
<p>拓展方法是会加入这个特性</p>
<p>该特性每个被lua调用的类都加可以提示性能</p>
</li>
</ul>
<p><strong>解决方案：</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//写一个静态类</span><br><span class="hljs-keyword">public</span> staitc <span class="hljs-keyword">class</span> <span class="hljs-title">ClassName</span><br>&#123;<br>    [<span class="hljs-meta">CSharpCallLua</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Type&gt; name = <span class="hljs-keyword">new</span> List&lt;Type&gt;()<br>    &#123;<br>        <span class="hljs-keyword">typeof</span>(UnityAction&lt;类型&gt;)<br>    &#125;<br>    --之后生成Xlua代码<br>    --[LuaCallCSharp]同理<br>    [<span class="hljs-meta">LuaCallCSharp</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Type&gt; name = <span class="hljs-keyword">new</span> List&lt;Type&gt;()<br>    &#123;<br>        <span class="hljs-keyword">typeof</span>(GameObject)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//好处:把所有特性汇总在这个地方</span><br></code></pre></td></tr></table></figure>



<h3 id="Lua-支持与不支持哪种类型的泛型函数、如何变为支持"><a href="#Lua-支持与不支持哪种类型的泛型函数、如何变为支持" class="headerlink" title="Lua 支持与不支持哪种类型的泛型函数、如何变为支持"></a>Lua 支持与不支持哪种类型的泛型函数、如何变为支持</h3><p><strong>支持：</strong></p>
<p>有约束有参数的泛型函数</p>
<p><strong>不支持：</strong></p>
<ol>
<li>没有约束的泛型函数</li>
<li>有约束没有参数的泛型函数</li>
<li>非Class的约束</li>
</ol>
<blockquote>
<p>如何变支持</p>
</blockquote>
<p>得到通用函数 设置泛型类型再使用</p>
<p>xlua提供了一个方法 : xlua.get_generic_method</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> name = xlua.get_generic_method(CS.ClassName,<span class="hljs-string">&quot;FuncName&quot;</span>)<br><span class="hljs-keyword">local</span> name_R = name(CS.System.指定类型)<br>name_R(CS.ClassName(),指定类型参数)<br></code></pre></td></tr></table></figure>

<p><font color = "red"><b>注意 有一定使用限制！！！</b></font></p>
<p>如果打包为 Mono 这种方式支持使用</p>
<p>IL2CPP打包 如果泛型参数是引用类型才能使用</p>
<p>IL2CPP打包 如果是值类型，除非C#那边已经调用过 同类型的泛型参数 lua才能够被使用</p>
<h3 id="Resource-和-AssetBundle-的区别"><a href="#Resource-和-AssetBundle-的区别" class="headerlink" title="Resource 和 AssetBundle 的区别"></a>Resource 和 AssetBundle 的区别</h3><ul>
<li><p><strong>Resource</strong></p>
<ol>
<li><p>打包时定死</p>
</li>
<li><p>只读</p>
</li>
<li><p>无法修改</p>
</li>
</ol>
</li>
<li><p><strong>AssetBundle</strong></p>
<ol>
<li>存储位置可以自定</li>
<li>压缩方式自定义</li>
<li>后期可以动态更新</li>
</ol>
</li>
</ul>
<h3 id="请简述热更新的流程"><a href="#请简述热更新的流程" class="headerlink" title="请简述热更新的流程"></a>请简述热更新的流程</h3><p>本地存在资源对比文件和已有资源</p>
<ol>
<li><p>下载资源服务器中的对比文件</p>
</li>
<li><p>将下载下来的远端对比文件和本地的做对比</p>
<p>记录需要更新的资源和要移除的资源</p>
</li>
<li><p>根据第二步中记录的信息，进行资源下载和移除</p>
</li>
<li><p>更新本地对比文件，其内容和刚才下载的远端对比文件一致</p>
</li>
</ol>
<blockquote>
<p>热更新方案有哪些？</p>
</blockquote>
<ul>
<li><p><strong>整包</strong>：存放在上SteamingAssets里<br>——策略：完整更新资源放在包里</p>
<p>——优点：首次更新少</p>
<p>——缺点：安装包下载时间长，首次安装久</p>
</li>
<li><p><strong>分包</strong><br>——策略：少部分资源放在包里，大部分更新资源存放在更新资源器中</p>
<p>——优点：安装包小，安装时间短，下载快</p>
<p>——缺点：首次更新下载解压缩包时间旧</p>
</li>
</ul>
<h3 id="Unity热更新解决方案中，Lua和ILRuntime方案的本质是什么？"><a href="#Unity热更新解决方案中，Lua和ILRuntime方案的本质是什么？" class="headerlink" title="Unity热更新解决方案中，Lua和ILRuntime方案的本质是什么？"></a>Unity热更新解决方案中，Lua和ILRuntime方案的本质是什么？</h3><p><strong>Lua热更本质：</strong><br>Lua是解释型语言，不需要实现编译，在运行时动态解释执行。xLua和toLua等Lua热更新解决方案，是通过在Unity中内置Lua虚拟机（解释器）来执行Lua逻辑的</p>
<p><strong>ILruntime热更本质：</strong><br>ILRuntime通过读取DLL文件中的IL汇编码，通过在Unity中内置的IL解释执行虚拟机（解释器）来执行热更DLL中的代码</p>
<p>总体来说，他们都是在Unity中内置各自的解释器（写好的用于解释执行相关的代码）来执行我们的热更新代码</p>
<h3 id="如果不考虑IOS平台，只在Windows和Android平台上发布游戏，如何在不使用第三方热更新方案的前提下实现热更新功能"><a href="#如果不考虑IOS平台，只在Windows和Android平台上发布游戏，如何在不使用第三方热更新方案的前提下实现热更新功能" class="headerlink" title="如果不考虑IOS平台，只在Windows和Android平台上发布游戏，如何在不使用第三方热更新方案的前提下实现热更新功能"></a>如果不考虑IOS平台，只在Windows和Android平台上发布游戏，如何在不使用第三方热更新方案的前提下实现热更新功能</h3><p><strong>C#的反射</strong><br>可以通过热更DLL文件的形式，加载程序集（dll）<br>利用反射执行热更DLL包中的逻辑</p>
<hr>
<h2 id="🌙计算机网络"><a href="#🌙计算机网络" class="headerlink" title="🌙计算机网络"></a>🌙计算机网络</h2><h3 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP UDP"></a>TCP UDP</h3><p>TCP&#x2F;IP协议（一）网络基础知识 网络七层协议<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wanghuaijun/p/10092930.html">https://www.cnblogs.com/wanghuaijun/p/10092930.html</a></p>
<ul>
<li><p><strong>TCP</strong>(Transmission Control Protocol 传输控制协议)：<strong>是一种面向连接的、可靠的、基于字节流的传输层通信协议</strong>，使用三次握手协议建立连接、四次挥手断开连接。面向连接意味着两个使用TCP的应用(通常是一个客户端和一个服务器)在彼此交换数据包之前必须先建立一个TCP连接。在一个TCP连接中，仅有两方进行彼此通信，广播和多播不能用TCP。TCP 协议的作用是，保证数据通信的完整性和可靠性，防止丢包。TCP把连接作为最基本的对象，每一条TCP连接都有两个端点，这种端点我们叫作套接字(socket)，端口号拼接到IP地址即构成了套接字。</p>
<p><strong>特点：</strong></p>
<ol>
<li>面向连接</li>
<li>一对一</li>
<li>可靠性高</li>
<li>有序的</li>
</ol>
<blockquote>
<p>TCP协议的可靠性是如何达到的？</p>
</blockquote>
<p>TCP协议是通过检验和、确认应答信号、重发机制、连接管理、流量控制、拥塞控制等手段达到可靠的</p>
</li>
<li><p><strong>UDP</strong>(User Datagram Protocol 用户数据报协议)：<strong>是OSI</strong>(Open System Interconnection 开放式系统互联)<strong>参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务</strong>。UDP协议的主要作用是将网络数据流量压缩成数据包的形式。</p>
</li>
<li><p>区别：</p>
<ul>
<li>TCP提供的是面向连接的、可靠的数据流传输；UDP提供的是非面向连接的、不可靠的数据流传输。</li>
<li>TCP提供可靠的服务，通过TCP连接传送的数据，无差错、不丢失、不重复，按序到达；UDP尽最大努力交付，即不保证可靠交付。</li>
<li>TCP面向字节流；UDP面向报文。</li>
<li>TCP连接只能是点到点的；UDP支持一对一、一对多、多对一和多对多的交互通信。</li>
<li>UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。</li>
<li>TCP对系统资源要求较多，UDP对系统资源要求较少。TCP首部有20字节；UDP的首部只有8个字节。</li>
<li>TCP的逻辑通信信道是全双工的可靠信道；UDP的逻辑通信信道是不可靠信道。</li>
<li>基于TCP的应用：HTTP、WebSocker、重要数据文件传输等常见</li>
<li>基于UDP的应用：QQ等部分实时通信软件、视频&#x2F;音频下载传输等。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>TCP</th>
<th>UDP</th>
</tr>
</thead>
<tbody><tr>
<td>连接方面</td>
<td>面向连接</td>
<td>无连接</td>
</tr>
<tr>
<td>是否可靠</td>
<td>可靠</td>
<td>不可靠</td>
</tr>
<tr>
<td>传输效率</td>
<td>相对UDP低</td>
<td></td>
</tr>
<tr>
<td>连接对象</td>
<td>一对一</td>
<td>n对n</td>
</tr>
</tbody></table>
<h3 id="三次握手，4次挥手"><a href="#三次握手，4次挥手" class="headerlink" title="三次握手，4次挥手"></a>三次握手，4次挥手</h3><ul>
<li><strong>三次握手</strong><ul>
<li>第一次握手：<strong>TCP连接请求，告诉服务器我要和你建立连接</strong>。客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 SYN_Send状态。</li>
<li>第二次握手：<strong>TCP授予连接，告诉客户端批准连接。</strong>服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD的状态。</li>
<li>第三次握手：<strong>TCP确认连接，告诉服务器，来就来</strong>。客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 establised状态。</li>
<li>服务器收到 ACK 报文之后，也处于 establised 状态，此时，双方以建立起了链接。</li>
</ul>
</li>
<li><strong>四次挥手</strong><ul>
<li>第一次挥手：<strong>告诉服务器我数据发完了，你如果还有消息就快发完</strong>。客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于CLOSED_WAIT1状态。</li>
<li>第二次握手：<strong>告诉客户端我知道了，请继续等待我的消息</strong>。服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT2状态。</li>
<li>第三次挥手：<strong>告诉客户端消息发完了，你可以正式断开连接了</strong>。如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK的状态。</li>
<li>第四次挥手：<strong>告诉服务器我等一会如果没有收到你回复我就断开了</strong>。客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态</li>
<li>服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</li>
</ul>
</li>
</ul>
<p><strong>总结</strong>：三次握手表示客户端和服务端进行连接的过程，四次挥手是两台设备断开连接做的什么</p>
<p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/TCP%26UDP.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="状态同步-帧同步"><a href="#状态同步-帧同步" class="headerlink" title="状态同步,帧同步"></a>状态同步,帧同步</h3><p>帧同步和状态同步该怎么选（上）<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/104932624">https://zhuanlan.zhihu.com/p/104932624</a></p>
<p>帧同步和状态同步<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/33898014">https://zhuanlan.zhihu.com/p/33898014</a></p>
<h3 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h3><p>OSI（Open System Interconnection）是由国际标准化组织（ISO）制定的网络模型，该模型定义了不同计算机如何互相连接，是设计和描述计算机网络通信的基本框架。<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=OSI%E6%A8%A1%E5%9E%8B&spm=1001.2101.3001.7020">OSI模型</a>将网络通信分为7层：</p>
<p><img src="https://img-blog.csdnimg.cn/20210530224055792.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzeTc3Nzc3Nw==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p>OSI仅是一个理论上的模型，实际使用的是TCP&#x2F;IP网络模型，TCP&#x2F;IP模型将OSI模型的应用层，表示层和会话层合并为应用层：</p>
<p><img src="https://img-blog.csdnimg.cn/20210530224106137.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzeTc3Nzc3Nw==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="img"></p>
<hr>
<h2 id="🌙Unity-网络编程"><a href="#🌙Unity-网络编程" class="headerlink" title="🌙Unity 网络编程"></a>🌙Unity 网络编程</h2><h3 id="Socket套接字有3种不同的类型"><a href="#Socket套接字有3种不同的类型" class="headerlink" title="Socket套接字有3种不同的类型"></a>Socket套接字有3种不同的类型</h3><ol>
<li><p>流套接字</p>
<ul>
<li>主要用于实现TCP通信，提供了面向连接、可靠的、有序的、数据无差错且无重复的数据传输服务</li>
</ul>
</li>
<li><p>数据报套接字</p>
<ul>
<li>主要用于实现UDP通信，提供了无连接的通信服务，数据包的长度不能大于32KB，不提供正确性检查，不保证顺序，可能出现重发、丢失等情况</li>
</ul>
</li>
<li><p>原始套接字（不常用，不深入)</p>
<ul>
<li>主要用于实现IP数据包通信，用于直接访问协议的较低层，常用于侦听和分析数据包</li>
</ul>
</li>
</ol>
<h3 id="服务端和客户端需要做什么"><a href="#服务端和客户端需要做什么" class="headerlink" title="服务端和客户端需要做什么"></a>服务端和客户端需要做什么</h3><p>客户端：</p>
<ol>
<li>创建套接字Socket </li>
<li>用Connect方法与服务端相连</li>
<li>用Send和Receive相关方法收发数据</li>
<li>用Shutdown方法释放连接 </li>
<li>关闭套接字</li>
</ol>
<p>服务端 </p>
<ol>
<li>创建套接字Socket</li>
<li>用Bind方法将套接字与本地地址绑定</li>
<li>用Listen方法监听 </li>
<li>用Accept方法等待客户端连接 </li>
<li>建立连接，Accept返回新套接字 </li>
<li>用Send和Receive相关方法收发数据</li>
<li>用Shutdown方法释放连接</li>
<li>关闭套接字</li>
</ol>
<hr>
<h2 id="🌙计算机图形学（基于Games101）"><a href="#🌙计算机图形学（基于Games101）" class="headerlink" title="🌙计算机图形学（基于Games101）"></a>🌙计算机图形学（基于Games101）</h2><blockquote>
<p> <strong>笔记来自于：<a target="_blank" rel="noopener" href="https://www.yuque.com/gaoshanliushui-mbfny/sst4c5/oq643c">https://www.yuque.com/gaoshanliushui-mbfny/sst4c5/oq643c</a></strong></p>
</blockquote>
<hr>
<h2 id="🌙算法"><a href="#🌙算法" class="headerlink" title="🌙算法"></a>🌙算法</h2><h3 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problemset/all/">题库 - 力扣 (LeetCode) 全球极客挚爱的技术成长平台</a></p>
<p><strong>每日一题</strong></p>
<p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/V2QJXN%25LGY17_GWQIJ%24%7D1W1.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="代码随想录"><a href="#代码随想录" class="headerlink" title="代码随想录"></a>代码随想录</h3><p><a target="_blank" rel="noopener" href="https://programmercarl.com/">代码随想录 (programmercarl.com)</a></p>
<h3 id="十大排序算法"><a href="#十大排序算法" class="headerlink" title="十大排序算法"></a>十大排序算法</h3><h4 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h4><p><img src="https://img-blog.csdnimg.cn/1daa0def8e454f61836f28a8d1cb2e0b.gif" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p><strong>口诀：</strong></p>
<p>外层循环 n-1;内层循环 n-1-i;两两比较做互换；</p>
<blockquote>
<p>以下代码在控制台操作，输入数字以‘逗号’隔开</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BubbleSort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] array</span>)</span><br>&#123;<br>	<span class="hljs-built_in">bool</span> isSort = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; array.Length; ++i)<br>    &#123;<br>    	isSort = <span class="hljs-literal">false</span>;<br>    	<span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; array.Length - i - <span class="hljs-number">1</span>; ++j)<br>        &#123;<br>        	<span class="hljs-keyword">if</span> (array[j] &gt; array[j + <span class="hljs-number">1</span>])<br>            &#123;<br>            	isSort = <span class="hljs-literal">true</span>;<br><br>				array[j] ^= array[j + <span class="hljs-number">1</span>];<br>                array[j + <span class="hljs-number">1</span>] ^= array[j];<br>                array[j] ^= array[j + <span class="hljs-number">1</span>];<br><br>			&#125;<br>        &#125;<br>        <br>		  	<span class="hljs-keyword">if</span> (!isSort)<br>		  		<span class="hljs-keyword">break</span>;<br>                <br>     &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>程序执行结果：</p>
<p><img src="https://img-blog.csdnimg.cn/15b1cfff79a049f0bef2dc98617d8d8d.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h4 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2.插入排序"></a>2.插入排序</h4><p><img src="https://img-blog.csdnimg.cn/d7de02f14c6c45f7ad9e75888ed6254b.gif" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InsertSort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] array</span>)</span><br>&#123;<br>    <span class="hljs-built_in">int</span> noSortValue;<br>    <span class="hljs-built_in">int</span> sortIndex;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; array.Length; ++i)<br>    &#123;<br>        noSortValue = array[i];<br>        sortIndex = i - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (sortIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; array[sortIndex] &gt; noSortValue)<br>        &#123;<br>            array[sortIndex + <span class="hljs-number">1</span>] = array[sortIndex];<br>            --sortIndex;<br>        &#125;<br>        array[sortIndex + <span class="hljs-number">1</span>] = noSortValue;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>程序执行结果：</p>
<p><img src="https://img-blog.csdnimg.cn/15b1cfff79a049f0bef2dc98617d8d8d.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h4 id="3-选择排序"><a href="#3-选择排序" class="headerlink" title="3.选择排序"></a>3.选择排序</h4><p><img src="https://img-blog.csdnimg.cn/b72900449cb44c15999f8d89c286bb69.gif" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SelectionSort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] array</span>)</span><br>&#123;<br>    <span class="hljs-built_in">int</span> index;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; array.Length; i++)<br>    &#123;<br>        index = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = i + <span class="hljs-number">1</span>; j &lt; array.Length; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (array[index] &gt; array[j])<br>            &#123;<br>                index = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (index != i)<br>        &#123;<br>            array[i] ^= array[index];<br>            array[index] ^= array[i];<br>            array[i] ^= array[index];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<p>程序执行结果：</p>
<p><img src="https://img-blog.csdnimg.cn/5ca6790d2c4740ba86e8b956475dd2bd.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h4 id="4-快速排序"><a href="#4-快速排序" class="headerlink" title="4.快速排序"></a>4.快速排序</h4><p><img src="https://img-blog.csdnimg.cn/5ff1f36a0e694cbc9ffd5f2e6089a821.gif" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p>快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists)。</p>
<p><strong>步骤为：</strong></p>
<ol>
<li><p>从数列中挑出一个元素，称为 “基准”（pivot）。</p>
</li>
<li><p>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆放在基准的后面（相同的数可以到任一边）。在这个分割结束之后，该基准就处于数列的中间位置。这个称为分割（partition）操作。</p>
</li>
<li><p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p>
</li>
</ol>
<p>递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个演算法总会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">QuickSort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] array, <span class="hljs-built_in">int</span> left, <span class="hljs-built_in">int</span> right</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (left &gt;= right)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">int</span> tempLeft, tempRight, temp;<br>    temp = array[left];<br>    tempLeft = left;<br>    tempRight = right;<br><br>    <span class="hljs-keyword">while</span> (tempLeft != tempRight)<br>    &#123;<br>        <span class="hljs-comment">//比较位置交换</span><br>        <span class="hljs-comment">//首先从右边开始比较，看值有没有资格标识的右侧</span><br>        <span class="hljs-comment">//移动右侧游标</span><br>        <span class="hljs-keyword">while</span> (tempLeft &lt; tempRight &amp;&amp;<br>            array[tempRight] &gt; temp)<br>        &#123;<br>            tempRight--;<br>        &#125;<br>        <span class="hljs-comment">//移动结束可以换位置</span><br>        array[tempLeft] = array[tempRight];<br><br>        <span class="hljs-comment">//移动左侧游标</span><br>        <span class="hljs-keyword">while</span> (tempLeft &lt; tempRight &amp;&amp;<br>            array[tempLeft] &lt; temp)<br>        &#123;<br>            tempLeft++;<br>        &#125;<br>        array[tempRight] = array[tempLeft];<br>    &#125;<br><br>    array[tempRight] = temp;<br>    QuickSort(array, left, tempRight - <span class="hljs-number">1</span>);<br>    QuickSort(array, tempLeft + <span class="hljs-number">1</span>, right);<br><br>&#125;<br><br></code></pre></td></tr></table></figure>



<h4 id="5-希尔排序"><a href="#5-希尔排序" class="headerlink" title="5.希尔排序"></a>5.希尔排序</h4><p>插入排序的升级</p>
<p><img src="https://raw.githubusercontent.com/MCIBlueMoon/PicGO_Img/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/640.gif" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">XiErSort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] array</span>)</span><br>&#123;<br>    <span class="hljs-built_in">int</span> noSortValue;<br>    <span class="hljs-built_in">int</span> sortIndex;<br>    <span class="hljs-comment">//第一次步长是第一次数组/2  所以：int step = arr.Length/2</span><br>    <span class="hljs-comment">//之后每次步长变化是step/2</span><br>    <span class="hljs-comment">//最小步长为1 stem&gt;0</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> step = array.Length / <span class="hljs-number">2</span>; step &gt; <span class="hljs-number">0</span>; step /= <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = step; i &lt; array.Length; i++)<br>        &#123;<br>            noSortValue = array[i];<br>            sortIndex = i - step;<br>            <span class="hljs-keyword">while</span> (sortIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; noSortValue &lt; array[sortIndex])<br>            &#123;<br>                array[sortIndex + step] = array[sortIndex];<br>                sortIndex -= step;<br>            &#125;<br>            array[sortIndex + step] = noSortValue;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>


<p>程序执行结果：</p>
<p><img src="https://img-blog.csdnimg.cn/2b6aaaf6b5914b2eb6efa5e559c18840.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h4 id="6-堆排序"><a href="#6-堆排序" class="headerlink" title="6.堆排序"></a>6.堆排序</h4><p>堆排序首先是构建最大堆或最小堆。最大堆是用来正序排序，最小堆是用来倒序排序。</p>
<p>最大堆是指二叉树中每个结点的值都比其左右子结点的值大。同理最小堆是指二叉树中每个结点的值都比其左右子结点的值小。</p>
<p>对于二叉树不了解，在这里可以只有一个印象就可以。二叉树就是一个结点最多只有两个左右子结点。至于什么是完全二叉树，这里就不在过多解释，以后有机会写数据结构的时候，会着重解释，但是有一点要知道，数列从上往下，从左往右，按照只有一个根结点，且每个结点有两个子结点这样构建二叉树，那么他就是一颗完全二叉树。</p>
<p>下面我用一张图，来表示上面的概念，并加深印象。</p>
<p><img src="https://img-blog.csdnimg.cn/e33fa55d2e98407ea12bbc0b99221487.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p>完全二叉树：<br>可以发现其实每个结点的下标和其左右子结点的下标是有一定关系的，即结点下标为n，左子结点下标为：2n+1，右子结点的下标为：2n+2。</p>
<p>最大堆：</p>
<p><img src="https://img-blog.csdnimg.cn/8f1362ccb2a043d98977410ba95406e2.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p>上图为第一次构建最大堆的结果</p>
<p>可以看出因为根结点要比左右子结点数值大，而且其左右子结点要比其孙子结点数值大，以此类推，此时的根结点即为数列的最大值。</p>
<p>那么我们如何把一个无序构建成一个最大堆。首先看最大堆的最大特点就是：父结点的数值一定比左右结点数值大，我们依照这个规则不断的调整结点使其满足条件即可。</p>
<p>再仔细观察堆我们发现，由一半以上的结点是没有孩子结点的，这部分结点就称为叶子结点，那么也就是说，这部分结点是不需要向下调整的。我们选择从(length&#x2F;2)-1的下标开始依次从0下标的方向进行调整。每次调整之后，调整的结点还要继续比较他的子结点看看是否仍然满足最大堆特点，一直调整到叶子结点。这样做的目的就是使数列的大值向上浮，小值向下沉。直到下标0结点（根结点）调整完成，此时就是一个最大堆。</p>
<p>此时根结点是一个最大值，我们把最大值排在无序数列最后，即把最大值与队尾交换位置。此时我们发现除了根结点，其他结点仍然是符合最大堆特点的（注意，从这个位置往后，我们讲述的情况都是排除了最后一个数，因为他已经排好了位置）。这时我们只用调整根结点就可以了，调整之后，就得到了数列的第二个最大值。依次调整，直到数列排好即可。</p>
<p><img src="https://img-blog.csdnimg.cn/5eaad2f07d4e400daff97217f6b7ab49.gif" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HeapCompare</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] array, <span class="hljs-built_in">int</span> nowIndex, <span class="hljs-built_in">int</span> arrayLength</span>)</span><br>&#123;<br>    <span class="hljs-comment">//通过传入的索引的到它对应的左右叶子结点的索引</span><br>    <span class="hljs-built_in">int</span> left = <span class="hljs-number">2</span> * nowIndex + <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">int</span> right = <span class="hljs-number">2</span> * nowIndex + <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">//用于记录较大数的索引</span><br>    <span class="hljs-built_in">int</span> bigggerIndex = nowIndex;<br>    <span class="hljs-comment">//先比左再比右</span><br>    <span class="hljs-keyword">if</span> (left &lt; arrayLength &amp;&amp; array[left] &gt; array[bigggerIndex])<br>    &#123;<br>        bigggerIndex = left;<br>    &#125;<br>    <span class="hljs-comment">//比较右结点</span><br>    <span class="hljs-keyword">if</span> (right &lt; arrayLength &amp;&amp; array[right] &gt; array[bigggerIndex])<br>    &#123;<br>        bigggerIndex = right;<br>    &#125;<br>    <span class="hljs-comment">//如果比较过后 发现最大索引发送变化 那就要换位置了</span><br>    <span class="hljs-keyword">if</span> (bigggerIndex != nowIndex)<br>    &#123;<br>        array[nowIndex] ^= array[bigggerIndex];<br>        array[bigggerIndex] ^= array[nowIndex];<br>        array[nowIndex] ^= array[bigggerIndex];<br><br>        <span class="hljs-comment">//通过递归是否影响了叶子结点的三角关系</span><br>        HeapCompare(array, bigggerIndex, arrayLength);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildBigHeap</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] array</span>)</span><br>&#123;<br>    <span class="hljs-comment">//从最大的非叶子结点索引开始，不停往前构建大堆顶</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = array.Length / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>    &#123;<br>        HeapCompare(array, i, array.Length);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HeapSort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] array</span>)</span><br>&#123;<br>    <span class="hljs-comment">//构建大堆顶</span><br>    BuildBigHeap(array);<br>    <span class="hljs-comment">//执行过后最大的数再最上层</span><br>    <span class="hljs-comment">//往屁股后面方 得到屁股后面最后一个索引</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = array.Length - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--)<br>    &#123;<br>        <span class="hljs-comment">//直接把 堆顶的顶端的数 放到最后一个</span><br>        array[<span class="hljs-number">0</span>] ^= array[i];<br>        array[i] ^= array[<span class="hljs-number">0</span>];<br>        array[<span class="hljs-number">0</span>] ^= array[i];<br>        <span class="hljs-comment">//重新进行大堆顶调整</span><br>        HeapCompare(array, <span class="hljs-number">0</span>, i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h4 id="7-归并排序"><a href="#7-归并排序" class="headerlink" title="7.归并排序"></a>7.归并排序</h4><p>归并排序是建立在归并操作上的一种有效，稳定的排序算法，该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。 将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。 若将两个有序表合并成一个有序表，称为二路归并。</p>
<p>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p>
<ul>
<li><p>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；</p>
</li>
<li><p>自下而上的迭代；</p>
</li>
</ul>
<p><strong>算法步骤</strong></p>
<ol>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li>
<li>重复步骤 3 直到某一指针达到序列尾；</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/0c66af0a2da0474d94384b06847ba235.gif" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span>[] <span class="hljs-title">MergeSort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] array</span>)</span><br>&#123;<br>    <span class="hljs-comment">// 递归结束条件</span><br>    <span class="hljs-keyword">if</span> (array.Length &lt; <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> array;<br>    <span class="hljs-comment">//1.数组分两段  得到一个中间索引</span><br>    <span class="hljs-built_in">int</span> mid = array.Length / <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">//2.初始化左右数组</span><br>    <span class="hljs-built_in">int</span>[] left = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[mid];<br>    <span class="hljs-built_in">int</span>[] right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[array.Length - mid];<br>    <span class="hljs-comment">//左右初始化内容</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; array.Length; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; mid)<br>            left[i] = array[i];<br>        <span class="hljs-keyword">else</span><br>            right[i - mid] = array[i];<br>    &#125;<br>    <span class="hljs-comment">//3.递归再分再排序</span><br>    <span class="hljs-keyword">return</span> Sort(MergeSort(left), MergeSort(right));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span>[] <span class="hljs-title">Sort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] left, <span class="hljs-built_in">int</span>[] right</span>)</span><br>&#123;<br><br>    <span class="hljs-comment">//先准备一个新数组</span><br>    <span class="hljs-built_in">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[left.Length + right.Length];<br>    <span class="hljs-built_in">int</span> leftIndex = <span class="hljs-number">0</span>;<span class="hljs-comment">//左数组索引</span><br>    <span class="hljs-built_in">int</span> rightIndex = <span class="hljs-number">0</span>;<span class="hljs-comment">//右数组索引</span><br><br>    <span class="hljs-comment">//最终目的是要填满这个新数组</span><br>    <span class="hljs-comment">//不会初心两侧都放完还在进循环</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; array.Length; i++)<br>    &#123;<br>        <span class="hljs-comment">//左侧放完了，代表右侧全部大于左侧直接方对面</span><br>        <span class="hljs-keyword">if</span> (leftIndex &gt;= left.Length)<br>        &#123;<br>            array[i] = right[rightIndex];<br>            rightIndex++;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rightIndex &gt;= right.Length)<br>        &#123;<br>            array[i] = left[leftIndex];<br>            leftIndex++;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left[leftIndex] &lt; right[rightIndex])<br>        &#123;<br>            array[i] = left[leftIndex];<br>            leftIndex++;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            array[i] = right[rightIndex];<br>            rightIndex++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> array;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="8-计数排序"><a href="#8-计数排序" class="headerlink" title="8.计数排序"></a>8.计数排序</h4><p><img src="https://img-blog.csdnimg.cn/9fbfeab31f384aad9329a49fe345f678.gif" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p>计数排序是一种适合于最大值和最小值的差值不是不是很大的排序。例如 temp[i] &#x3D; m, 表示元素 i 一共出现了 m 次</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CountSort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] arr</span>)</span><br> &#123;<br>     <span class="hljs-comment">//1.得到数列的最大值 和 最小值</span><br>     <span class="hljs-built_in">int</span> Max = arr[<span class="hljs-number">0</span>];<br>     <span class="hljs-built_in">int</span> Min = arr[<span class="hljs-number">0</span>];<br> <br>     <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; arr.Length; i++)<br>     &#123;<br>         <span class="hljs-keyword">if</span> (arr[i] &gt; Max) Max = arr[i];<br>         <span class="hljs-keyword">if</span> (arr[i] &lt; Min) Min = arr[i];<br>     &#125;<br>     <span class="hljs-comment">//2.根据数列最大值确定统计数组的长度</span><br>     <span class="hljs-built_in">int</span>[] newArr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[Max -Min+ <span class="hljs-number">1</span>];<br>     <span class="hljs-comment">//3.遍历数列，填充统计数组 记得加上 偏移量Min</span><br>     <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.Length; i++)<br>     &#123;<br>         newArr[arr[i]-Min]++;<br>     &#125;<br>     <span class="hljs-comment">//4.遍历统计数组，输出结果 记得加上 偏移量Min</span><br>     <span class="hljs-built_in">int</span> Index = <span class="hljs-number">0</span>;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; newArr.Length; i++)<br>     &#123;<br>         <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; newArr[i]; j++)<br>         &#123;<br>             arr[Index++] = i+Min;<br>         &#125;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure>

<h4 id="9-桶排序"><a href="#9-桶排序" class="headerlink" title="9.桶排序"></a>9.桶排序</h4><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p>
<p><strong>算法步骤</strong></p>
<ol>
<li>设置一个定量的数组当作空桶；</li>
<li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li>
<li>对每个不是空的桶进行排序；</li>
<li>从不是空的桶里把排好序的数据拼接起来。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/b7e8e42333e1432bb1a494d301c1c41e.gif" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 桶排序</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span> &#123;<br>        <span class="hljs-built_in">double</span>[] array = &#123; <span class="hljs-number">0.43</span>, <span class="hljs-number">0.69</span>, <span class="hljs-number">0.11</span>, <span class="hljs-number">0.72</span>, <span class="hljs-number">0.28</span>, <span class="hljs-number">0.21</span>, <span class="hljs-number">0.56</span>, <span class="hljs-number">0.80</span>, <span class="hljs-number">0.48</span>, <span class="hljs-number">0.94</span>, <span class="hljs-number">0.32</span>, <span class="hljs-number">0.08</span> &#125;;<br><br>        BucketSort(array, <span class="hljs-number">10</span>);<br>        ShowSord(array);<br><br>        Console.ReadKey();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ShowSord</span>(<span class="hljs-params"><span class="hljs-built_in">double</span>[] array</span>)</span> &#123;<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> num <span class="hljs-keyword">in</span> array) &#123;<br>            Console.Write(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;num&#125;</span> &quot;</span>);<br>        &#125;<br>        Console.WriteLine();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BucketSort</span>(<span class="hljs-params"><span class="hljs-built_in">double</span>[] array, <span class="hljs-built_in">int</span> bucketNum</span>)</span> &#123;<br>        <span class="hljs-comment">//创建bucket时，在二维中增加一组标识位，其中bucket[x, 0]表示这一维所包含的数字的个数</span><br>        <span class="hljs-comment">//通过这样的技巧可以少写很多代码</span><br>        <span class="hljs-built_in">double</span>[,] bucket = <span class="hljs-keyword">new</span> <span class="hljs-built_in">double</span>[bucketNum, array.Length + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> num <span class="hljs-keyword">in</span> array) &#123;<br>            <span class="hljs-built_in">int</span> bit = (<span class="hljs-built_in">int</span>)(<span class="hljs-number">10</span> * num);<br>            bucket[bit, (<span class="hljs-built_in">int</span>)++bucket[bit, <span class="hljs-number">0</span>]] = num;<br>        &#125;<br>        <span class="hljs-comment">//为桶里的每一行使用插入排序</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; bucketNum; j++) &#123;<br>            <span class="hljs-comment">//为桶里的行创建新的数组后使用插入排序</span><br>            <span class="hljs-built_in">double</span>[] insertion = <span class="hljs-keyword">new</span> <span class="hljs-built_in">double</span>[(<span class="hljs-built_in">int</span>)bucket[j, <span class="hljs-number">0</span>]];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> k = <span class="hljs-number">0</span>; k &lt; insertion.Length; k++) &#123;<br>                insertion[k] = bucket[j, k + <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-comment">//插入排序</span><br>            StraightInsertionSort(insertion);<br>            <span class="hljs-comment">//把排好序的结果回写到桶里</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> k = <span class="hljs-number">0</span>; k &lt; insertion.Length; k++) &#123;<br>                bucket[j, k + <span class="hljs-number">1</span>] = insertion[k];<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//将所有桶里的数据回写到原数组中</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> count = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; j &lt; bucketNum; j++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> k = <span class="hljs-number">1</span>; k &lt;= bucket[j, <span class="hljs-number">0</span>]; k++) &#123;<br>                array[count++] = bucket[j, k];<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">StraightInsertionSort</span>(<span class="hljs-params"><span class="hljs-built_in">double</span>[] array</span>)</span> &#123;<br>        <span class="hljs-comment">//插入排序</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; array.Length; i++) &#123;<br>            <span class="hljs-built_in">double</span> sentinel = array[i];<br>            <span class="hljs-built_in">int</span> j = i - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; sentinel &lt; array[j]) &#123;<br>                array[j + <span class="hljs-number">1</span>] = array[j];<br>                j--;<br>            &#125;<br>            array[j + <span class="hljs-number">1</span>] = sentinel;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>


<h4 id="10-基数排序"><a href="#10-基数排序" class="headerlink" title="10.基数排序"></a>10.基数排序</h4><p>基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数；</p>
<p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</p>
<p>基数相对于其他排序，算法逻辑和代码都相对简单。<br>代码方面，也都是和另外两个排序的顺序一致。<br>与另外两个非比较排序不同的是：<br>计数排序和桶排序是基于数组索引来的，所以只能排序整数<br>但是基于数的计数而定，所以在改造后，理论上是也可以排序非整数</p>
<p><strong>算法步骤</strong></p>
<ol>
<li><p>求最值，取得数组中的最大数，并取得位数；</p>
</li>
<li><p>初新组，此处新组是指新桶，桶大小为10(因为基数只有0-10)；</p>
</li>
<li><p>正填充，将对应基数的数字放到对应的桶中</p>
</li>
<li><p>将桶中的数据反填充到array数组中</p>
</li>
</ol>
<blockquote>
<p>注：正反填充需要进行循环，循环次数为步骤一的位数 </p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/de00f05f30634bf3aa413803b3f35d4b.gif" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span>[] <span class="hljs-title">RadixSort2</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] array</span>)</span><br>&#123;<br>    <span class="hljs-comment">//求最(大)值</span><br>    <span class="hljs-built_in">int</span> max = array[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> array)<br>    &#123;<br>        max = item &gt; max ? item : max;<br>    &#125;<br><br>    <span class="hljs-built_in">int</span> maxDigit = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(max!=<span class="hljs-number">0</span>)<br>    &#123;<br>        max /= <span class="hljs-number">10</span>;maxDigit++;<br>    &#125;<br>    <span class="hljs-comment">//初新桶</span><br>    <span class="hljs-keyword">var</span> bucket = <span class="hljs-keyword">new</span> List&lt;List&lt;<span class="hljs-built_in">int</span>&gt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        bucket.Add(<span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;());<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; maxDigit; i++)<br>    &#123;<br>        <span class="hljs-comment">//正填充</span><br>        <span class="hljs-built_in">int</span> div = (<span class="hljs-built_in">int</span>)Math.Pow(<span class="hljs-number">10</span>, (i + <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> array)<br>        &#123;<br>            <span class="hljs-comment">//获取基数</span><br>            <span class="hljs-built_in">int</span> radix = (item % div) / (div / <span class="hljs-number">10</span>);<br>            bucket[radix].Add(item);<br>        &#125;<br>        <span class="hljs-comment">//反填充（//反填充要注意顺序）</span><br>        <span class="hljs-built_in">int</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> bucket)<br>        &#123;<br>            <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> it <span class="hljs-keyword">in</span> item)<br>            &#123;<br>                array[index++] = it;                        <br>            &#125;<br>            item.Clear();<span class="hljs-comment">//清除数据</span><br>        &#125;                <br>    &#125;<br>    <span class="hljs-keyword">return</span> array;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/49a4114d2323450792d15706511acdf4.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/842750f7516f4a62aa62e32a07190c1d.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a target="_blank" rel="noopener" href="https://raindust.blog.csdn.net/article/details/104127820">C#十大排序算法</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/weiios/p/3933994.html">C#快速排序详解</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e4d0990dd0bd">排序算法2|简单选择排序与堆排序（C#）</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/cdaniu/p/16370507.html">【C# 排序】归并排序 merge sort</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/liuyi89430/article/details/107612559">C#计数排序</a><br><a target="_blank" rel="noopener" href="https://bbs.huaweicloud.com/blogs/313568">【愚公系列】2021年11月 C#版 数据结构与算法解析(桶排序)</a><br><a target="_blank" rel="noopener" href="https://www.freesion.com/article/96281055419/">C# 算法之基数排序排序(非比较排序之三)</a></p>
<hr>
<h2 id="🌙设计模式"><a href="#🌙设计模式" class="headerlink" title="🌙设计模式"></a>🌙设计模式</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Impulse/p/4685463.html">C#设计模式总结 - 凡的世界 - 博客园 (cnblogs.com)</a></p>
<p><a href="https://bmtan.cc/2022/06/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">C# 设计模式 - Bmtan</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E9%9D%A2%E8%AF%95/" class="category-chain-item">面试</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Unity/">#Unity</a>
      
        <a href="/tags/C/">#C#</a>
      
        <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">#计算机网络</a>
      
        <a href="/tags/Lua/">#Lua</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Unity 客户端面试</div>
      <div>http://bmtan.cc/2023/02/01/Unity客户端面试/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Bmtan</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年2月1日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/07/30/AssetBundle%20%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD/" title="AssetBundle包 同步异步加载">
                        <span class="hidden-mobile">AssetBundle包 同步异步加载</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
